{"version":3,"sources":["out-vscode/vs/code/node/fake","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/assert.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/decorators.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/arrays.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/json.ts","out-vscode/vs/code/node/vs/base/common/performance.js","out-vscode/vs/code/node/vs/base/common/semver/semver.js","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/stream.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/buffer.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/objects.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/console.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/marshalling.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/glob.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/labels.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/node/decoder.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/node/extpath.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/node/powershell.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/node/watcher.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/parts/ipc/common/ipc.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/parts/storage/common/storage.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/date.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/common/errorMessage.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/node/processes.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/node/shell.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/environment/common/environmentService.ts","out-vscode/vs/code/node/vs/platform/environment/node/userDataPath.js","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/environment/node/environmentService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/common/extensionNls.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensions/common/extensionValidator.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/node/watcher/nsfw/watcherService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/node/watcher/unix/watcherService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/node/watcher/win32/csharpWatcherService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/node/watcher/win32/watcherService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/instantiation/common/descriptors.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/instantiation/common/graph.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/download/common/download.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/environment/common/environment.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/common/extensionManagement.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensions/common/extensions.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/common/extensionManagementUtil.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/common/extensionManagementCLIService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/node/extensionsManifestCache.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/environment/node/shellEnv.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/node/watcher/watcher.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/node/watcher/nodejs/watcherService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/instantiation/common/serviceCollection.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/instantiation/common/instantiationService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/localizations/common/localizations.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/log/common/log.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/node/extensionDownloader.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/node/extensionLifecycle.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/node/extensionsWatcher.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/localizations/node/localizations.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/log/node/spdlogLog.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/common/io.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/common/fileService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/files/node/diskFileSystemProvider.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/product/common/productService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/registry/common/platform.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/jsonschemas/common/jsonContributionRegistry.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/configuration/common/configurationRegistry.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/configuration/common/configuration.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/configuration/common/configurationModels.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/configuration/common/configurationService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/request/common/request.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/request/node/proxy.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/serviceMachineId/common/serviceMachineId.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/state/node/state.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/state/node/stateService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/storage/common/storage.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/telemetry/common/commonProperties.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/telemetry/common/telemetry.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/common/extensionGalleryService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/telemetry/common/telemetryService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/telemetry/common/telemetryUtils.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/telemetry/node/appInsightsAppender.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/telemetry/node/telemetry.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/base/node/zip.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/node/extensionManagementUtil.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/node/extensionsScanner.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/extensionManagement/node/extensionManagementService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/platform/request/node/requestService.ts","out-vscode/vs/code/node/file:/Volumes/DATA/projects/vscode-web/vscode/src/vs/code/node/cliProcessMain.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function createDecorator(mapFn: (fn: Function, key: string) => Function): Function {\n\treturn (target: any, key: string, descriptor: any) => {\n\t\tlet fnKey: string | null = null;\n\t\tlet fn: Function | null = null;\n\n\t\tif (typeof descriptor.value === 'function') {\n\t\t\tfnKey = 'value';\n\t\t\tfn = descriptor.value;\n\t\t} else if (typeof descriptor.get === 'function') {\n\t\t\tfnKey = 'get';\n\t\t\tfn = descriptor.get;\n\t\t}\n\n\t\tif (!fn) {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\n\t\tdescriptor[fnKey!] = mapFn(fn, key);\n\t};\n}\n\nlet memoizeId = 0;\nexport function createMemoizer() {\n\tconst memoizeKeyPrefix = `$memoize${memoizeId++}`;\n\tlet self: any = undefined;\n\n\tconst result = function memoize(target: any, key: string, descriptor: any) {\n\t\tlet fnKey: string | null = null;\n\t\tlet fn: Function | null = null;\n\n\t\tif (typeof descriptor.value === 'function') {\n\t\t\tfnKey = 'value';\n\t\t\tfn = descriptor.value;\n\n\t\t\tif (fn!.length !== 0) {\n\t\t\t\tconsole.warn('Memoize should only be used in functions with zero parameters');\n\t\t\t}\n\t\t} else if (typeof descriptor.get === 'function') {\n\t\t\tfnKey = 'get';\n\t\t\tfn = descriptor.get;\n\t\t}\n\n\t\tif (!fn) {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\n\t\tconst memoizeKey = `${memoizeKeyPrefix}:${key}`;\n\t\tdescriptor[fnKey!] = function (...args: any[]) {\n\t\t\tself = this;\n\n\t\t\tif (!this.hasOwnProperty(memoizeKey)) {\n\t\t\t\tObject.defineProperty(this, memoizeKey, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: fn!.apply(this, args)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this[memoizeKey];\n\t\t};\n\t};\n\n\tresult.clear = () => {\n\t\tif (typeof self === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tObject.getOwnPropertyNames(self).forEach(property => {\n\t\t\tif (property.indexOf(memoizeKeyPrefix) === 0) {\n\t\t\t\tdelete self[property];\n\t\t\t}\n\t\t});\n\t};\n\n\treturn result;\n}\n\nexport function memoize(target: any, key: string, descriptor: any) {\n\treturn createMemoizer()(target, key, descriptor);\n}\n\nexport interface IDebounceReducer<T> {\n\t(previousValue: T, ...args: any[]): T;\n}\n\nexport function debounce<T>(delay: number, reducer?: IDebounceReducer<T>, initialValueProvider?: () => T): Function {\n\treturn createDecorator((fn, key) => {\n\t\tconst timerKey = `$debounce$${key}`;\n\t\tconst resultKey = `$debounce$result$${key}`;\n\n\t\treturn function (this: any, ...args: any[]) {\n\t\t\tif (!this[resultKey]) {\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}\n\n\t\t\tclearTimeout(this[timerKey]);\n\n\t\t\tif (reducer) {\n\t\t\t\tthis[resultKey] = reducer(this[resultKey], ...args);\n\t\t\t\targs = [this[resultKey]];\n\t\t\t}\n\n\t\t\tthis[timerKey] = setTimeout(() => {\n\t\t\t\tfn.apply(this, args);\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}, delay);\n\t\t};\n\t});\n}\n\nexport function throttle<T>(delay: number, reducer?: IDebounceReducer<T>, initialValueProvider?: () => T): Function {\n\treturn createDecorator((fn, key) => {\n\t\tconst timerKey = `$throttle$timer$${key}`;\n\t\tconst resultKey = `$throttle$result$${key}`;\n\t\tconst lastRunKey = `$throttle$lastRun$${key}`;\n\t\tconst pendingKey = `$throttle$pending$${key}`;\n\n\t\treturn function (this: any, ...args: any[]) {\n\t\t\tif (!this[resultKey]) {\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}\n\t\t\tif (this[lastRunKey] === null || this[lastRunKey] === undefined) {\n\t\t\t\tthis[lastRunKey] = -Number.MAX_VALUE;\n\t\t\t}\n\n\t\t\tif (reducer) {\n\t\t\t\tthis[resultKey] = reducer(this[resultKey], ...args);\n\t\t\t}\n\n\t\t\tif (this[pendingKey]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextTime = this[lastRunKey] + delay;\n\t\t\tif (nextTime <= Date.now()) {\n\t\t\t\tthis[lastRunKey] = Date.now();\n\t\t\t\tfn.apply(this, [this[resultKey]]);\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t} else {\n\t\t\t\tthis[pendingKey] = true;\n\t\t\t\tthis[timerKey] = setTimeout(() => {\n\t\t\t\t\tthis[pendingKey] = false;\n\t\t\t\t\tthis[lastRunKey] = Date.now();\n\t\t\t\t\tfn.apply(this, [this[resultKey]]);\n\t\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t\t}, nextTime - Date.now());\n\t\t\t}\n\t\t};\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { canceled } from 'vs/base/common/errors';\nimport { ISplice } from 'vs/base/common/sequence';\n\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail<T>(array: ArrayLike<T>, n: number = 0): T {\n\treturn array[array.length - (1 + n)];\n}\n\nexport function tail2<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\tlet low = 0,\n\t\thigh = array.length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = comparator(array[mid], key);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted<T>(array: ReadonlyArray<T>, p: (x: T) => boolean): number {\n\tlet low = 0, high = array.length;\n\tif (high === 0) {\n\t\treturn 0; // no children\n\t}\n\twhile (low < high) {\n\t\tconst mid = Math.floor((low + high) / 2);\n\t\tif (p(array[mid])) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn low;\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tlet pivotValue = data[Math.floor(data.length * Math.random())];\n\tlet lower: T[] = [];\n\tlet higher: T[] = [];\n\tlet pivots: T[] = [];\n\n\tfor (let value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of data.slice(0).sort(compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[], added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // nextTick() would starve I/O.\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow canceled();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstInSorted(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn <T[]>array.filter(e => !!e);\n}\n\n/**\n * Remove all falsey values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): void {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * Moves the element in the array for the provided positions.\n */\nexport function move(array: any[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: any): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn?: (t: T) => string): T[] {\n\tif (!keyFn) {\n\t\treturn array.filter((element, position) => {\n\t\t\treturn array.indexOf(element) === position;\n\t\t});\n\t}\n\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\treturn array.filter((elem) => {\n\t\tconst key = keyFn(elem);\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\n\t\treturn true;\n\t});\n}\n\nexport function distinctES6<T>(array: ReadonlyArray<T>): T[] {\n\tconst seen = new Set<T>();\n\treturn array.filter(element => {\n\t\tif (seen.has(element)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(element);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T>(keyFn: (t: T) => string): (t: T) => boolean {\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\t\treturn true;\n\t};\n}\n\nexport function lastIndex<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean): number {\n\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (fn(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue: NotFound): T | NotFound;\nexport function firstOrDefault<T>(array: ReadonlyArray<T>): T | undefined;\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue?: NotFound): T | NotFound | undefined {\n\treturn array.length > 0 ? array[0] : notFoundValue;\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function flatten<T>(arr: T[][]): T[] {\n\treturn (<T[]>[]).concat(...arr);\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R; } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFind<T, R>(array: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of array) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum ScanError {\n\tNone = 0,\n\tUnexpectedEndOfComment = 1,\n\tUnexpectedEndOfString = 2,\n\tUnexpectedEndOfNumber = 3,\n\tInvalidUnicode = 4,\n\tInvalidEscapeCharacter = 5,\n\tInvalidCharacter = 6\n}\n\nexport const enum SyntaxKind {\n\tOpenBraceToken = 1,\n\tCloseBraceToken = 2,\n\tOpenBracketToken = 3,\n\tCloseBracketToken = 4,\n\tCommaToken = 5,\n\tColonToken = 6,\n\tNullKeyword = 7,\n\tTrueKeyword = 8,\n\tFalseKeyword = 9,\n\tStringLiteral = 10,\n\tNumericLiteral = 11,\n\tLineCommentTrivia = 12,\n\tBlockCommentTrivia = 13,\n\tLineBreakTrivia = 14,\n\tTrivia = 15,\n\tUnknown = 16,\n\tEOF = 17\n}\n\n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n\t/**\n\t * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n\t */\n\tsetPosition(pos: number): void;\n\t/**\n\t * Read the next token. Returns the token code.\n\t */\n\tscan(): SyntaxKind;\n\t/**\n\t * Returns the current scan position, which is after the last read token.\n\t */\n\tgetPosition(): number;\n\t/**\n\t * Returns the last read token.\n\t */\n\tgetToken(): SyntaxKind;\n\t/**\n\t * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n\t */\n\tgetTokenValue(): string;\n\t/**\n\t * The start offset of the last read token.\n\t */\n\tgetTokenOffset(): number;\n\t/**\n\t * The length of the last read token.\n\t */\n\tgetTokenLength(): number;\n\t/**\n\t * An error code of the last scan.\n\t */\n\tgetTokenError(): ScanError;\n}\n\n\n\nexport interface ParseError {\n\terror: ParseErrorCode;\n\toffset: number;\n\tlength: number;\n}\n\nexport const enum ParseErrorCode {\n\tInvalidSymbol = 1,\n\tInvalidNumberFormat = 2,\n\tPropertyNameExpected = 3,\n\tValueExpected = 4,\n\tColonExpected = 5,\n\tCommaExpected = 6,\n\tCloseBraceExpected = 7,\n\tCloseBracketExpected = 8,\n\tEndOfFileExpected = 9,\n\tInvalidCommentToken = 10,\n\tUnexpectedEndOfComment = 11,\n\tUnexpectedEndOfString = 12,\n\tUnexpectedEndOfNumber = 13,\n\tInvalidUnicode = 14,\n\tInvalidEscapeCharacter = 15,\n\tInvalidCharacter = 16\n}\n\nexport type NodeType = 'object' | 'array' | 'property' | 'string' | 'number' | 'boolean' | 'null';\n\nexport interface Node {\n\treadonly type: NodeType;\n\treadonly value?: any;\n\treadonly offset: number;\n\treadonly length: number;\n\treadonly colonOffset?: number;\n\treadonly parent?: Node;\n\treadonly children?: Node[];\n}\n\nexport type Segment = string | number;\nexport type JSONPath = Segment[];\n\nexport interface Location {\n\t/**\n\t * The previous property key or literal value (string, number, boolean or null) or undefined.\n\t */\n\tpreviousNode?: Node;\n\t/**\n\t * The path describing the location in the JSON document. The path consists of a sequence strings\n\t * representing an object property or numbers for array indices.\n\t */\n\tpath: JSONPath;\n\t/**\n\t * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n\t * '*' will match a single segment, of any property name or index.\n\t * '**' will match a sequence of segments or no segment, of any property name or index.\n\t */\n\tmatches: (patterns: JSONPath) => boolean;\n\t/**\n\t * If set, the location's offset is at a property key.\n\t */\n\tisAtPropertyKey: boolean;\n}\n\nexport interface ParseOptions {\n\tdisallowComments?: boolean;\n\tallowTrailingComma?: boolean;\n\tallowEmptyContent?: boolean;\n}\n\nexport namespace ParseOptions {\n\texport const DEFAULT = {\n\t\tallowTrailingComma: true\n\t};\n}\n\nexport interface JSONVisitor {\n\t/**\n\t * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n\t */\n\tonObjectBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a property is encountered. The offset and length represent the location of the property name.\n\t */\n\tonObjectProperty?: (property: string, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n\t */\n\tonObjectEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n\t */\n\tonArrayBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n\t */\n\tonArrayEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n\t */\n\tonLiteralValue?: (value: any, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n\t */\n\tonSeparator?: (character: string, offset: number, length: number) => void;\n\n\t/**\n\t * When comments are allowed, invoked when a line or block comment is encountered. The offset and length represent the location of the comment.\n\t */\n\tonComment?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked on an error.\n\t */\n\tonError?: (error: ParseErrorCode, offset: number, length: number) => void;\n}\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text: string, ignoreTrivia: boolean = false): JSONScanner {\n\n\tlet pos = 0,\n\t\tlen = text.length,\n\t\tvalue: string = '',\n\t\ttokenOffset = 0,\n\t\ttoken: SyntaxKind = SyntaxKind.Unknown,\n\t\tscanError: ScanError = ScanError.None;\n\n\tfunction scanHexDigits(count: number): number {\n\t\tlet digits = 0;\n\t\tlet hexValue = 0;\n\t\twhile (digits < count) {\n\t\t\tconst ch = text.charCodeAt(pos);\n\t\t\tif (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes._0;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes.A + 10;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes.a + 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t\tdigits++;\n\t\t}\n\t\tif (digits < count) {\n\t\t\thexValue = -1;\n\t\t}\n\t\treturn hexValue;\n\t}\n\n\tfunction setPosition(newPosition: number) {\n\t\tpos = newPosition;\n\t\tvalue = '';\n\t\ttokenOffset = 0;\n\t\ttoken = SyntaxKind.Unknown;\n\t\tscanError = ScanError.None;\n\t}\n\n\tfunction scanNumber(): string {\n\t\tconst start = pos;\n\t\tif (text.charCodeAt(pos) === CharacterCodes._0) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t\treturn text.substring(start, pos);\n\t\t\t}\n\t\t}\n\t\tlet end = pos;\n\t\tif (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tend = pos;\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t}\n\t\t}\n\t\treturn text.substring(start, end);\n\t}\n\n\tfunction scanString(): string {\n\n\t\tlet result = '',\n\t\t\tstart = pos;\n\n\t\twhile (true) {\n\t\t\tif (pos >= len) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst ch = text.charCodeAt(pos);\n\t\t\tif (ch === CharacterCodes.doubleQuote) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch === CharacterCodes.backslash) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tif (pos >= len) {\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst ch2 = text.charCodeAt(pos++);\n\t\t\t\tswitch (ch2) {\n\t\t\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\t\t\tresult += '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.backslash:\n\t\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.slash:\n\t\t\t\t\t\tresult += '/';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.b:\n\t\t\t\t\t\tresult += '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.f:\n\t\t\t\t\t\tresult += '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.n:\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.r:\n\t\t\t\t\t\tresult += '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.t:\n\t\t\t\t\t\tresult += '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.u:\n\t\t\t\t\t\tconst ch3 = scanHexDigits(4);\n\t\t\t\t\t\tif (ch3 >= 0) {\n\t\t\t\t\t\t\tresult += String.fromCharCode(ch3);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscanError = ScanError.InvalidUnicode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tscanError = ScanError.InvalidEscapeCharacter;\n\t\t\t\t}\n\t\t\t\tstart = pos;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch >= 0 && ch <= 0x1F) {\n\t\t\t\tif (isLineBreak(ch)) {\n\t\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tscanError = ScanError.InvalidCharacter;\n\t\t\t\t\t// mark as error but continue with string\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction scanNext(): SyntaxKind {\n\n\t\tvalue = '';\n\t\tscanError = ScanError.None;\n\n\t\ttokenOffset = pos;\n\n\t\tif (pos >= len) {\n\t\t\t// at the end\n\t\t\ttokenOffset = len;\n\t\t\treturn token = SyntaxKind.EOF;\n\t\t}\n\n\t\tlet code = text.charCodeAt(pos);\n\t\t// trivia: whitespace\n\t\tif (isWhitespace(code)) {\n\t\t\tdo {\n\t\t\t\tpos++;\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t} while (isWhitespace(code));\n\n\t\t\treturn token = SyntaxKind.Trivia;\n\t\t}\n\n\t\t// trivia: newlines\n\t\tif (isLineBreak(code)) {\n\t\t\tpos++;\n\t\t\tvalue += String.fromCharCode(code);\n\t\t\tif (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n\t\t\t\tpos++;\n\t\t\t\tvalue += '\\n';\n\t\t\t}\n\t\t\treturn token = SyntaxKind.LineBreakTrivia;\n\t\t}\n\n\t\tswitch (code) {\n\t\t\t// tokens: []{}:,\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBraceToken;\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBraceToken;\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBracketToken;\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBracketToken;\n\t\t\tcase CharacterCodes.colon:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.ColonToken;\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CommaToken;\n\n\t\t\t// strings\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\tpos++;\n\t\t\t\tvalue = scanString();\n\t\t\t\treturn token = SyntaxKind.StringLiteral;\n\n\t\t\t// comments\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\tconst start = pos - 1;\n\t\t\t\t// Single-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\twhile (pos < len) {\n\t\t\t\t\t\tif (isLineBreak(text.charCodeAt(pos))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\n\t\t\t\t\t}\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.LineCommentTrivia;\n\t\t\t\t}\n\n\t\t\t\t// Multi-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\tconst safeLength = len - 1; // For lookahead.\n\t\t\t\t\tlet commentClosed = false;\n\t\t\t\t\twhile (pos < safeLength) {\n\t\t\t\t\t\tconst ch = text.charCodeAt(pos);\n\n\t\t\t\t\t\tif (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\t\tcommentClosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!commentClosed) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tscanError = ScanError.UnexpectedEndOfComment;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.BlockCommentTrivia;\n\t\t\t\t}\n\t\t\t\t// just a single slash\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\n\t\t\t// numbers\n\t\t\tcase CharacterCodes.minus:\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\tif (pos === len || !isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t// found a minus, followed by a number so\n\t\t\t// we fall through to proceed with scanning\n\t\t\t// numbers\n\t\t\tcase CharacterCodes._0:\n\t\t\tcase CharacterCodes._1:\n\t\t\tcase CharacterCodes._2:\n\t\t\tcase CharacterCodes._3:\n\t\t\tcase CharacterCodes._4:\n\t\t\tcase CharacterCodes._5:\n\t\t\tcase CharacterCodes._6:\n\t\t\tcase CharacterCodes._7:\n\t\t\tcase CharacterCodes._8:\n\t\t\tcase CharacterCodes._9:\n\t\t\t\tvalue += scanNumber();\n\t\t\t\treturn token = SyntaxKind.NumericLiteral;\n\t\t\t// literals and unknown symbols\n\t\t\tdefault:\n\t\t\t\t// is a literal? Read the full word.\n\t\t\t\twhile (pos < len && isUnknownContentCharacter(code)) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t\t}\n\t\t\t\tif (tokenOffset !== pos) {\n\t\t\t\t\tvalue = text.substring(tokenOffset, pos);\n\t\t\t\t\t// keywords: true, false, null\n\t\t\t\t\tswitch (value) {\n\t\t\t\t\t\tcase 'true': return token = SyntaxKind.TrueKeyword;\n\t\t\t\t\t\tcase 'false': return token = SyntaxKind.FalseKeyword;\n\t\t\t\t\t\tcase 'null': return token = SyntaxKind.NullKeyword;\n\t\t\t\t\t}\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// some\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t}\n\t}\n\n\tfunction isUnknownContentCharacter(code: CharacterCodes) {\n\t\tif (isWhitespace(code) || isLineBreak(code)) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (code) {\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\tcase CharacterCodes.colon:\n\t\t\tcase CharacterCodes.comma:\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tfunction scanNextNonTrivia(): SyntaxKind {\n\t\tlet result: SyntaxKind;\n\t\tdo {\n\t\t\tresult = scanNext();\n\t\t} while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n\t\treturn result;\n\t}\n\n\treturn {\n\t\tsetPosition: setPosition,\n\t\tgetPosition: () => pos,\n\t\tscan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n\t\tgetToken: () => token,\n\t\tgetTokenValue: () => value,\n\t\tgetTokenOffset: () => tokenOffset,\n\t\tgetTokenLength: () => pos - tokenOffset,\n\t\tgetTokenError: () => scanError\n\t};\n}\n\nfunction isWhitespace(ch: number): boolean {\n\treturn ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n\t\tch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n\t\tch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n}\n\nfunction isLineBreak(ch: number): boolean {\n\treturn ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n}\n\nfunction isDigit(ch: number): boolean {\n\treturn ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n}\n\nconst enum CharacterCodes {\n\tnullCharacter = 0,\n\tmaxAsciiCharacter = 0x7F,\n\n\tlineFeed = 0x0A,              // \\n\n\tcarriageReturn = 0x0D,        // \\r\n\tlineSeparator = 0x2028,\n\tparagraphSeparator = 0x2029,\n\n\t// REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n\t// like an odd disparity?  (Or maybe it's completely fine for them to be different).\n\tnextLine = 0x0085,\n\n\t// Unicode 3.0 space characters\n\tspace = 0x0020,   // \" \"\n\tnonBreakingSpace = 0x00A0,   //\n\tenQuad = 0x2000,\n\temQuad = 0x2001,\n\tenSpace = 0x2002,\n\temSpace = 0x2003,\n\tthreePerEmSpace = 0x2004,\n\tfourPerEmSpace = 0x2005,\n\tsixPerEmSpace = 0x2006,\n\tfigureSpace = 0x2007,\n\tpunctuationSpace = 0x2008,\n\tthinSpace = 0x2009,\n\thairSpace = 0x200A,\n\tzeroWidthSpace = 0x200B,\n\tnarrowNoBreakSpace = 0x202F,\n\tideographicSpace = 0x3000,\n\tmathematicalSpace = 0x205F,\n\togham = 0x1680,\n\n\t_ = 0x5F,\n\t$ = 0x24,\n\n\t_0 = 0x30,\n\t_1 = 0x31,\n\t_2 = 0x32,\n\t_3 = 0x33,\n\t_4 = 0x34,\n\t_5 = 0x35,\n\t_6 = 0x36,\n\t_7 = 0x37,\n\t_8 = 0x38,\n\t_9 = 0x39,\n\n\ta = 0x61,\n\tb = 0x62,\n\tc = 0x63,\n\td = 0x64,\n\te = 0x65,\n\tf = 0x66,\n\tg = 0x67,\n\th = 0x68,\n\ti = 0x69,\n\tj = 0x6A,\n\tk = 0x6B,\n\tl = 0x6C,\n\tm = 0x6D,\n\tn = 0x6E,\n\to = 0x6F,\n\tp = 0x70,\n\tq = 0x71,\n\tr = 0x72,\n\ts = 0x73,\n\tt = 0x74,\n\tu = 0x75,\n\tv = 0x76,\n\tw = 0x77,\n\tx = 0x78,\n\ty = 0x79,\n\tz = 0x7A,\n\n\tA = 0x41,\n\tB = 0x42,\n\tC = 0x43,\n\tD = 0x44,\n\tE = 0x45,\n\tF = 0x46,\n\tG = 0x47,\n\tH = 0x48,\n\tI = 0x49,\n\tJ = 0x4A,\n\tK = 0x4B,\n\tL = 0x4C,\n\tM = 0x4D,\n\tN = 0x4E,\n\tO = 0x4F,\n\tP = 0x50,\n\tQ = 0x51,\n\tR = 0x52,\n\tS = 0x53,\n\tT = 0x54,\n\tU = 0x55,\n\tV = 0x56,\n\tW = 0x57,\n\tX = 0x58,\n\tY = 0x59,\n\tZ = 0x5A,\n\n\tampersand = 0x26,             // &\n\tasterisk = 0x2A,              // *\n\tat = 0x40,                    // @\n\tbackslash = 0x5C,             // \\\n\tbar = 0x7C,                   // |\n\tcaret = 0x5E,                 // ^\n\tcloseBrace = 0x7D,            // }\n\tcloseBracket = 0x5D,          // ]\n\tcloseParen = 0x29,            // )\n\tcolon = 0x3A,                 // :\n\tcomma = 0x2C,                 // ,\n\tdot = 0x2E,                   // .\n\tdoubleQuote = 0x22,           // \"\n\tequals = 0x3D,                // =\n\texclamation = 0x21,           // !\n\tgreaterThan = 0x3E,           // >\n\tlessThan = 0x3C,              // <\n\tminus = 0x2D,                 // -\n\topenBrace = 0x7B,             // {\n\topenBracket = 0x5B,           // [\n\topenParen = 0x28,             // (\n\tpercent = 0x25,               // %\n\tplus = 0x2B,                  // +\n\tquestion = 0x3F,              // ?\n\tsemicolon = 0x3B,             // ;\n\tsingleQuote = 0x27,           // '\n\tslash = 0x2F,                 // /\n\ttilde = 0x7E,                 // ~\n\n\tbackspace = 0x08,             // \\b\n\tformFeed = 0x0C,              // \\f\n\tbyteOrderMark = 0xFEFF,\n\ttab = 0x09,                   // \\t\n\tverticalTab = 0x0B,           // \\v\n}\n\ninterface NodeImpl extends Node {\n\ttype: NodeType;\n\tvalue?: any;\n\toffset: number;\n\tlength: number;\n\tcolonOffset?: number;\n\tparent?: NodeImpl;\n\tchildren?: NodeImpl[];\n}\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text: string, position: number): Location {\n\tconst segments: Segment[] = []; // strings or numbers\n\tconst earlyReturnException = new Object();\n\tlet previousNode: NodeImpl | undefined = undefined;\n\tconst previousNodeInst: NodeImpl = {\n\t\tvalue: {},\n\t\toffset: 0,\n\t\tlength: 0,\n\t\ttype: 'object',\n\t\tparent: undefined\n\t};\n\tlet isAtPropertyKey = false;\n\tfunction setPreviousNode(value: string, offset: number, length: number, type: NodeType) {\n\t\tpreviousNodeInst.value = value;\n\t\tpreviousNodeInst.offset = offset;\n\t\tpreviousNodeInst.length = length;\n\t\tpreviousNodeInst.type = type;\n\t\tpreviousNodeInst.colonOffset = undefined;\n\t\tpreviousNode = previousNodeInst;\n\t}\n\ttry {\n\n\t\tvisit(text, {\n\t\t\tonObjectBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tisAtPropertyKey = position > offset;\n\t\t\t\tsegments.push(''); // push a placeholder (will be replaced)\n\t\t\t},\n\t\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(name, offset, length, 'property');\n\t\t\t\tsegments[segments.length - 1] = name;\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.push(0);\n\t\t\t},\n\t\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(value, offset, length, getNodeType(value));\n\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tif (sep === ':' && previousNode && previousNode.type === 'property') {\n\t\t\t\t\tpreviousNode.colonOffset = offset;\n\t\t\t\t\tisAtPropertyKey = false;\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tconst last = segments[segments.length - 1];\n\t\t\t\t\tif (typeof last === 'number') {\n\t\t\t\t\t\tsegments[segments.length - 1] = last + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisAtPropertyKey = true;\n\t\t\t\t\t\tsegments[segments.length - 1] = '';\n\t\t\t\t\t}\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (e) {\n\t\tif (e !== earlyReturnException) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treturn {\n\t\tpath: segments,\n\t\tpreviousNode,\n\t\tisAtPropertyKey,\n\t\tmatches: (pattern: Segment[]) => {\n\t\t\tlet k = 0;\n\t\t\tfor (let i = 0; k < pattern.length && i < segments.length; i++) {\n\t\t\t\tif (pattern[k] === segments[i] || pattern[k] === '*') {\n\t\t\t\t\tk++;\n\t\t\t\t} else if (pattern[k] !== '**') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn k === pattern.length;\n\t\t}\n\t};\n}\n\n\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): any {\n\tlet currentProperty: string | null = null;\n\tlet currentParent: any = [];\n\tconst previousParents: any[] = [];\n\n\tfunction onValue(value: any) {\n\t\tif (Array.isArray(currentParent)) {\n\t\t\t(<any[]>currentParent).push(value);\n\t\t} else if (currentProperty !== null) {\n\t\t\tcurrentParent[currentProperty] = value;\n\t\t}\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: () => {\n\t\t\tconst object = {};\n\t\t\tonValue(object);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = object;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonObjectProperty: (name: string) => {\n\t\t\tcurrentProperty = name;\n\t\t},\n\t\tonObjectEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonArrayBegin: () => {\n\t\t\tconst array: any[] = [];\n\t\t\tonValue(array);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = array;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonArrayEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonLiteralValue: onValue,\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\treturn currentParent[0];\n}\n\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): Node {\n\tlet currentParent: NodeImpl = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n\n\tfunction ensurePropertyComplete(endOffset: number) {\n\t\tif (currentParent.type === 'property') {\n\t\t\tcurrentParent.length = endOffset - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t}\n\t}\n\n\tfunction onValue(valueNode: Node): Node {\n\t\tcurrentParent.children!.push(valueNode);\n\t\treturn valueNode;\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: (offset: number) => {\n\t\t\tcurrentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n\t\t\tcurrentParent.children!.push({ type: 'string', value: name, offset, length, parent: currentParent });\n\t\t},\n\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\tonValue({ type: getNodeType(value), offset, length, parent: currentParent, value });\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\tif (currentParent.type === 'property') {\n\t\t\t\tif (sep === ':') {\n\t\t\t\t\tcurrentParent.colonOffset = offset;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tensurePropertyComplete(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\n\tconst result = currentParent.children![0];\n\tif (result) {\n\t\tdelete result.parent;\n\t}\n\treturn result;\n}\n\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root: Node, path: JSONPath): Node | undefined {\n\tif (!root) {\n\t\treturn undefined;\n\t}\n\tlet node = root;\n\tfor (let segment of path) {\n\t\tif (typeof segment === 'string') {\n\t\t\tif (node.type !== 'object' || !Array.isArray(node.children)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet found = false;\n\t\t\tfor (const propertyNode of node.children) {\n\t\t\t\tif (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n\t\t\t\t\tnode = propertyNode.children[1];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tconst index = <number>segment;\n\t\t\tif (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnode = node.children[index];\n\t\t}\n\t}\n\treturn node;\n}\n\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node: Node): JSONPath {\n\tif (!node.parent || !node.parent.children) {\n\t\treturn [];\n\t}\n\tconst path = getNodePath(node.parent);\n\tif (node.parent.type === 'property') {\n\t\tconst key = node.parent.children[0].value;\n\t\tpath.push(key);\n\t} else if (node.parent.type === 'array') {\n\t\tconst index = node.parent.children.indexOf(node);\n\t\tif (index !== -1) {\n\t\t\tpath.push(index);\n\t\t}\n\t}\n\treturn path;\n}\n\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node: Node): any {\n\tswitch (node.type) {\n\t\tcase 'array':\n\t\t\treturn node.children!.map(getNodeValue);\n\t\tcase 'object':\n\t\t\tconst obj = Object.create(null);\n\t\t\tfor (let prop of node.children!) {\n\t\t\t\tconst valueNode = prop.children![1];\n\t\t\t\tif (valueNode) {\n\t\t\t\t\tobj[prop.children![0].value] = getNodeValue(valueNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\tcase 'null':\n\t\tcase 'string':\n\t\tcase 'number':\n\t\tcase 'boolean':\n\t\t\treturn node.value;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n\n}\n\nexport function contains(node: Node, offset: number, includeRightBound = false): boolean {\n\treturn (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node: Node, offset: number, includeRightBound = false): Node | undefined {\n\tif (contains(node, offset, includeRightBound)) {\n\t\tconst children = node.children;\n\t\tif (Array.isArray(children)) {\n\t\t\tfor (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n\t\t\t\tconst item = findNodeAtOffset(children[i], offset, includeRightBound);\n\t\t\t\tif (item) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text: string, visitor: JSONVisitor, options: ParseOptions = ParseOptions.DEFAULT): any {\n\n\tconst _scanner = createScanner(text, false);\n\n\tfunction toNoArgVisit(visitFunction?: (offset: number, length: number) => void): () => void {\n\t\treturn visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\tfunction toOneArgVisit<T>(visitFunction?: (arg: T, offset: number, length: number) => void): (arg: T) => void {\n\t\treturn visitFunction ? (arg: T) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\n\tconst onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n\t\tonObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n\t\tonObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n\t\tonArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n\t\tonArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n\t\tonLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n\t\tonSeparator = toOneArgVisit(visitor.onSeparator),\n\t\tonComment = toNoArgVisit(visitor.onComment),\n\t\tonError = toOneArgVisit(visitor.onError);\n\n\tconst disallowComments = options && options.disallowComments;\n\tconst allowTrailingComma = options && options.allowTrailingComma;\n\tfunction scanNext(): SyntaxKind {\n\t\twhile (true) {\n\t\t\tconst token = _scanner.scan();\n\t\t\tswitch (_scanner.getTokenError()) {\n\t\t\t\tcase ScanError.InvalidUnicode:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidUnicode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidEscapeCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidEscapeCharacter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfNumber:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfNumber);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfComment:\n\t\t\t\t\tif (!disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfComment);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfString:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfString);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidCharacter);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (token) {\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidCommentToken);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonComment();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Trivia:\n\t\t\t\tcase SyntaxKind.LineBreakTrivia:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleError(error: ParseErrorCode, skipUntilAfter: SyntaxKind[] = [], skipUntil: SyntaxKind[] = []): void {\n\t\tonError(error);\n\t\tif (skipUntilAfter.length + skipUntil.length > 0) {\n\t\t\tlet token = _scanner.getToken();\n\t\t\twhile (token !== SyntaxKind.EOF) {\n\t\t\t\tif (skipUntilAfter.indexOf(token) !== -1) {\n\t\t\t\t\tscanNext();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (skipUntil.indexOf(token) !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttoken = scanNext();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(isValue: boolean): boolean {\n\t\tconst value = _scanner.getTokenValue();\n\t\tif (isValue) {\n\t\t\tonLiteralValue(value);\n\t\t} else {\n\t\t\tonObjectProperty(value);\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseLiteral(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tlet value = 0;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = JSON.parse(_scanner.getTokenValue());\n\t\t\t\t\tif (typeof value !== 'number') {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t}\n\t\t\t\tonLiteralValue(value);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tonLiteralValue(null);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tonLiteralValue(true);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tonLiteralValue(false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseProperty(): boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n\t\t\thandleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\treturn false;\n\t\t}\n\t\tparseString(false);\n\t\tif (_scanner.getToken() === SyntaxKind.ColonToken) {\n\t\t\tonSeparator(':');\n\t\t\tscanNext(); // consume colon\n\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t} else {\n\t\t\thandleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseObject(): boolean {\n\t\tonObjectBegin();\n\t\tscanNext(); // consume open brace\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseProperty()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonObjectEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n\t\t\thandleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close brace\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseArray(): boolean {\n\t\tonArrayBegin();\n\t\tscanNext(); // consume open bracket\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonArrayEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n\t\t\thandleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close bracket\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseValue(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.OpenBracketToken:\n\t\t\t\treturn parseArray();\n\t\t\tcase SyntaxKind.OpenBraceToken:\n\t\t\t\treturn parseObject();\n\t\t\tcase SyntaxKind.StringLiteral:\n\t\t\t\treturn parseString(true);\n\t\t\tdefault:\n\t\t\t\treturn parseLiteral();\n\t\t}\n\t}\n\n\tscanNext();\n\tif (_scanner.getToken() === SyntaxKind.EOF) {\n\t\tif (options.allowEmptyContent) {\n\t\t\treturn true;\n\t\t}\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (!parseValue()) {\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (_scanner.getToken() !== SyntaxKind.EOF) {\n\t\thandleError(ParseErrorCode.EndOfFileExpected, [], []);\n\t}\n\treturn true;\n}\n\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text: string, replaceCh?: string): string {\n\n\tlet _scanner = createScanner(text),\n\t\tparts: string[] = [],\n\t\tkind: SyntaxKind,\n\t\toffset = 0,\n\t\tpos: number;\n\n\tdo {\n\t\tpos = _scanner.getPosition();\n\t\tkind = _scanner.scan();\n\t\tswitch (kind) {\n\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\tcase SyntaxKind.EOF:\n\t\t\t\tif (offset !== pos) {\n\t\t\t\t\tparts.push(text.substring(offset, pos));\n\t\t\t\t}\n\t\t\t\tif (replaceCh !== undefined) {\n\t\t\t\t\tparts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n\t\t\t\t}\n\t\t\t\toffset = _scanner.getPosition();\n\t\t\t\tbreak;\n\t\t}\n\t} while (kind !== SyntaxKind.EOF);\n\n\treturn parts.join('');\n}\n\nexport function getNodeType(value: any): NodeType {\n\tswitch (typeof value) {\n\t\tcase 'boolean': return 'boolean';\n\t\tcase 'number': return 'number';\n\t\tcase 'string': return 'string';\n\t\tcase 'object': {\n\t\t\tif (!value) {\n\t\t\t\treturn 'null';\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\treturn 'array';\n\t\t\t}\n\t\t\treturn 'object';\n\t\t}\n\t\tdefault: return 'null';\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\n//@ts-check\n\n(function () {\n\n\t/**\n\t * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}\n\t */\n\tfunction _definePolyfillMarks(timeOrigin) {\n\n\t\tconst _data = [];\n\t\tif (typeof timeOrigin === 'number') {\n\t\t\t_data.push('code/timeOrigin', timeOrigin);\n\t\t}\n\n\t\tfunction mark(name) {\n\t\t\t_data.push(name, Date.now());\n\t\t}\n\t\tfunction getMarks() {\n\t\t\tconst result = [];\n\t\t\tfor (let i = 0; i < _data.length; i += 2) {\n\t\t\t\tresult.push({\n\t\t\t\t\tname: _data[i],\n\t\t\t\t\tstartTime: _data[i + 1],\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn { mark, getMarks };\n\t}\n\n\t/**\n\t * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}\n\t */\n\tfunction _define() {\n\n\t\tif (typeof performance === 'object' && typeof performance.mark === 'function') {\n\t\t\t// in a browser context, reuse performance-util\n\n\t\t\tif (typeof performance.timeOrigin !== 'number' && !performance.timing) {\n\t\t\t\t// safari & webworker: because there is no timeOrigin and no workaround\n\t\t\t\t// we use the `Date.now`-based polyfill.\n\t\t\t\treturn _definePolyfillMarks();\n\n\t\t\t} else {\n\t\t\t\t// use \"native\" performance for mark and getMarks\n\t\t\t\treturn {\n\t\t\t\t\tmark(name) {\n\t\t\t\t\t\tperformance.mark(name);\n\t\t\t\t\t},\n\t\t\t\t\tgetMarks() {\n\t\t\t\t\t\tlet timeOrigin = performance.timeOrigin;\n\t\t\t\t\t\tif (typeof timeOrigin !== 'number') {\n\t\t\t\t\t\t\t// safari: there is no timerOrigin but in renderers there is the timing-property\n\t\t\t\t\t\t\t// see https://bugs.webkit.org/show_bug.cgi?id=174862\n\t\t\t\t\t\t\ttimeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];\n\t\t\t\t\t\tfor (const entry of performance.getEntriesByType('mark')) {\n\t\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t\tname: entry.name,\n\t\t\t\t\t\t\t\tstartTime: Math.round(timeOrigin + entry.startTime)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t} else if (typeof process === 'object') {\n\t\t\t// node.js: use the normal polyfill but add the timeOrigin\n\t\t\t// from the node perf_hooks API as very first mark\n\t\t\tconst timeOrigin = Math.round((require.nodeRequire || require)('perf_hooks').performance.timeOrigin);\n\t\t\treturn _definePolyfillMarks(timeOrigin);\n\n\t\t} else {\n\t\t\t// unknown environment\n\t\t\tconsole.trace('perf-util loaded in UNKNOWN environment');\n\t\t\treturn _definePolyfillMarks();\n\t\t}\n\t}\n\n\tfunction _factory(sharedObj) {\n\t\tif (!sharedObj.MonacoPerformanceMarks) {\n\t\t\tsharedObj.MonacoPerformanceMarks = _define();\n\t\t}\n\t\treturn sharedObj.MonacoPerformanceMarks;\n\t}\n\n\t// This module can be loaded in an amd and commonjs-context.\n\t// Because we want both instances to use the same perf-data\n\t// we store them globally\n\n\t// eslint-disable-next-line no-var\n\tvar sharedObj;\n\tif (typeof global === 'object') {\n\t\t// nodejs\n\t\tsharedObj = global;\n\t} else if (typeof self === 'object') {\n\t\t// browser\n\t\tsharedObj = self;\n\t} else {\n\t\tsharedObj = {};\n\t}\n\n\tif (typeof define === 'function') {\n\t\t// amd\n\t\tdefine(\"vs/base/common/performance\", [], function () { return _factory(sharedObj); });\n\t} else if (typeof module === 'object' && typeof module.exports === 'object') {\n\t\t// commonjs\n\t\tmodule.exports = _factory(sharedObj);\n\t} else {\n\t\tconsole.trace('perf-util defined in UNKNOWN context (neither requirejs or commonjs)');\n\t\tsharedObj.perf = _factory(sharedObj);\n\t}\n\n})();\n","/**\n * Semver UMD module\n * Copyright (c) Isaac Z. Schlueter and Contributors\n * https://github.com/npm/node-semver\n */\n\n/**\n * DO NOT EDIT THIS FILE\n */\n\n!function(e,r){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=r();else if(\"function\"==typeof define&&define.amd)define(\"vs/base/common/semver/semver\", [],r);else{var t=r();for(var n in t)(\"object\"==typeof exports?exports:e)[n]=t[n]}}(\"undefined\"!=typeof self?self:this,(function(){return function(e){var r={};function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&r&&\"string\"!=typeof e)for(var o in e)t.d(n,o,function(r){return e[r]}.bind(null,o));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,\"a\",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p=\"\",t(t.s=0)}([function(e,r,t){(function(t){var n;r=e.exports=H,n=\"object\"==typeof t&&t.env&&t.env.NODE_DEBUG&&/\\bsemver\\b/i.test(t.env.NODE_DEBUG)?function(){var e=Array.prototype.slice.call(arguments,0);e.unshift(\"SEMVER\"),console.log.apply(console,e)}:function(){},r.SEMVER_SPEC_VERSION=\"2.0.0\";var o=256,i=Number.MAX_SAFE_INTEGER||9007199254740991,s=r.re=[],a=r.src=[],u=0,c=u++;a[c]=\"0|[1-9]\\\\d*\";var p=u++;a[p]=\"[0-9]+\";var f=u++;a[f]=\"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";var l=u++;a[l]=\"(\"+a[c]+\")\\\\.(\"+a[c]+\")\\\\.(\"+a[c]+\")\";var h=u++;a[h]=\"(\"+a[p]+\")\\\\.(\"+a[p]+\")\\\\.(\"+a[p]+\")\";var v=u++;a[v]=\"(?:\"+a[c]+\"|\"+a[f]+\")\";var m=u++;a[m]=\"(?:\"+a[p]+\"|\"+a[f]+\")\";var w=u++;a[w]=\"(?:-(\"+a[v]+\"(?:\\\\.\"+a[v]+\")*))\";var g=u++;a[g]=\"(?:-?(\"+a[m]+\"(?:\\\\.\"+a[m]+\")*))\";var y=u++;a[y]=\"[0-9A-Za-z-]+\";var d=u++;a[d]=\"(?:\\\\+(\"+a[y]+\"(?:\\\\.\"+a[y]+\")*))\";var b=u++,j=\"v?\"+a[l]+a[w]+\"?\"+a[d]+\"?\";a[b]=\"^\"+j+\"$\";var E=\"[v=\\\\s]*\"+a[h]+a[g]+\"?\"+a[d]+\"?\",T=u++;a[T]=\"^\"+E+\"$\";var x=u++;a[x]=\"((?:<|>)?=?)\";var $=u++;a[$]=a[p]+\"|x|X|\\\\*\";var k=u++;a[k]=a[c]+\"|x|X|\\\\*\";var S=u++;a[S]=\"[v=\\\\s]*(\"+a[k]+\")(?:\\\\.(\"+a[k]+\")(?:\\\\.(\"+a[k]+\")(?:\"+a[w]+\")?\"+a[d]+\"?)?)?\";var R=u++;a[R]=\"[v=\\\\s]*(\"+a[$]+\")(?:\\\\.(\"+a[$]+\")(?:\\\\.(\"+a[$]+\")(?:\"+a[g]+\")?\"+a[d]+\"?)?)?\";var I=u++;a[I]=\"^\"+a[x]+\"\\\\s*\"+a[S]+\"$\";var _=u++;a[_]=\"^\"+a[x]+\"\\\\s*\"+a[R]+\"$\";var O=u++;a[O]=\"(?:^|[^\\\\d])(\\\\d{1,16})(?:\\\\.(\\\\d{1,16}))?(?:\\\\.(\\\\d{1,16}))?(?:$|[^\\\\d])\";var A=u++;a[A]=\"(?:~>?)\";var M=u++;a[M]=\"(\\\\s*)\"+a[A]+\"\\\\s+\",s[M]=new RegExp(a[M],\"g\");var V=u++;a[V]=\"^\"+a[A]+a[S]+\"$\";var P=u++;a[P]=\"^\"+a[A]+a[R]+\"$\";var C=u++;a[C]=\"(?:\\\\^)\";var L=u++;a[L]=\"(\\\\s*)\"+a[C]+\"\\\\s+\",s[L]=new RegExp(a[L],\"g\");var N=u++;a[N]=\"^\"+a[C]+a[S]+\"$\";var q=u++;a[q]=\"^\"+a[C]+a[R]+\"$\";var D=u++;a[D]=\"^\"+a[x]+\"\\\\s*(\"+E+\")$|^$\";var X=u++;a[X]=\"^\"+a[x]+\"\\\\s*(\"+j+\")$|^$\";var z=u++;a[z]=\"(\\\\s*)\"+a[x]+\"\\\\s*(\"+E+\"|\"+a[S]+\")\",s[z]=new RegExp(a[z],\"g\");var G=u++;a[G]=\"^\\\\s*(\"+a[S]+\")\\\\s+-\\\\s+(\"+a[S]+\")\\\\s*$\";var Z=u++;a[Z]=\"^\\\\s*(\"+a[R]+\")\\\\s+-\\\\s+(\"+a[R]+\")\\\\s*$\";var B=u++;a[B]=\"(<|>)?=?\\\\s*\\\\*\";for(var U=0;U<35;U++)n(U,a[U]),s[U]||(s[U]=new RegExp(a[U]));function F(e,r){if(e instanceof H)return e;if(\"string\"!=typeof e)return null;if(e.length>o)return null;if(!(r?s[T]:s[b]).test(e))return null;try{return new H(e,r)}catch(e){return null}}function H(e,r){if(e instanceof H){if(e.loose===r)return e;e=e.version}else if(\"string\"!=typeof e)throw new TypeError(\"Invalid Version: \"+e);if(e.length>o)throw new TypeError(\"version is longer than \"+o+\" characters\");if(!(this instanceof H))return new H(e,r);n(\"SemVer\",e,r),this.loose=r;var t=e.trim().match(r?s[T]:s[b]);if(!t)throw new TypeError(\"Invalid Version: \"+e);if(this.raw=e,this.major=+t[1],this.minor=+t[2],this.patch=+t[3],this.major>i||this.major<0)throw new TypeError(\"Invalid major version\");if(this.minor>i||this.minor<0)throw new TypeError(\"Invalid minor version\");if(this.patch>i||this.patch<0)throw new TypeError(\"Invalid patch version\");t[4]?this.prerelease=t[4].split(\".\").map((function(e){if(/^[0-9]+$/.test(e)){var r=+e;if(r>=0&&r<i)return r}return e})):this.prerelease=[],this.build=t[5]?t[5].split(\".\"):[],this.format()}r.parse=F,r.valid=function(e,r){var t=F(e,r);return t?t.version:null},r.clean=function(e,r){var t=F(e.trim().replace(/^[=v]+/,\"\"),r);return t?t.version:null},r.SemVer=H,H.prototype.format=function(){return this.version=this.major+\".\"+this.minor+\".\"+this.patch,this.prerelease.length&&(this.version+=\"-\"+this.prerelease.join(\".\")),this.version},H.prototype.toString=function(){return this.version},H.prototype.compare=function(e){return n(\"SemVer.compare\",this.version,this.loose,e),e instanceof H||(e=new H(e,this.loose)),this.compareMain(e)||this.comparePre(e)},H.prototype.compareMain=function(e){return e instanceof H||(e=new H(e,this.loose)),K(this.major,e.major)||K(this.minor,e.minor)||K(this.patch,e.patch)},H.prototype.comparePre=function(e){if(e instanceof H||(e=new H(e,this.loose)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;var r=0;do{var t=this.prerelease[r],o=e.prerelease[r];if(n(\"prerelease compare\",r,t,o),void 0===t&&void 0===o)return 0;if(void 0===o)return 1;if(void 0===t)return-1;if(t!==o)return K(t,o)}while(++r)},H.prototype.inc=function(e,r){switch(e){case\"premajor\":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc(\"pre\",r);break;case\"preminor\":this.prerelease.length=0,this.patch=0,this.minor++,this.inc(\"pre\",r);break;case\"prepatch\":this.prerelease.length=0,this.inc(\"patch\",r),this.inc(\"pre\",r);break;case\"prerelease\":0===this.prerelease.length&&this.inc(\"patch\",r),this.inc(\"pre\",r);break;case\"major\":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case\"minor\":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case\"patch\":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case\"pre\":if(0===this.prerelease.length)this.prerelease=[0];else{for(var t=this.prerelease.length;--t>=0;)\"number\"==typeof this.prerelease[t]&&(this.prerelease[t]++,t=-2);-1===t&&this.prerelease.push(0)}r&&(this.prerelease[0]===r?isNaN(this.prerelease[1])&&(this.prerelease=[r,0]):this.prerelease=[r,0]);break;default:throw new Error(\"invalid increment argument: \"+e)}return this.format(),this.raw=this.version,this},r.inc=function(e,r,t,n){\"string\"==typeof t&&(n=t,t=void 0);try{return new H(e,t).inc(r,n).version}catch(e){return null}},r.diff=function(e,r){if(ee(e,r))return null;var t=F(e),n=F(r);if(t.prerelease.length||n.prerelease.length){for(var o in t)if((\"major\"===o||\"minor\"===o||\"patch\"===o)&&t[o]!==n[o])return\"pre\"+o;return\"prerelease\"}for(var o in t)if((\"major\"===o||\"minor\"===o||\"patch\"===o)&&t[o]!==n[o])return o},r.compareIdentifiers=K;var J=/^[0-9]+$/;function K(e,r){var t=J.test(e),n=J.test(r);return t&&n&&(e=+e,r=+r),t&&!n?-1:n&&!t?1:e<r?-1:e>r?1:0}function Q(e,r,t){return new H(e,t).compare(new H(r,t))}function W(e,r,t){return Q(e,r,t)>0}function Y(e,r,t){return Q(e,r,t)<0}function ee(e,r,t){return 0===Q(e,r,t)}function re(e,r,t){return 0!==Q(e,r,t)}function te(e,r,t){return Q(e,r,t)>=0}function ne(e,r,t){return Q(e,r,t)<=0}function oe(e,r,t,n){var o;switch(r){case\"===\":\"object\"==typeof e&&(e=e.version),\"object\"==typeof t&&(t=t.version),o=e===t;break;case\"!==\":\"object\"==typeof e&&(e=e.version),\"object\"==typeof t&&(t=t.version),o=e!==t;break;case\"\":case\"=\":case\"==\":o=ee(e,t,n);break;case\"!=\":o=re(e,t,n);break;case\">\":o=W(e,t,n);break;case\">=\":o=te(e,t,n);break;case\"<\":o=Y(e,t,n);break;case\"<=\":o=ne(e,t,n);break;default:throw new TypeError(\"Invalid operator: \"+r)}return o}function ie(e,r){if(e instanceof ie){if(e.loose===r)return e;e=e.value}if(!(this instanceof ie))return new ie(e,r);n(\"comparator\",e,r),this.loose=r,this.parse(e),this.semver===se?this.value=\"\":this.value=this.operator+this.semver.version,n(\"comp\",this)}r.rcompareIdentifiers=function(e,r){return K(r,e)},r.major=function(e,r){return new H(e,r).major},r.minor=function(e,r){return new H(e,r).minor},r.patch=function(e,r){return new H(e,r).patch},r.compare=Q,r.compareLoose=function(e,r){return Q(e,r,!0)},r.rcompare=function(e,r,t){return Q(r,e,t)},r.sort=function(e,t){return e.sort((function(e,n){return r.compare(e,n,t)}))},r.rsort=function(e,t){return e.sort((function(e,n){return r.rcompare(e,n,t)}))},r.gt=W,r.lt=Y,r.eq=ee,r.neq=re,r.gte=te,r.lte=ne,r.cmp=oe,r.Comparator=ie;var se={};function ae(e,r){if(e instanceof ae)return e.loose===r?e:new ae(e.raw,r);if(e instanceof ie)return new ae(e.value,r);if(!(this instanceof ae))return new ae(e,r);if(this.loose=r,this.raw=e,this.set=e.split(/\\s*\\|\\|\\s*/).map((function(e){return this.parseRange(e.trim())}),this).filter((function(e){return e.length})),!this.set.length)throw new TypeError(\"Invalid SemVer Range: \"+e);this.format()}function ue(e){return!e||\"x\"===e.toLowerCase()||\"*\"===e}function ce(e,r,t,n,o,i,s,a,u,c,p,f,l){return((r=ue(t)?\"\":ue(n)?\">=\"+t+\".0.0\":ue(o)?\">=\"+t+\".\"+n+\".0\":\">=\"+r)+\" \"+(a=ue(u)?\"\":ue(c)?\"<\"+(+u+1)+\".0.0\":ue(p)?\"<\"+u+\".\"+(+c+1)+\".0\":f?\"<=\"+u+\".\"+c+\".\"+p+\"-\"+f:\"<=\"+a)).trim()}function pe(e,r){for(var t=0;t<e.length;t++)if(!e[t].test(r))return!1;if(r.prerelease.length){for(t=0;t<e.length;t++)if(n(e[t].semver),e[t].semver!==se&&e[t].semver.prerelease.length>0){var o=e[t].semver;if(o.major===r.major&&o.minor===r.minor&&o.patch===r.patch)return!0}return!1}return!0}function fe(e,r,t){try{r=new ae(r,t)}catch(e){return!1}return r.test(e)}function le(e,r,t,n){var o,i,s,a,u;switch(e=new H(e,n),r=new ae(r,n),t){case\">\":o=W,i=ne,s=Y,a=\">\",u=\">=\";break;case\"<\":o=Y,i=te,s=W,a=\"<\",u=\"<=\";break;default:throw new TypeError('Must provide a hilo val of \"<\" or \">\"')}if(fe(e,r,n))return!1;for(var c=0;c<r.set.length;++c){var p=r.set[c],f=null,l=null;if(p.forEach((function(e){e.semver===se&&(e=new ie(\">=0.0.0\")),f=f||e,l=l||e,o(e.semver,f.semver,n)?f=e:s(e.semver,l.semver,n)&&(l=e)})),f.operator===a||f.operator===u)return!1;if((!l.operator||l.operator===a)&&i(e,l.semver))return!1;if(l.operator===u&&s(e,l.semver))return!1}return!0}ie.prototype.parse=function(e){var r=this.loose?s[D]:s[X],t=e.match(r);if(!t)throw new TypeError(\"Invalid comparator: \"+e);this.operator=t[1],\"=\"===this.operator&&(this.operator=\"\"),t[2]?this.semver=new H(t[2],this.loose):this.semver=se},ie.prototype.toString=function(){return this.value},ie.prototype.test=function(e){return n(\"Comparator.test\",e,this.loose),this.semver===se||(\"string\"==typeof e&&(e=new H(e,this.loose)),oe(e,this.operator,this.semver,this.loose))},ie.prototype.intersects=function(e,r){if(!(e instanceof ie))throw new TypeError(\"a Comparator is required\");var t;if(\"\"===this.operator)return t=new ae(e.value,r),fe(this.value,t,r);if(\"\"===e.operator)return t=new ae(this.value,r),fe(e.semver,t,r);var n=!(\">=\"!==this.operator&&\">\"!==this.operator||\">=\"!==e.operator&&\">\"!==e.operator),o=!(\"<=\"!==this.operator&&\"<\"!==this.operator||\"<=\"!==e.operator&&\"<\"!==e.operator),i=this.semver.version===e.semver.version,s=!(\">=\"!==this.operator&&\"<=\"!==this.operator||\">=\"!==e.operator&&\"<=\"!==e.operator),a=oe(this.semver,\"<\",e.semver,r)&&(\">=\"===this.operator||\">\"===this.operator)&&(\"<=\"===e.operator||\"<\"===e.operator),u=oe(this.semver,\">\",e.semver,r)&&(\"<=\"===this.operator||\"<\"===this.operator)&&(\">=\"===e.operator||\">\"===e.operator);return n||o||i&&s||a||u},r.Range=ae,ae.prototype.format=function(){return this.range=this.set.map((function(e){return e.join(\" \").trim()})).join(\"||\").trim(),this.range},ae.prototype.toString=function(){return this.range},ae.prototype.parseRange=function(e){var r=this.loose;e=e.trim(),n(\"range\",e,r);var t=r?s[Z]:s[G];e=e.replace(t,ce),n(\"hyphen replace\",e),e=e.replace(s[z],\"$1$2$3\"),n(\"comparator trim\",e,s[z]),e=(e=(e=e.replace(s[M],\"$1~\")).replace(s[L],\"$1^\")).split(/\\s+/).join(\" \");var o=r?s[D]:s[X],i=e.split(\" \").map((function(e){return function(e,r){return n(\"comp\",e),e=function(e,r){return e.trim().split(/\\s+/).map((function(e){return function(e,r){n(\"caret\",e,r);var t=r?s[q]:s[N];return e.replace(t,(function(r,t,o,i,s){var a;return n(\"caret\",e,r,t,o,i,s),ue(t)?a=\"\":ue(o)?a=\">=\"+t+\".0.0 <\"+(+t+1)+\".0.0\":ue(i)?a=\"0\"===t?\">=\"+t+\".\"+o+\".0 <\"+t+\".\"+(+o+1)+\".0\":\">=\"+t+\".\"+o+\".0 <\"+(+t+1)+\".0.0\":s?(n(\"replaceCaret pr\",s),\"-\"!==s.charAt(0)&&(s=\"-\"+s),a=\"0\"===t?\"0\"===o?\">=\"+t+\".\"+o+\".\"+i+s+\" <\"+t+\".\"+o+\".\"+(+i+1):\">=\"+t+\".\"+o+\".\"+i+s+\" <\"+t+\".\"+(+o+1)+\".0\":\">=\"+t+\".\"+o+\".\"+i+s+\" <\"+(+t+1)+\".0.0\"):(n(\"no pr\"),a=\"0\"===t?\"0\"===o?\">=\"+t+\".\"+o+\".\"+i+\" <\"+t+\".\"+o+\".\"+(+i+1):\">=\"+t+\".\"+o+\".\"+i+\" <\"+t+\".\"+(+o+1)+\".0\":\">=\"+t+\".\"+o+\".\"+i+\" <\"+(+t+1)+\".0.0\"),n(\"caret return\",a),a}))}(e,r)})).join(\" \")}(e,r),n(\"caret\",e),e=function(e,r){return e.trim().split(/\\s+/).map((function(e){return function(e,r){var t=r?s[P]:s[V];return e.replace(t,(function(r,t,o,i,s){var a;return n(\"tilde\",e,r,t,o,i,s),ue(t)?a=\"\":ue(o)?a=\">=\"+t+\".0.0 <\"+(+t+1)+\".0.0\":ue(i)?a=\">=\"+t+\".\"+o+\".0 <\"+t+\".\"+(+o+1)+\".0\":s?(n(\"replaceTilde pr\",s),\"-\"!==s.charAt(0)&&(s=\"-\"+s),a=\">=\"+t+\".\"+o+\".\"+i+s+\" <\"+t+\".\"+(+o+1)+\".0\"):a=\">=\"+t+\".\"+o+\".\"+i+\" <\"+t+\".\"+(+o+1)+\".0\",n(\"tilde return\",a),a}))}(e,r)})).join(\" \")}(e,r),n(\"tildes\",e),e=function(e,r){return n(\"replaceXRanges\",e,r),e.split(/\\s+/).map((function(e){return function(e,r){e=e.trim();var t=r?s[_]:s[I];return e.replace(t,(function(r,t,o,i,s,a){n(\"xRange\",e,r,t,o,i,s,a);var u=ue(o),c=u||ue(i),p=c||ue(s);return\"=\"===t&&p&&(t=\"\"),u?r=\">\"===t||\"<\"===t?\"<0.0.0\":\"*\":t&&p?(c&&(i=0),p&&(s=0),\">\"===t?(t=\">=\",c?(o=+o+1,i=0,s=0):p&&(i=+i+1,s=0)):\"<=\"===t&&(t=\"<\",c?o=+o+1:i=+i+1),r=t+o+\".\"+i+\".\"+s):c?r=\">=\"+o+\".0.0 <\"+(+o+1)+\".0.0\":p&&(r=\">=\"+o+\".\"+i+\".0 <\"+o+\".\"+(+i+1)+\".0\"),n(\"xRange return\",r),r}))}(e,r)})).join(\" \")}(e,r),n(\"xrange\",e),e=function(e,r){return n(\"replaceStars\",e,r),e.trim().replace(s[B],\"\")}(e,r),n(\"stars\",e),e}(e,r)})).join(\" \").split(/\\s+/);return this.loose&&(i=i.filter((function(e){return!!e.match(o)}))),i=i.map((function(e){return new ie(e,r)}))},ae.prototype.intersects=function(e,r){if(!(e instanceof ae))throw new TypeError(\"a Range is required\");return this.set.some((function(t){return t.every((function(t){return e.set.some((function(e){return e.every((function(e){return t.intersects(e,r)}))}))}))}))},r.toComparators=function(e,r){return new ae(e,r).set.map((function(e){return e.map((function(e){return e.value})).join(\" \").trim().split(\" \")}))},ae.prototype.test=function(e){if(!e)return!1;\"string\"==typeof e&&(e=new H(e,this.loose));for(var r=0;r<this.set.length;r++)if(pe(this.set[r],e))return!0;return!1},r.satisfies=fe,r.maxSatisfying=function(e,r,t){var n=null,o=null;try{var i=new ae(r,t)}catch(e){return null}return e.forEach((function(e){i.test(e)&&(n&&-1!==o.compare(e)||(o=new H(n=e,t)))})),n},r.minSatisfying=function(e,r,t){var n=null,o=null;try{var i=new ae(r,t)}catch(e){return null}return e.forEach((function(e){i.test(e)&&(n&&1!==o.compare(e)||(o=new H(n=e,t)))})),n},r.validRange=function(e,r){try{return new ae(e,r).range||\"*\"}catch(e){return null}},r.ltr=function(e,r,t){return le(e,r,\"<\",t)},r.gtr=function(e,r,t){return le(e,r,\">\",t)},r.outside=le,r.prerelease=function(e,r){var t=F(e,r);return t&&t.prerelease.length?t.prerelease:null},r.intersects=function(e,r,t){return e=new ae(e,t),r=new ae(r,t),e.intersects(r)},r.coerce=function(e){if(e instanceof H)return e;if(\"string\"!=typeof e)return null;var r=e.match(s[O]);return null==r?null:F((r[1]||\"0\")+\".\"+(r[2]||\"0\")+\".\"+(r[3]||\"0\"))}}).call(this,t(1))},function(e,r){var t,n,o=e.exports={};function i(){throw new Error(\"setTimeout has not been defined\")}function s(){throw new Error(\"clearTimeout has not been defined\")}function a(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t=\"function\"==typeof setTimeout?setTimeout:i}catch(e){t=i}try{n=\"function\"==typeof clearTimeout?clearTimeout:s}catch(e){n=s}}();var u,c=[],p=!1,f=-1;function l(){p&&u&&(p=!1,u.length?c=u.concat(c):f=-1,c.length&&h())}function h(){if(!p){var e=a(l);p=!0;for(var r=c.length;r;){for(u=c,c=[];++f<r;)u&&u[f].run();f=-1,r=c.length}u=null,p=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===s||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(r){try{return n.call(null,e)}catch(r){return n.call(this,e)}}}(e)}}function v(e,r){this.fun=e,this.array=r}function m(){}o.nextTick=function(e){var r=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)r[t-1]=arguments[t];c.push(new v(e,r)),1!==c.length||p||a(h)},v.prototype.run=function(){this.fun.apply(null,this.array)},o.title=\"browser\",o.browser=!0,o.env={},o.argv=[],o.version=\"\",o.versions={},o.on=m,o.addListener=m,o.once=m,o.off=m,o.removeListener=m,o.removeAllListeners=m,o.emit=m,o.prependListener=m,o.prependOnceListener=m,o.listeners=function(e){return[]},o.binding=function(e){throw new Error(\"process.binding is not supported\")},o.cwd=function(){return\"/\"},o.chdir=function(e){throw new Error(\"process.chdir is not supported\")},o.umask=function(){return 0}}])}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T> {\n\t(data: T[]): T;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T>): Promise<T>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T>): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): void {\n\tstream.on('error', error => listener.onError(error));\n\tstream.on('end', () => listener.onEnd());\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => listener.onData(data));\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst hasTextEncoder = (typeof TextEncoder !== 'undefined');\nconst hasTextDecoder = (typeof TextDecoder !== 'undefined');\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean; }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else if (hasTextEncoder) {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t} else {\n\t\t\treturn new VSBuffer(strings.encodeUTF8(source));\n\t\t}\n\t}\n\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else if (hasTextDecoder) {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t} else {\n\t\t\treturn strings.decodeUTF8(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performant, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start!/*bad lib.d.ts*/, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else {\n\t\t\tthis.buffer.set(array, offset);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isObject, isUndefinedOrNull, isArray } from 'vs/base/common/types';\n\nexport function deepClone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tif (obj instanceof RegExp) {\n\t\t// See https://github.com/microsoft/TypeScript/issues/10990\n\t\treturn obj as any;\n\t}\n\tconst result: any = Array.isArray(obj) ? [] : {};\n\tObject.keys(<any>obj).forEach((key: string) => {\n\t\tif ((<any>obj)[key] && typeof (<any>obj)[key] === 'object') {\n\t\t\tresult[key] = deepClone((<any>obj)[key]);\n\t\t} else {\n\t\t\tresult[key] = (<any>obj)[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function deepFreeze<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tconst stack: any[] = [obj];\n\twhile (stack.length > 0) {\n\t\tconst obj = stack.shift();\n\t\tObject.freeze(obj);\n\t\tfor (const key in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, key)) {\n\t\t\t\tconst prop = obj[key];\n\t\t\t\tif (typeof prop === 'object' && !Object.isFrozen(prop)) {\n\t\t\t\t\tstack.push(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function cloneAndChange(obj: any, changer: (orig: any) => any): any {\n\treturn _cloneAndChange(obj, changer, new Set());\n}\n\nfunction _cloneAndChange(obj: any, changer: (orig: any) => any, seen: Set<any>): any {\n\tif (isUndefinedOrNull(obj)) {\n\t\treturn obj;\n\t}\n\n\tconst changed = changer(obj);\n\tif (typeof changed !== 'undefined') {\n\t\treturn changed;\n\t}\n\n\tif (isArray(obj)) {\n\t\tconst r1: any[] = [];\n\t\tfor (const e of obj) {\n\t\t\tr1.push(_cloneAndChange(e, changer, seen));\n\t\t}\n\t\treturn r1;\n\t}\n\n\tif (isObject(obj)) {\n\t\tif (seen.has(obj)) {\n\t\t\tthrow new Error('Cannot clone recursive data-structure');\n\t\t}\n\t\tseen.add(obj);\n\t\tconst r2 = {};\n\t\tfor (let i2 in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, i2)) {\n\t\t\t\t(r2 as any)[i2] = _cloneAndChange(obj[i2], changer, seen);\n\t\t\t}\n\t\t}\n\t\tseen.delete(obj);\n\t\treturn r2;\n\t}\n\n\treturn obj;\n}\n\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination: any, source: any, overwrite: boolean = true): any {\n\tif (!isObject(destination)) {\n\t\treturn source;\n\t}\n\n\tif (isObject(source)) {\n\t\tObject.keys(source).forEach(key => {\n\t\t\tif (key in destination) {\n\t\t\t\tif (overwrite) {\n\t\t\t\t\tif (isObject(destination[key]) && isObject(source[key])) {\n\t\t\t\t\t\tmixin(destination[key], source[key], overwrite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn destination;\n}\n\nexport function equals(one: any, other: any): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\tif (one === null || one === undefined || other === null || other === undefined) {\n\t\treturn false;\n\t}\n\tif (typeof one !== typeof other) {\n\t\treturn false;\n\t}\n\tif (typeof one !== 'object') {\n\t\treturn false;\n\t}\n\tif ((Array.isArray(one)) !== (Array.isArray(other))) {\n\t\treturn false;\n\t}\n\n\tlet i: number;\n\tlet key: string;\n\n\tif (Array.isArray(one)) {\n\t\tif (one.length !== other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < one.length; i++) {\n\t\t\tif (!equals(one[i], other[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst oneKeys: string[] = [];\n\n\t\tfor (key in one) {\n\t\t\toneKeys.push(key);\n\t\t}\n\t\toneKeys.sort();\n\t\tconst otherKeys: string[] = [];\n\t\tfor (key in other) {\n\t\t\totherKeys.push(key);\n\t\t}\n\t\totherKeys.sort();\n\t\tif (!equals(oneKeys, otherKeys)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < oneKeys.length; i++) {\n\t\t\tif (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Calls `JSON.Stringify` with a replacer to break apart any circular references.\n * This prevents `JSON`.stringify` from throwing the exception\n *  \"Uncaught TypeError: Converting circular structure to JSON\"\n */\nexport function safeStringify(obj: any): string {\n\tconst seen = new Set<any>();\n\treturn JSON.stringify(obj, (key, value) => {\n\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\tif (seen.has(value)) {\n\t\t\t\treturn '[Circular]';\n\t\t\t} else {\n\t\t\t\tseen.add(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport function getOrDefault<T, R>(obj: T, fn: (obj: T) => R | undefined, defaultValue: R): R {\n\tconst result = fn(obj);\n\treturn typeof result === 'undefined' ? defaultValue : result;\n}\n\ntype obj = { [key: string]: any; };\n/**\n * Returns an object that has keys for each value that is different in the base object. Keys\n * that do not exist in the target but in the base object are not considered.\n *\n * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting\n * object if they differ.\n *\n * @param base the object to diff against\n * @param obj the object to use for diffing\n */\nexport function distinct(base: obj, target: obj): obj {\n\tconst result = Object.create(null);\n\n\tif (!base || !target) {\n\t\treturn result;\n\t}\n\n\tconst targetKeys = Object.keys(target);\n\ttargetKeys.forEach(k => {\n\t\tconst baseValue = base[k];\n\t\tconst targetValue = target[k];\n\n\t\tif (!equals(baseValue, targetValue)) {\n\t\t\tresult[k] = targetValue;\n\t\t}\n\t});\n\n\treturn result;\n}\n\nexport function getCaseInsensitive(target: obj, key: string): any {\n\tconst lowercaseKey = key.toLowerCase();\n\tconst equivalentKey = Object.keys(target).find(k => k.toLowerCase() === lowercaseKey);\n\treturn equivalentKey ? target[equivalentKey] : target[key];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IRemoteConsoleLog {\n\ttype: string;\n\tseverity: string;\n\targuments: string;\n}\n\ninterface IStackArgument {\n\t__$stack: string;\n}\n\nexport interface IStackFrame {\n\turi: URI;\n\tline: number;\n\tcolumn: number;\n}\n\nexport function isRemoteConsoleLog(obj: any): obj is IRemoteConsoleLog {\n\tconst entry = obj as IRemoteConsoleLog;\n\n\treturn entry && typeof entry.type === 'string' && typeof entry.severity === 'string';\n}\n\nexport function parse(entry: IRemoteConsoleLog): { args: any[], stack?: string } {\n\tconst args: any[] = [];\n\tlet stack: string | undefined;\n\n\t// Parse Entry\n\ttry {\n\t\tconst parsedArguments: any[] = JSON.parse(entry.arguments);\n\n\t\t// Check for special stack entry as last entry\n\t\tconst stackArgument = parsedArguments[parsedArguments.length - 1] as IStackArgument;\n\t\tif (stackArgument && stackArgument.__$stack) {\n\t\t\tparsedArguments.pop(); // stack is handled specially\n\t\t\tstack = stackArgument.__$stack;\n\t\t}\n\n\t\targs.push(...parsedArguments);\n\t} catch (error) {\n\t\targs.push('Unable to log remote console arguments', entry.arguments);\n\t}\n\n\treturn { args, stack };\n}\n\nexport function getFirstFrame(entry: IRemoteConsoleLog): IStackFrame | undefined;\nexport function getFirstFrame(stack: string | undefined): IStackFrame | undefined;\nexport function getFirstFrame(arg0: IRemoteConsoleLog | string | undefined): IStackFrame | undefined {\n\tif (typeof arg0 !== 'string') {\n\t\treturn getFirstFrame(parse(arg0!).stack);\n\t}\n\n\t// Parse a source information out of the stack if we have one. Format can be:\n\t// at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)\n\t// or\n\t// at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17\n\t// or\n\t// at c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17\n\t// or\n\t// at e.$executeContributedCommand(c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17)\n\tconst stack = arg0;\n\tif (stack) {\n\t\tconst topFrame = findFirstFrame(stack);\n\n\t\t// at [^\\/]* => line starts with \"at\" followed by any character except '/' (to not capture unix paths too late)\n\t\t// (?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\) => windows drive letter OR unix root OR unc root\n\t\t// (?:.+) => simple pattern for the path, only works because of the line/col pattern after\n\t\t// :(?:\\d+):(?:\\d+) => :line:column data\n\t\tconst matches = /at [^\\/]*((?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\))(?:.+)):(\\d+):(\\d+)/.exec(topFrame || '');\n\t\tif (matches && matches.length === 4) {\n\t\t\treturn {\n\t\t\t\turi: URI.file(matches[1]),\n\t\t\t\tline: Number(matches[2]),\n\t\t\t\tcolumn: Number(matches[3])\n\t\t\t};\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction findFirstFrame(stack: string | undefined): string | undefined {\n\tif (!stack) {\n\t\treturn stack;\n\t}\n\n\tconst newlineIndex = stack.indexOf('\\n');\n\tif (newlineIndex === -1) {\n\t\treturn stack;\n\t}\n\n\treturn stack.substring(0, newlineIndex);\n}\n\nexport function log(entry: IRemoteConsoleLog, label: string): void {\n\tconst { args, stack } = parse(entry);\n\n\tconst isOneStringArg = typeof args[0] === 'string' && args.length === 1;\n\n\tlet topFrame = findFirstFrame(stack);\n\tif (topFrame) {\n\t\ttopFrame = `(${topFrame.trim()})`;\n\t}\n\n\tlet consoleArgs: string[] = [];\n\n\t// First arg is a string\n\tif (typeof args[0] === 'string') {\n\t\tif (topFrame && isOneStringArg) {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color(''), color('grey')];\n\t\t} else {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color(''), ...args.slice(1)];\n\t\t}\n\t}\n\n\t// First arg is something else, just apply all\n\telse {\n\t\tconsoleArgs = [`%c[${label}]%`, color('blue'), ...args];\n\t}\n\n\t// Stack: add to args unless already aded\n\tif (topFrame && !isOneStringArg) {\n\t\tconsoleArgs.push(topFrame);\n\t}\n\n\t// Log it\n\tif (typeof (console as any)[entry.severity] !== 'function') {\n\t\tthrow new Error('Unknown console method');\n\t}\n\t(console as any)[entry.severity].apply(console, consoleArgs);\n}\n\nfunction color(color: string): string {\n\treturn `color: ${color}`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { regExpFlags } from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\n\nexport function stringify(obj: any): string {\n\treturn JSON.stringify(obj, replacer);\n}\n\nexport function parse(text: string): any {\n\tlet data = JSON.parse(text);\n\tdata = revive(data);\n\treturn data;\n}\n\nexport interface MarshalledObject {\n\t$mid: number;\n}\n\nfunction replacer(key: string, value: any): any {\n\t// URI is done via toJSON-member\n\tif (value instanceof RegExp) {\n\t\treturn {\n\t\t\t$mid: 2,\n\t\t\tsource: value.source,\n\t\t\tflags: regExpFlags(value),\n\t\t};\n\t}\n\treturn value;\n}\n\n\ntype Deserialize<T> = T extends UriComponents ? URI\n\t: T extends object\n\t? Revived<T>\n\t: T;\n\nexport type Revived<T> = { [K in keyof T]: Deserialize<T[K]> };\n\nexport function revive<T = any>(obj: any, depth = 0): Revived<T> {\n\tif (!obj || depth > 200) {\n\t\treturn obj;\n\t}\n\n\tif (typeof obj === 'object') {\n\n\t\tswitch ((<MarshalledObject>obj).$mid) {\n\t\t\tcase 1: return <any>URI.revive(obj);\n\t\t\tcase 2: return <any>new RegExp(obj.source, obj.flags);\n\t\t}\n\n\t\tif (\n\t\t\tobj instanceof VSBuffer\n\t\t\t|| obj instanceof Uint8Array\n\t\t) {\n\t\t\treturn <any>obj;\n\t\t}\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tfor (let i = 0; i < obj.length; ++i) {\n\t\t\t\tobj[i] = revive(obj[i], depth + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// walk object\n\t\t\tfor (const key in obj) {\n\t\t\t\tif (Object.hasOwnProperty.call(obj, key)) {\n\t\t\t\t\tobj[key] = revive(obj[key], depth + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = paths.sep === paths.posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst targetPathEnd = paths.posix.sep + targetPath;\n\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (testPath, basename) {\n\t\treturn typeof testPath === 'string' &&\n\t\t\t((testPath === nativePath || testPath.endsWith(nativePathEnd))\n\t\t\t\t|| !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd)))\n\t\t\t? pattern : null;\n\t} : function (testPath, basename) {\n\t\treturn typeof testPath === 'string' &&\n\t\t\t(testPath === nativePath\n\t\t\t\t|| (!usingPosixSep && testPath === targetPath))\n\t\t\t? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[]; } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { posix, normalize, win32, sep } from 'vs/base/common/path';\nimport { startsWithIgnoreCase, rtrim } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows, isMacintosh } from 'vs/base/common/platform';\nimport { isEqual, basename, relativePath } from 'vs/base/common/resources';\nimport { hasDriveLetter, isRootOrDriveLetter } from 'vs/base/common/extpath';\n\nexport interface IWorkspaceFolderProvider {\n\tgetWorkspaceFolder(resource: URI): { uri: URI, name?: string; } | null;\n\tgetWorkspace(): {\n\t\tfolders: { uri: URI, name?: string; }[];\n\t};\n}\n\nexport interface IUserHomeProvider {\n\tuserHome?: URI;\n}\n\n/**\n * @deprecated use LabelService instead\n */\nexport function getPathLabel(resource: URI | string, userHomeProvider?: IUserHomeProvider, rootProvider?: IWorkspaceFolderProvider): string {\n\tif (typeof resource === 'string') {\n\t\tresource = URI.file(resource);\n\t}\n\n\t// return early if we can resolve a relative path label from the root\n\tif (rootProvider) {\n\t\tconst baseResource = rootProvider.getWorkspaceFolder(resource);\n\t\tif (baseResource) {\n\t\t\tconst hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n\n\t\t\tlet pathLabel: string;\n\t\t\tif (isEqual(baseResource.uri, resource)) {\n\t\t\t\tpathLabel = ''; // no label if paths are identical\n\t\t\t} else {\n\t\t\t\tpathLabel = relativePath(baseResource.uri, resource)!;\n\t\t\t}\n\n\t\t\tif (hasMultipleRoots) {\n\t\t\t\tconst rootName = baseResource.name ? baseResource.name : basename(baseResource.uri);\n\t\t\t\tpathLabel = pathLabel ? (rootName + ' • ' + pathLabel) : rootName; // always show root basename if there are multiple\n\t\t\t}\n\n\t\t\treturn pathLabel;\n\t\t}\n\t}\n\n\t// return if the resource is neither file:// nor untitled:// and no baseResource was provided\n\tif (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\n\t\treturn resource.with({ query: null, fragment: null }).toString(true);\n\t}\n\n\t// convert c:\\something => C:\\something\n\tif (hasDriveLetter(resource.fsPath)) {\n\t\treturn normalize(normalizeDriveLetter(resource.fsPath));\n\t}\n\n\t// normalize and tildify (macOS, Linux only)\n\tlet res = normalize(resource.fsPath);\n\tif (!isWindows && userHomeProvider?.userHome) {\n\t\tres = tildify(res, userHomeProvider.userHome.fsPath);\n\t}\n\n\treturn res;\n}\n\nexport function getBaseLabel(resource: URI | string): string;\nexport function getBaseLabel(resource: URI | string | undefined): string | undefined;\nexport function getBaseLabel(resource: URI | string | undefined): string | undefined {\n\tif (!resource) {\n\t\treturn undefined;\n\t}\n\n\tif (typeof resource === 'string') {\n\t\tresource = URI.file(resource);\n\t}\n\n\tconst base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\n\n\t// convert c: => C:\n\tif (isWindows && isRootOrDriveLetter(base)) {\n\t\treturn normalizeDriveLetter(base);\n\t}\n\n\treturn base;\n}\n\nexport function normalizeDriveLetter(path: string): string {\n\tif (hasDriveLetter(path)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string; } = Object.create(null);\nexport function tildify(path: string, userHome: string): string {\n\tif (isWindows || !path || !userHome) {\n\t\treturn path; // unsupported\n\t}\n\n\t// Keep a normalized user home path as cache to prevent accumulated string creation\n\tlet normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = `${rtrim(userHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (isLinux ? path.startsWith(normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\n\t\tpath = `~/${path.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nexport function shorten(paths: string[], pathSeparator: string = sep): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tlet path = paths[pathIndex];\n\n\t\tif (path === '') {\n\t\t\tshortenedPaths[pathIndex] = `.${pathSeparator}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!path) {\n\t\t\tshortenedPaths[pathIndex] = path;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = '';\n\t\tif (path.indexOf(unc) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(unc) + unc.length);\n\t\t\tpath = path.substr(path.indexOf(unc) + unc.length);\n\t\t} else if (path.indexOf(pathSeparator) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(pathSeparator) + pathSeparator.length);\n\t\t\tpath = path.substr(path.indexOf(pathSeparator) + pathSeparator.length);\n\t\t} else if (path.indexOf(home) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(home) + home.length);\n\t\t\tpath = path.substr(path.indexOf(home) + home.length);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = path.split(pathSeparator);\n\t\tfor (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n\t\t\tfor (let start = segments.length - subpathLength; match && start >= 0; start--) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments.slice(start, start + subpathLength).join(pathSeparator);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean = (start + subpathLength === segments.length);\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean = paths[otherPathIndex].endsWith(subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = '';\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (segments[0].endsWith(':') || prefix !== '') {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + pathSeparator + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + pathSeparator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if neeeded\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + pathSeparator;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + pathSeparator + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = path; // use full path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT,\n\tVARIABLE,\n\tSEPARATOR\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which templating is applied\n * @param values the values of the templates to use\n */\nexport function template(template: string, values: { [key: string]: string | ISeparator | undefined | null; } = Object.create(null)): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = '';\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === '$' || (inVariable && char === '{')) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === '}' && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === 'string') {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments.filter((segment, index) => {\n\n\t\t// Only keep separator if we have values to the left and right\n\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\tconst left = segments[index - 1];\n\t\t\tconst right = segments[index + 1];\n\n\t\t\treturn [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n\t\t}\n\n\t\t// accept any TEXT and VARIABLE\n\t\treturn true;\n\t}).map(segment => segment.value).join('');\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n\t}\n\n\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '');\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n\t}\n\n\treturn label.replace(/&&/g, '_');\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, '&&');\n}\n\n/**\n * Splits a path in name and parent path, supporting both '/' and '\\'\n */\nexport function splitName(fullPath: string): { name: string, parentPath: string; } {\n\tconst p = fullPath.indexOf('/') !== -1 ? posix : win32;\n\tconst name = p.basename(fullPath);\n\tconst parentPath = p.dirname(fullPath);\n\tif (name.length) {\n\t\treturn { name, parentPath };\n\t}\n\t// only the root segment\n\treturn { name: parentPath, parentPath: '' };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as sd from 'string_decoder';\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * Convenient way to iterate over output line by line. This helper accommodates for the fact that\n * a buffer might not end with new lines all the way.\n *\n * To use:\n * - call the write method\n * - forEach() over the result to get the lines\n */\nexport class LineDecoder {\n\tprivate stringDecoder: sd.StringDecoder;\n\tprivate remaining: string | null;\n\n\tconstructor(encoding: BufferEncoding = 'utf8') {\n\t\tthis.stringDecoder = new sd.StringDecoder(encoding);\n\t\tthis.remaining = null;\n\t}\n\n\twrite(buffer: Buffer): string[] {\n\t\tconst result: string[] = [];\n\t\tconst value = this.remaining\n\t\t\t? this.remaining + this.stringDecoder.write(buffer)\n\t\t\t: this.stringDecoder.write(buffer);\n\n\t\tif (value.length < 1) {\n\t\t\treturn result;\n\t\t}\n\t\tlet start = 0;\n\t\tlet ch: number;\n\t\tlet idx = start;\n\t\twhile (idx < value.length) {\n\t\t\tch = value.charCodeAt(idx);\n\t\t\tif (ch === CharCode.CarriageReturn || ch === CharCode.LineFeed) {\n\t\t\t\tresult.push(value.substring(start, idx));\n\t\t\t\tidx++;\n\t\t\t\tif (idx < value.length) {\n\t\t\t\t\tconst lastChar = ch;\n\t\t\t\t\tch = value.charCodeAt(idx);\n\t\t\t\t\tif ((lastChar === CharCode.CarriageReturn && ch === CharCode.LineFeed) || (lastChar === CharCode.LineFeed && ch === CharCode.CarriageReturn)) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = idx;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tthis.remaining = start < value.length ? value.substr(start) : null;\n\t\treturn result;\n\t}\n\n\tend(): string | null {\n\t\treturn this.remaining;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { promisify } from 'util';\nimport { rtrim } from 'vs/base/common/strings';\nimport { sep, join, normalize, dirname, basename } from 'vs/base/common/path';\nimport { readdirSync } from 'vs/base/node/pfs';\n\n/**\n * Copied from: https://github.com/microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport function realcaseSync(path: string): string | null {\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = readdirSync(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport async function realpath(path: string): Promise<string> {\n\ttry {\n\t\t// DO NOT USE `fs.promises.realpath` here as it internally\n\t\t// calls `fs.native.realpath` which will result in subst\n\t\t// drives to be resolved to their target on Windows\n\t\t// https://github.com/microsoft/vscode/issues/118562\n\t\treturn await promisify(fs.realpath)(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait fs.promises.access(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as pfs from 'vs/base/node/pfs';\nimport * as os from 'os';\nimport * as path from 'vs/base/common/path';\n\n// This is required, since parseInt(\"7-preview\") will return 7.\nconst IntRegex: RegExp = /^\\d+$/;\n\nconst PwshMsixRegex: RegExp = /^Microsoft.PowerShell_.*/;\nconst PwshPreviewMsixRegex: RegExp = /^Microsoft.PowerShellPreview_.*/;\n\nconst enum Arch {\n\tx64,\n\tx86,\n\tARM\n}\n\nlet processArch: Arch;\nswitch (process.arch) {\n\tcase 'ia32':\n\tcase 'x32':\n\t\tprocessArch = Arch.x86;\n\t\tbreak;\n\tcase 'arm':\n\tcase 'arm64':\n\t\tprocessArch = Arch.ARM;\n\t\tbreak;\n\tdefault:\n\t\tprocessArch = Arch.x64;\n\t\tbreak;\n}\n\n/*\nCurrently, here are the values for these environment variables on their respective archs:\n\nOn x86 process on x86:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on x64:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is AMD64\n\nOn x64 process on x64:\nPROCESSOR_ARCHITECTURE is AMD64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn ARM process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n\nOn x86 process on ARM:\nPROCESSOR_ARCHITECTURE is X86\nPROCESSOR_ARCHITEW6432 is ARM64\n\nOn x64 process on ARM:\nPROCESSOR_ARCHITECTURE is ARM64\nPROCESSOR_ARCHITEW6432 is undefined\n*/\nlet osArch: Arch;\nif (process.env['PROCESSOR_ARCHITEW6432']) {\n\tosArch = process.env['PROCESSOR_ARCHITEW6432'] === 'ARM64'\n\t\t? Arch.ARM\n\t\t: Arch.x64;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'ARM64') {\n\tosArch = Arch.ARM;\n} else if (process.env['PROCESSOR_ARCHITECTURE'] === 'X86') {\n\tosArch = Arch.x86;\n} else {\n\tosArch = Arch.x64;\n}\n\nexport interface IPowerShellExeDetails {\n\treadonly displayName: string;\n\treadonly exePath: string;\n}\n\nexport interface IPossiblePowerShellExe extends IPowerShellExeDetails {\n\texists(): Promise<boolean>;\n}\n\nclass PossiblePowerShellExe implements IPossiblePowerShellExe {\n\tconstructor(\n\t\tpublic readonly exePath: string,\n\t\tpublic readonly displayName: string,\n\t\tprivate knownToExist?: boolean) { }\n\n\tpublic async exists(): Promise<boolean> {\n\t\tif (this.knownToExist === undefined) {\n\t\t\tthis.knownToExist = await pfs.SymlinkSupport.existsFile(this.exePath);\n\t\t}\n\t\treturn this.knownToExist;\n\t}\n}\n\nfunction getProgramFilesPath(\n\t{ useAlternateBitness = false }: { useAlternateBitness?: boolean } = {}): string | null {\n\n\tif (!useAlternateBitness) {\n\t\t// Just use the native system bitness\n\t\treturn process.env.ProgramFiles || null;\n\t}\n\n\t// We might be a 64-bit process looking for 32-bit program files\n\tif (processArch === Arch.x64) {\n\t\treturn process.env['ProgramFiles(x86)'] || null;\n\t}\n\n\t// We might be a 32-bit process looking for 64-bit program files\n\tif (osArch === Arch.x64) {\n\t\treturn process.env.ProgramW6432 || null;\n\t}\n\n\t// We're a 32-bit process on 32-bit Windows, there is no other Program Files dir\n\treturn null;\n}\n\nasync function findPSCoreWindowsInstallation(\n\t{ useAlternateBitness = false, findPreview = false }:\n\t\t{ useAlternateBitness?: boolean; findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\n\tconst programFilesPath = getProgramFilesPath({ useAlternateBitness });\n\tif (!programFilesPath) {\n\t\treturn null;\n\t}\n\n\tconst powerShellInstallBaseDir = path.join(programFilesPath, 'PowerShell');\n\n\t// Ensure the base directory exists\n\tif (!await pfs.SymlinkSupport.existsDirectory(powerShellInstallBaseDir)) {\n\t\treturn null;\n\t}\n\n\tlet highestSeenVersion: number = -1;\n\tlet pwshExePath: string | null = null;\n\tfor (const item of await pfs.readdir(powerShellInstallBaseDir)) {\n\n\t\tlet currentVersion: number = -1;\n\t\tif (findPreview) {\n\t\t\t// We are looking for something like \"7-preview\"\n\n\t\t\t// Preview dirs all have dashes in them\n\t\t\tconst dashIndex = item.indexOf('-');\n\t\t\tif (dashIndex < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Verify that the part before the dash is an integer\n\t\t\t// and that the part after the dash is \"preview\"\n\t\t\tconst intPart: string = item.substring(0, dashIndex);\n\t\t\tif (!IntRegex.test(intPart) || item.substring(dashIndex + 1) !== 'preview') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(intPart, 10);\n\t\t} else {\n\t\t\t// Search for a directory like \"6\" or \"7\"\n\t\t\tif (!IntRegex.test(item)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrentVersion = parseInt(item, 10);\n\t\t}\n\n\t\t// Ensure we haven't already seen a higher version\n\t\tif (currentVersion <= highestSeenVersion) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Now look for the file\n\t\tconst exePath = path.join(powerShellInstallBaseDir, item, 'pwsh.exe');\n\t\tif (!await pfs.SymlinkSupport.existsFile(exePath)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpwshExePath = exePath;\n\t\thighestSeenVersion = currentVersion;\n\t}\n\n\tif (!pwshExePath) {\n\t\treturn null;\n\t}\n\n\tconst bitness: string = programFilesPath.includes('x86') ? ' (x86)' : '';\n\tconst preview: string = findPreview ? ' Preview' : '';\n\n\treturn new PossiblePowerShellExe(pwshExePath, `PowerShell${preview}${bitness}`, true);\n}\n\nasync function findPSCoreMsix({ findPreview }: { findPreview?: boolean } = {}): Promise<IPossiblePowerShellExe | null> {\n\t// We can't proceed if there's no LOCALAPPDATA path\n\tif (!process.env.LOCALAPPDATA) {\n\t\treturn null;\n\t}\n\n\t// Find the base directory for MSIX application exe shortcuts\n\tconst msixAppDir = path.join(process.env.LOCALAPPDATA, 'Microsoft', 'WindowsApps');\n\n\tif (!await pfs.SymlinkSupport.existsDirectory(msixAppDir)) {\n\t\treturn null;\n\t}\n\n\t// Define whether we're looking for the preview or the stable\n\tconst { pwshMsixDirRegex, pwshMsixName } = findPreview\n\t\t? { pwshMsixDirRegex: PwshPreviewMsixRegex, pwshMsixName: 'PowerShell Preview (Store)' }\n\t\t: { pwshMsixDirRegex: PwshMsixRegex, pwshMsixName: 'PowerShell (Store)' };\n\n\t// We should find only one such application, so return on the first one\n\tfor (const subdir of await pfs.readdir(msixAppDir)) {\n\t\tif (pwshMsixDirRegex.test(subdir)) {\n\t\t\tconst pwshMsixPath = path.join(msixAppDir, subdir, 'pwsh.exe');\n\t\t\treturn new PossiblePowerShellExe(pwshMsixPath, pwshMsixName);\n\t\t}\n\t}\n\n\t// If we find nothing, return null\n\treturn null;\n}\n\nfunction findPSCoreDotnetGlobalTool(): IPossiblePowerShellExe {\n\tconst dotnetGlobalToolExePath: string = path.join(os.homedir(), '.dotnet', 'tools', 'pwsh.exe');\n\n\treturn new PossiblePowerShellExe(dotnetGlobalToolExePath, '.NET Core PowerShell Global Tool');\n}\n\nfunction findWinPS(): IPossiblePowerShellExe | null {\n\tconst winPSPath = path.join(\n\t\tprocess.env.windir!,\n\t\tprocessArch === Arch.x86 && osArch !== Arch.x86 ? 'SysNative' : 'System32',\n\t\t'WindowsPowerShell', 'v1.0', 'powershell.exe');\n\n\treturn new PossiblePowerShellExe(winPSPath, 'Windows PowerShell', true);\n}\n\n/**\n * Iterates through all the possible well-known PowerShell installations on a machine.\n * Returned values may not exist, but come with an .exists property\n * which will check whether the executable exists.\n */\nasync function* enumerateDefaultPowerShellInstallations(): AsyncIterable<IPossiblePowerShellExe> {\n\t// Find PSCore stable first\n\tlet pwshExe = await findPSCoreWindowsInstallation();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Windows may have a 32-bit pwsh.exe\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Also look for the MSIX/UWP installation\n\tpwshExe = await findPSCoreMsix();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for the .NET global tool\n\t// Some older versions of PowerShell have a bug in this where startup will fail,\n\t// but this is fixed in newer versions\n\tpwshExe = findPSCoreDotnetGlobalTool();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for PSCore preview\n\tpwshExe = await findPSCoreWindowsInstallation({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Find a preview MSIX\n\tpwshExe = await findPSCoreMsix({ findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Look for pwsh-preview with the opposite bitness\n\tpwshExe = await findPSCoreWindowsInstallation({ useAlternateBitness: true, findPreview: true });\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n\n\t// Finally, get Windows PowerShell\n\tpwshExe = findWinPS();\n\tif (pwshExe) {\n\t\tyield pwshExe;\n\t}\n}\n\n/**\n * Iterates through PowerShell installations on the machine according\n * to configuration passed in through the constructor.\n * PowerShell items returned by this object are verified\n * to exist on the filesystem.\n */\nexport async function* enumeratePowerShellInstallations(): AsyncIterable<IPowerShellExeDetails> {\n\t// Get the default PowerShell installations first\n\tfor await (const defaultPwsh of enumerateDefaultPowerShellInstallations()) {\n\t\tif (await defaultPwsh.exists()) {\n\t\t\tyield defaultPwsh;\n\t\t}\n\t}\n}\n\n/**\n* Returns the first available PowerShell executable found in the search order.\n*/\nexport async function getFirstAvailablePowerShellInstallation(): Promise<IPowerShellExeDetails | null> {\n\tfor await (const pwsh of enumeratePowerShellInstallations()) {\n\t\treturn pwsh;\n\t}\n\treturn null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { join, basename } from 'vs/base/common/path';\nimport { watch } from 'fs';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { toDisposable, IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { exists, readdir } from 'vs/base/node/pfs';\n\nexport function watchFile(path: string, onChange: (type: 'added' | 'changed' | 'deleted', path: string) => void, onError: (error: string) => void): IDisposable {\n\treturn doWatchNonRecursive({ path, isDirectory: false }, onChange, onError);\n}\n\nexport function watchFolder(path: string, onChange: (type: 'added' | 'changed' | 'deleted', path: string) => void, onError: (error: string) => void): IDisposable {\n\treturn doWatchNonRecursive({ path, isDirectory: true }, onChange, onError);\n}\n\nexport const CHANGE_BUFFER_DELAY = 100;\n\nfunction doWatchNonRecursive(file: { path: string, isDirectory: boolean }, onChange: (type: 'added' | 'changed' | 'deleted', path: string) => void, onError: (error: string) => void): IDisposable {\n\tconst originalFileName = basename(file.path);\n\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\n\tlet disposed = false;\n\tlet watcherDisposables: IDisposable[] = [toDisposable(() => {\n\t\tmapPathToStatDisposable.forEach(disposable => dispose(disposable));\n\t\tmapPathToStatDisposable.clear();\n\t})];\n\n\ttry {\n\n\t\t// Creating watcher can fail with an exception\n\t\tconst watcher = watch(file.path);\n\t\twatcherDisposables.push(toDisposable(() => {\n\t\t\twatcher.removeAllListeners();\n\t\t\twatcher.close();\n\t\t}));\n\n\t\t// Folder: resolve children to emit proper events\n\t\tconst folderChildren: Set<string> = new Set<string>();\n\t\tif (file.isDirectory) {\n\t\t\treaddir(file.path).then(children => children.forEach(child => folderChildren.add(child)));\n\t\t}\n\n\t\twatcher.on('error', (code: number, signal: string) => {\n\t\t\tif (!disposed) {\n\t\t\t\tonError(`Failed to watch ${file.path} for changes using fs.watch() (${code}, ${signal})`);\n\t\t\t}\n\t\t});\n\n\t\twatcher.on('change', (type, raw) => {\n\t\t\tif (disposed) {\n\t\t\t\treturn; // ignore if already disposed\n\t\t\t}\n\n\t\t\t// Normalize file name\n\t\t\tlet changedFileName: string = '';\n\t\t\tif (raw) { // https://github.com/microsoft/vscode/issues/38191\n\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!changedFileName || (type !== 'change' && type !== 'rename')) {\n\t\t\t\treturn; // ignore unexpected events\n\t\t\t}\n\n\t\t\t// File path: use path directly for files and join with changed file name otherwise\n\t\t\tconst changedFilePath = file.isDirectory ? join(file.path, changedFileName) : file.path;\n\n\t\t\t// File\n\t\t\tif (!file.isDirectory) {\n\t\t\t\tif (type === 'rename' || changedFileName !== originalFileName) {\n\t\t\t\t\t// The file was either deleted or renamed. Many tools apply changes to files in an\n\t\t\t\t\t// atomic way (\"Atomic Save\") by first renaming the file to a temporary name and then\n\t\t\t\t\t// renaming it back to the original name. Our watcher will detect this as a rename\n\t\t\t\t\t// and then stops to work on Mac and Linux because the watcher is applied to the\n\t\t\t\t\t// inode and not the name. The fix is to detect this case and trying to watch the file\n\t\t\t\t\t// again after a certain delay.\n\t\t\t\t\t// In addition, we send out a delete event if after a timeout we detect that the file\n\t\t\t\t\t// does indeed not exist anymore.\n\n\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\tconst fileExists = await exists(changedFilePath);\n\n\t\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\tonChange('changed', changedFilePath);\n\n\t\t\t\t\t\t\twatcherDisposables = [doWatchNonRecursive(file, onChange, onError)];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// File seems to be really gone, so emit a deleted event\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tonChange('deleted', changedFilePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, CHANGE_BUFFER_DELAY);\n\n\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\tdispose(watcherDisposables);\n\t\t\t\t\twatcherDisposables = [toDisposable(() => clearTimeout(timeoutHandle))];\n\t\t\t\t} else {\n\t\t\t\t\tonChange('changed', changedFilePath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Folder\n\t\t\telse {\n\n\t\t\t\t// Children add/delete\n\t\t\t\tif (type === 'rename') {\n\n\t\t\t\t\t// Cancel any previous stats for this file path if existing\n\t\t\t\t\tconst statDisposable = mapPathToStatDisposable.get(changedFilePath);\n\t\t\t\t\tif (statDisposable) {\n\t\t\t\t\t\tdispose(statDisposable);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait a bit and try see if the file still exists on disk to decide on the resulting event\n\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFilePath);\n\n\t\t\t\t\t\tconst fileExists = await exists(changedFilePath);\n\n\t\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t// File Exists: either 'added' or 'changed' if known before\n\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\tlet type: 'added' | 'deleted' | 'changed';\n\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\ttype = 'changed';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttype = 'added';\n\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\ttype = 'deleted';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tonChange(type, changedFilePath);\n\t\t\t\t\t}, CHANGE_BUFFER_DELAY);\n\n\t\t\t\t\tmapPathToStatDisposable.set(changedFilePath, toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t}\n\n\t\t\t\t// Other events\n\t\t\t\telse {\n\n\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\tlet type: 'added' | 'changed';\n\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\ttype = 'changed';\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'added';\n\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t}\n\n\t\t\t\t\tonChange(type, changedFilePath);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\texists(file.path).then(exists => {\n\t\t\tif (exists && !disposed) {\n\t\t\t\tonError(`Failed to watch ${file.path} for changes using fs.watch() (${error.toString()})`);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn toDisposable(() => {\n\t\tdisposed = true;\n\n\t\twatcherDisposables = dispose(watcherDisposables);\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter, Relay, EventMultiplexer } from 'vs/base/common/event';\nimport { IDisposable, toDisposable, combinedDisposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { getRandomElement } from 'vs/base/common/arrays';\nimport { isFunction, isUndefinedOrNull } from 'vs/base/common/types';\nimport { revive } from 'vs/base/common/marshalling';\nimport * as strings from 'vs/base/common/strings';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn 'req';\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn 'cancel';\n\t\tcase RequestType.EventListen:\n\t\t\treturn 'subscribe';\n\t\tcase RequestType.EventDispose:\n\t\t\treturn 'unsubscribe';\n\t}\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any; };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel, id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any; };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose, id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string, name: string, stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\tonMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router?: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5\n}\n\nfunction createSizeBuffer(size: number): VSBuffer {\n\tconst result = VSBuffer.alloc(4);\n\tresult.writeUInt32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUInt32BE(0);\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n};\n\ndeclare const Buffer: any;\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (hasBuffer && Buffer.isBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriter.write(createSizeBuffer(data.byteLength));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: any;\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext, private logger: IIPCLogger | null = null, private timeoutDelay: number = 1000) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, 0, RequestInitiator.OtherSide, responseTypeToStr(response.type));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send([response.type, response.id], response.data);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, response.id, RequestInitiator.OtherSide, responseTypeToStr(response.type), response.data);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\t}\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\t}\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\t}\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\t}\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(request: IRawPromiseRequest | IRawEventListenRequest): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },\n\t\t\t\t\ttype: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise: this.onPromise(request.request); break;\n\t\t\t\t\tcase RequestType.EventListen: this.onEventListen(request.request); break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(d => d.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport const enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n\tlogOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate isDisposed: boolean = false;\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol, logger: IIPCLogger | null = null) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(errors.canceled());\n\t\t\t\t}\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(errors.canceled());\n\t\t\t\t}\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable(toDisposable(cancel), cancellationTokenListener);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => { this.activeRequests.delete(disposable); });\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) => emitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, requestTypeToStr(request.type));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, 0, RequestInitiator.LocalSide, responseTypeToStr(type));\n\t\t\t\t}\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tif (this.logger) {\n\t\t\t\t\tthis.logger.logIncoming(message.byteLength, header[1], RequestInitiator.LocalSide, responseTypeToStr(type), body);\n\t\t\t\t}\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\tif (handler) {\n\t\t\thandler(response);\n\t\t}\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn Event.toPromise(this.onDidInitialize);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(p => p.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> = this._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> = this._onDidRemoveConnection.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelServer, channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n\tgetChannel<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean): T;\n\tgetChannel<T extends IChannel>(channelName: string, routerOrClientFilter: IClientRouter<TContext> | ((client: Client<TContext>) => boolean)): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tlet connection = getRandomElement(that.connections.filter(routerOrClientFilter));\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t// if we found a client, let's call on it\n\t\t\t\t\t\t? Promise.resolve(connection)\n\t\t\t\t\t\t// else, let's wait for a client to come along\n\t\t\t\t\t\t: Event.toPromise(Event.filter(that.onDidAddConnection, routerOrClientFilter));\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(that, command, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(channelName, routerOrClientFilter, event, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean, eventName: string, arg: any): Event<T> {\n\t\tconst that = this;\n\t\tlet disposables = new DisposableStore();\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst channel = connection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthat.connections.filter(clientFilter).forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(that.onDidAddConnection, clientFilter)(onDidAddConnection, undefined, disposables);\n\t\t\t\tthat.onDidRemoveConnection(onDidRemoveConnection, undefined, disposables);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tthis._connections.forEach(connection => {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n/**\n * Use ProxyChannels to automatically wrapping and unwrapping\n * services to/from IPC channels, instead of manually wrapping\n * each service method and event.\n *\n * Restrictions:\n * - If marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - Events must follow the naming convention `onUpperCase`\n * - `CancellationToken` is currently not supported\n * - If a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\nexport namespace ProxyChannel {\n\n\texport interface IProxyOptions {\n\n\t\t/**\n\t\t * Disables automatic marshalling of `URI`.\n\t\t * If marshalling is disabled, `UriComponents`\n\t\t * must be used instead.\n\t\t */\n\t\tdisableMarshalling?: boolean;\n\t}\n\n\texport interface ICreateServiceChannelOptions extends IProxyOptions { }\n\n\texport function fromService(service: unknown, options?: ICreateServiceChannelOptions): IServerChannel {\n\t\tconst handler = service as { [key: string]: unknown };\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\t// Buffer any event that should be supported by\n\t\t// iterating over all property keys and finding them\n\t\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\t\tfor (const key in handler) {\n\t\t\tif (propertyIsEvent(key)) {\n\t\t\t\tmapEventNameToEvent.set(key, Event.buffer(handler[key] as Event<unknown>, true));\n\t\t\t}\n\t\t}\n\n\t\treturn new class implements IServerChannel {\n\n\t\t\tlisten<T>(_: unknown, event: string): Event<T> {\n\t\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\t\tif (eventImpl) {\n\t\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Event not found: ${event}`);\n\t\t\t}\n\n\t\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\t\tconst target = handler[command];\n\t\t\t\tif (typeof target === 'function') {\n\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn target.apply(handler, args);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Method not found: ${command}`);\n\t\t\t}\n\t\t};\n\t}\n\n\texport interface ICreateProxyServiceOptions extends IProxyOptions {\n\n\t\t/**\n\t\t * If provided, will add the value of `context`\n\t\t * to each method call to the target.\n\t\t */\n\t\tcontext?: unknown;\n\n\t\t/**\n\t\t * If provided, will not proxy any of the properties\n\t\t * that are part of the Map but rather return that value.\n\t\t */\n\t\tproperties?: Map<string, unknown>;\n\t}\n\n\texport function toService<T>(channel: IChannel, options?: ICreateProxyServiceOptions): T {\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\treturn new Proxy({}, {\n\t\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\t\tif (typeof propKey === 'string') {\n\n\t\t\t\t\t// Check for predefined values\n\t\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Event\n\t\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Function\n\t\t\t\t\treturn async function (...args: any[]) {\n\n\t\t\t\t\t\t// Add context if any\n\t\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\t\tif (options && !isUndefinedOrNull(options.context)) {\n\t\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = await channel.call(propKey, methodArgs);\n\n\t\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Property not found: ${String(propKey)}`);\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tfunction propertyIsEvent(name: string): boolean {\n\t\t// Assume a property is an event if it has a form of \"onSomething\"\n\t\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n\t}\n}\n\nconst colorTables = [\n\t['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n\t['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n];\n\nfunction prettyWithoutArrays(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (data && typeof data === 'object' && typeof data.toString === 'function') {\n\t\tlet result = data.toString();\n\t\tif (result !== '[object Object]') {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nexport function logWithColors(direction: string, totalLength: number, msgLength: number, req: number, initiator: RequestInitiator, str: string, data: any): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [`%c[${direction}]%c[${String(totalLength).padStart(7, ' ')}]%c[len: ${String(msgLength).padStart(5, ' ')}]%c${String(req).padStart(5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(')');\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) { }\n\n\tpublic logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(this._outgoingPrefix, this._totalOutgoing, msgLength, requestId, initiator, str, data);\n\t}\n\n\tpublic logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(this._incomingPrefix, this._totalIncoming, msgLength, requestId, initiator, str, data);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { ThrottledDelayer } from 'vs/base/common/async';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\n\tgetItems(): Promise<Map<string, string>>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n\n\tclose(recovery?: () => Map<string, string>): Promise<void>;\n}\n\nexport interface IStorage extends IDisposable {\n\n\treadonly onDidChangeStorage: Event<string>;\n\n\treadonly items: Map<string, string>;\n\treadonly size: number;\n\n\tinit(): Promise<void>;\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tset(key: string, value: string | boolean | number | undefined | null): Promise<void>;\n\tdelete(key: string): Promise<void>;\n\n\twhenFlushed(): Promise<void>;\n\n\tclose(): Promise<void>;\n}\n\nenum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(new Emitter<string>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = new ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY);\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\t// items that change external require us to update our\n\t\t// caches with the values. we just accept the value and\n\t\t// emit an event if there is a change.\n\t\te.changed?.forEach((value, key) => this.accept(key, value));\n\t\te.deleted?.forEach(key => this.accept(key, undefined));\n\t}\n\n\tprivate accept(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire(key);\n\t\t}\n\t}\n\n\tget items(): Map<string, string> {\n\t\treturn this.cache;\n\t}\n\n\tget size(): number {\n\t\treturn this.cache.size;\n\t}\n\n\tasync init(): Promise<void> {\n\t\tif (this.state !== StorageState.None) {\n\t\t\treturn; // either closed or already initialized\n\t\t}\n\n\t\tthis.state = StorageState.Initialized;\n\n\t\tif (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n\t\t\t// return early if we know the storage file does not exist. this is a performance\n\t\t\t// optimization to not load all items of the underlying storage if we know that\n\t\t\t// there can be no items because the storage does not exist.\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cache = await this.database.getItems();\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tasync set(key: string, value: string | boolean | number | null | undefined): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire(key);\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.flushDelayer.trigger(() => this.flushPending());\n\t}\n\n\tasync delete(key: string): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire(key);\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.flushDelayer.trigger(() => this.flushPending());\n\t}\n\n\tasync close(): Promise<void> {\n\t\tif (!this.pendingClose) {\n\t\t\tthis.pendingClose = this.doClose();\n\t\t}\n\n\t\treturn this.pendingClose;\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Trigger new flush to ensure data is persisted and then close\n\t\t// even if there is an error flushing. We must always ensure\n\t\t// the DB is closed to avoid corruption.\n\t\t//\n\t\t// Recovery: we pass our cache over as recovery option in case\n\t\t// the DB is not healthy.\n\t\ttry {\n\t\t\tawait this.flushDelayer.trigger(() => this.flushPending(), 0 /* as soon as possible */);\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tawait this.database.close(() => this.cache);\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise(resolve => this.whenFlushedCallbacks.push(resolve));\n\t}\n\n\toverride dispose(): void {\n\t\tthis.flushDelayer.cancel(); // workaround https://github.com/microsoft/vscode/issues/116777\n\t\tthis.flushDelayer.dispose();\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\treturn this.items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\tif (request.insert) {\n\t\t\trequest.insert.forEach((value, key) => this.items.set(key, value));\n\t\t}\n\n\t\tif (request.delete) {\n\t\t\trequest.delete.forEach(key => this.items.delete(key));\n\t\t}\n\t}\n\n\tasync close(): Promise<void> { }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\n\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst month = day * 30;\nconst year = day * 365;\n\nexport function fromNow(date: number | Date, appendAgoLabel?: boolean): string {\n\tif (typeof date !== 'number') {\n\t\tdate = date.getTime();\n\t}\n\n\tconst seconds = Math.round((new Date().getTime() - date) / 1000);\n\tif (seconds < -30) {\n\t\treturn localize('date.fromNow.in', 'in {0}', fromNow(new Date().getTime() + seconds * 1000, false));\n\t}\n\n\tif (seconds < 30) {\n\t\treturn localize('date.fromNow.now', 'now');\n\t}\n\n\tlet value: number;\n\tif (seconds < minute) {\n\t\tvalue = seconds;\n\n\t\tif (appendAgoLabel) {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.seconds.singular.ago', '{0} sec ago', value)\n\t\t\t\t: localize('date.fromNow.seconds.plural.ago', '{0} secs ago', value);\n\t\t} else {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.seconds.singular', '{0} sec', value)\n\t\t\t\t: localize('date.fromNow.seconds.plural', '{0} secs', value);\n\t\t}\n\t}\n\n\tif (seconds < hour) {\n\t\tvalue = Math.floor(seconds / minute);\n\t\tif (appendAgoLabel) {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.minutes.singular.ago', '{0} min ago', value)\n\t\t\t\t: localize('date.fromNow.minutes.plural.ago', '{0} mins ago', value);\n\t\t} else {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.minutes.singular', '{0} min', value)\n\t\t\t\t: localize('date.fromNow.minutes.plural', '{0} mins', value);\n\t\t}\n\t}\n\n\tif (seconds < day) {\n\t\tvalue = Math.floor(seconds / hour);\n\t\tif (appendAgoLabel) {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.hours.singular.ago', '{0} hr ago', value)\n\t\t\t\t: localize('date.fromNow.hours.plural.ago', '{0} hrs ago', value);\n\t\t} else {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.hours.singular', '{0} hr', value)\n\t\t\t\t: localize('date.fromNow.hours.plural', '{0} hrs', value);\n\t\t}\n\t}\n\n\tif (seconds < week) {\n\t\tvalue = Math.floor(seconds / day);\n\t\tif (appendAgoLabel) {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.days.singular.ago', '{0} day ago', value)\n\t\t\t\t: localize('date.fromNow.days.plural.ago', '{0} days ago', value);\n\t\t} else {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.days.singular', '{0} day', value)\n\t\t\t\t: localize('date.fromNow.days.plural', '{0} days', value);\n\t\t}\n\t}\n\n\tif (seconds < month) {\n\t\tvalue = Math.floor(seconds / week);\n\t\tif (appendAgoLabel) {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.weeks.singular.ago', '{0} wk ago', value)\n\t\t\t\t: localize('date.fromNow.weeks.plural.ago', '{0} wks ago', value);\n\t\t} else {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.weeks.singular', '{0} wk', value)\n\t\t\t\t: localize('date.fromNow.weeks.plural', '{0} wks', value);\n\t\t}\n\t}\n\n\tif (seconds < year) {\n\t\tvalue = Math.floor(seconds / month);\n\t\tif (appendAgoLabel) {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.months.singular.ago', '{0} mo ago', value)\n\t\t\t\t: localize('date.fromNow.months.plural.ago', '{0} mos ago', value);\n\t\t} else {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.months.singular', '{0} mo', value)\n\t\t\t\t: localize('date.fromNow.months.plural', '{0} mos', value);\n\t\t}\n\t}\n\n\tvalue = Math.floor(seconds / year);\n\tif (appendAgoLabel) {\n\t\treturn value === 1\n\t\t\t? localize('date.fromNow.years.singular.ago', '{0} yr ago', value)\n\t\t\t: localize('date.fromNow.years.plural.ago', '{0} yrs ago', value);\n\t} else {\n\t\treturn value === 1\n\t\t\t? localize('date.fromNow.years.singular', '{0} yr', value)\n\t\t\t: localize('date.fromNow.years.plural', '{0} yrs', value);\n\t}\n}\n\nexport function toLocalISOString(date: Date): string {\n\treturn date.getFullYear() +\n\t\t'-' + String(date.getMonth() + 1).padStart(2, '0') +\n\t\t'-' + String(date.getDate()).padStart(2, '0') +\n\t\t'T' + String(date.getHours()).padStart(2, '0') +\n\t\t':' + String(date.getMinutes()).padStart(2, '0') +\n\t\t':' + String(date.getSeconds()).padStart(2, '0') +\n\t\t'.' + (date.getMilliseconds() / 1000).toFixed(3).slice(2, 5) +\n\t\t'Z';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport * as types from 'vs/base/common/types';\nimport * as arrays from 'vs/base/common/arrays';\n\nfunction exceptionToErrorMessage(exception: any, verbose: boolean): string {\n\tif (verbose && (exception.stack || exception.stacktrace)) {\n\t\treturn nls.localize('stackTrace.format', \"{0}: {1}\", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));\n\t}\n\n\treturn detectSystemErrorMessage(exception);\n}\n\nfunction stackToString(stack: string[] | string | undefined): string | undefined {\n\tif (Array.isArray(stack)) {\n\t\treturn stack.join('\\n');\n\t}\n\n\treturn stack;\n}\n\nfunction detectSystemErrorMessage(exception: any): string {\n\n\t// See https://nodejs.org/api/errors.html#errors_class_system_error\n\tif (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n\t\treturn nls.localize('nodeExceptionMessage', \"A system error occurred ({0})\", exception.message);\n\t}\n\n\treturn exception.message || nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n\n/**\n * Tries to generate a human readable error message out of the error. If the verbose parameter\n * is set to true, the error message will include stacktrace details if provided.\n *\n * @returns A string containing the error message.\n */\nexport function toErrorMessage(error: any = null, verbose: boolean = false): string {\n\tif (!error) {\n\t\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n\t}\n\n\tif (Array.isArray(error)) {\n\t\tconst errors: any[] = arrays.coalesce(error);\n\t\tconst msg = toErrorMessage(errors[0], verbose);\n\n\t\tif (errors.length > 1) {\n\t\t\treturn nls.localize('error.moreErrors', \"{0} ({1} errors in total)\", msg, errors.length);\n\t\t}\n\n\t\treturn msg;\n\t}\n\n\tif (types.isString(error)) {\n\t\treturn error;\n\t}\n\n\tif (error.detail) {\n\t\tconst detail = error.detail;\n\n\t\tif (detail.error) {\n\t\t\treturn exceptionToErrorMessage(detail.error, verbose);\n\t\t}\n\n\t\tif (detail.exception) {\n\t\t\treturn exceptionToErrorMessage(detail.exception, verbose);\n\t\t}\n\t}\n\n\tif (error.stack) {\n\t\treturn exceptionToErrorMessage(error, verbose);\n\t}\n\n\tif (error.message) {\n\t\treturn error.message;\n\t}\n\n\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport * as pfs from 'vs/base/node/pfs';\nimport * as cp from 'child_process';\nimport * as nls from 'vs/nls';\nimport * as process from 'vs/base/common/process';\nimport * as Types from 'vs/base/common/types';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as Objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as Platform from 'vs/base/common/platform';\nimport { LineDecoder } from 'vs/base/node/decoder';\nimport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode, Executable } from 'vs/base/common/processes';\nimport { FileAccess } from 'vs/base/common/network';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport interface LineData {\n\tline: string;\n\tsource: Source;\n}\n\nfunction getWindowsCode(status: number): TerminateResponseCode {\n\tswitch (status) {\n\t\tcase 0:\n\t\t\treturn TerminateResponseCode.Success;\n\t\tcase 1:\n\t\t\treturn TerminateResponseCode.AccessDenied;\n\t\tcase 128:\n\t\t\treturn TerminateResponseCode.ProcessNotFound;\n\t\tdefault:\n\t\t\treturn TerminateResponseCode.Unknown;\n\t}\n}\n\nfunction terminateProcess(process: cp.ChildProcess, cwd?: string): Promise<TerminateResponse> {\n\tif (Platform.isWindows) {\n\t\ttry {\n\t\t\tconst options: any = {\n\t\t\t\tstdio: ['pipe', 'pipe', 'ignore']\n\t\t\t};\n\t\t\tif (cwd) {\n\t\t\t\toptions.cwd = cwd;\n\t\t\t}\n\t\t\tconst killProcess = cp.execFile('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tkillProcess.once('error', (err) => {\n\t\t\t\t\tresolve({ success: false, error: err });\n\t\t\t\t});\n\t\t\t\tkillProcess.once('exit', (code, signal) => {\n\t\t\t\t\tif (code === 0) {\n\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ success: false, code: code !== null ? code : TerminateResponseCode.Unknown });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn Promise.resolve({ success: false, error: err, code: err.status ? getWindowsCode(err.status) : TerminateResponseCode.Unknown });\n\t\t}\n\t} else if (Platform.isLinux || Platform.isMacintosh) {\n\t\ttry {\n\t\t\tconst cmd = FileAccess.asFileUri('vs/base/node/terminateProcess.sh', require).fsPath;\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tcp.execFile(cmd, [process.pid.toString()], { encoding: 'utf8', shell: true } as cp.ExecFileOptions, (err, stdout, stderr) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tresolve({ success: false, error: err });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn Promise.resolve({ success: false, error: err });\n\t\t}\n\t} else {\n\t\tprocess.kill('SIGKILL');\n\t}\n\treturn Promise.resolve({ success: true });\n}\n\nexport function getWindowsShell(env = process.env as Platform.IProcessEnvironment): string {\n\treturn env['comspec'] || 'cmd.exe';\n}\n\nexport abstract class AbstractProcess<TProgressData> {\n\tprivate cmd: string;\n\tprivate args: string[];\n\tprivate options: CommandOptions | ForkOptions;\n\tprotected shell: boolean;\n\n\tprivate childProcess: cp.ChildProcess | null;\n\tprotected childProcessPromise: Promise<cp.ChildProcess> | null;\n\tprivate pidResolve: ValueCallback<number> | undefined;\n\tprotected terminateRequested: boolean;\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[] | undefined, shell: boolean, options: CommandOptions | undefined);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean, arg4?: CommandOptions) {\n\t\tif (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n\t\t\tthis.cmd = <string>arg1;\n\t\t\tthis.args = arg2;\n\t\t\tthis.shell = arg3;\n\t\t\tthis.options = arg4;\n\t\t} else {\n\t\t\tconst executable = <Executable>arg1;\n\t\t\tthis.cmd = executable.command;\n\t\t\tthis.shell = executable.isShellCommand;\n\t\t\tthis.args = executable.args.slice(0);\n\t\t\tthis.options = executable.options || {};\n\t\t}\n\n\t\tthis.childProcess = null;\n\t\tthis.childProcessPromise = null;\n\t\tthis.terminateRequested = false;\n\n\t\tif (this.options.env) {\n\t\t\tconst newEnv: IStringDictionary<string> = Object.create(null);\n\t\t\tObject.keys(process.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = process.env[key]!;\n\t\t\t});\n\t\t\tObject.keys(this.options.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = this.options.env![key]!;\n\t\t\t});\n\t\t\tthis.options.env = newEnv;\n\t\t}\n\t}\n\n\tpublic getSanitizedCommand(): string {\n\t\tlet result = this.cmd.toLowerCase();\n\t\tconst index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (AbstractProcess.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tpublic start(pp: ProgressCallback<TProgressData>): Promise<SuccessData> {\n\t\tif (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n\t\t\treturn Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n\t\t}\n\t\treturn this.useExec().then((useExec) => {\n\t\t\tlet cc: ValueCallback<SuccessData>;\n\t\t\tlet ee: ErrorCallback;\n\t\t\tconst result = new Promise<any>((c, e) => {\n\t\t\t\tcc = c;\n\t\t\t\tee = e;\n\t\t\t});\n\n\t\t\tif (useExec) {\n\t\t\t\tlet cmd: string = this.cmd;\n\t\t\t\tif (this.args) {\n\t\t\t\t\tcmd = cmd + ' ' + this.args.join(' ');\n\t\t\t\t}\n\t\t\t\tthis.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tconst err: any = error;\n\t\t\t\t\t// This is tricky since executing a command shell reports error back in case the executed command return an\n\t\t\t\t\t// error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n\t\t\t\t\t// always parse the output and report success unless the job got killed.\n\t\t\t\t\tif (err && err.killed) {\n\t\t\t\t\t\tee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleExec(cc, pp, error, stdout as any, stderr as any);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet childProcess: cp.ChildProcess | null = null;\n\t\t\t\tconst closeHandler = (data: any) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tthis.childProcessPromise = null;\n\t\t\t\t\tthis.handleClose(data, cc, pp, ee);\n\t\t\t\t\tconst result: SuccessData = {\n\t\t\t\t\t\tterminated: this.terminateRequested\n\t\t\t\t\t};\n\t\t\t\t\tif (Types.isNumber(data)) {\n\t\t\t\t\t\tresult.cmdCode = <number>data;\n\t\t\t\t\t}\n\t\t\t\t\tcc(result);\n\t\t\t\t};\n\t\t\t\tif (this.shell && Platform.isWindows) {\n\t\t\t\t\tconst options: any = Objects.deepClone(this.options);\n\t\t\t\t\toptions.windowsVerbatimArguments = true;\n\t\t\t\t\toptions.detached = false;\n\t\t\t\t\tlet quotedCommand: boolean = false;\n\t\t\t\t\tlet quotedArg: boolean = false;\n\t\t\t\t\tconst commandLine: string[] = [];\n\t\t\t\t\tlet quoted = this.ensureQuotes(this.cmd);\n\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\tquotedCommand = quoted.quoted;\n\t\t\t\t\tif (this.args) {\n\t\t\t\t\t\tthis.args.forEach((elem) => {\n\t\t\t\t\t\t\tquoted = this.ensureQuotes(elem);\n\t\t\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\t\t\tquotedArg = quotedArg && quoted.quoted;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconst args: string[] = [\n\t\t\t\t\t\t'/s',\n\t\t\t\t\t\t'/c',\n\t\t\t\t\t];\n\t\t\t\t\tif (quotedCommand) {\n\t\t\t\t\t\tif (quotedArg) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine.join(' ') + '\"');\n\t\t\t\t\t\t} else if (commandLine.length > 1) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push(commandLine.join(' '));\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess = cp.spawn(getWindowsShell(), args, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.cmd) {\n\t\t\t\t\t\tchildProcess = cp.spawn(this.cmd, this.args, this.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (childProcess) {\n\t\t\t\t\tthis.childProcess = childProcess;\n\t\t\t\t\tthis.childProcessPromise = Promise.resolve(childProcess);\n\t\t\t\t\tif (this.pidResolve) {\n\t\t\t\t\t\tthis.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n\t\t\t\t\t\tthis.pidResolve = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess.on('error', (error: Error) => {\n\t\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\t\tee({ terminated: this.terminateRequested, error: error });\n\t\t\t\t\t});\n\t\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\t\tthis.childProcess.on('close', closeHandler);\n\t\t\t\t\t\tthis.handleSpawn(childProcess, cc!, pp, ee!, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tprotected abstract handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, error: Error | null, stdout: Buffer, stderr: Buffer): void;\n\tprotected abstract handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback, sync: boolean): void;\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback): void {\n\t\t// Default is to do nothing.\n\t}\n\n\tprivate static readonly regexp = /^[^\"].* .*[^\"]/;\n\tprivate ensureQuotes(value: string) {\n\t\tif (AbstractProcess.regexp.test(value)) {\n\t\t\treturn {\n\t\t\t\tvalue: '\"' + value + '\"', //`\"${value}\"`,\n\t\t\t\tquoted: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tquoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic get pid(): Promise<number> {\n\t\tif (this.childProcessPromise) {\n\t\t\treturn this.childProcessPromise.then(childProcess => childProcess.pid, err => -1);\n\t\t} else {\n\t\t\treturn new Promise<number>((resolve) => {\n\t\t\t\tthis.pidResolve = resolve;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic terminate(): Promise<TerminateResponse> {\n\t\tif (!this.childProcessPromise) {\n\t\t\treturn Promise.resolve<TerminateResponse>({ success: true });\n\t\t}\n\t\treturn this.childProcessPromise.then((childProcess) => {\n\t\t\tthis.terminateRequested = true;\n\t\t\treturn terminateProcess(childProcess, this.options.cwd).then(response => {\n\t\t\t\tif (response.success) {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t});\n\t\t}, (err) => {\n\t\t\treturn { success: true };\n\t\t});\n\t}\n\n\tprivate useExec(): Promise<boolean> {\n\t\treturn new Promise<boolean>(resolve => {\n\t\t\tif (!this.shell || !Platform.isWindows) {\n\t\t\t\treturn resolve(false);\n\t\t\t}\n\t\t\tconst cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n\t\t\tcmdShell.on('error', (error: Error) => {\n\t\t\t\treturn resolve(true);\n\t\t\t});\n\t\t\tcmdShell.on('exit', (data: any) => {\n\t\t\t\treturn resolve(false);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class LineProcess extends AbstractProcess<LineData> {\n\n\tprivate stdoutLineDecoder: LineDecoder | null;\n\tprivate stderrLineDecoder: LineDecoder | null;\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[], shell: boolean, options: CommandOptions);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean | ForkOptions, arg4?: CommandOptions) {\n\t\tsuper(<any>arg1, arg2, <any>arg3, arg4);\n\n\t\tthis.stdoutLineDecoder = null;\n\t\tthis.stderrLineDecoder = null;\n\t}\n\n\tprotected handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, error: Error, stdout: Buffer, stderr: Buffer) {\n\t\t[stdout, stderr].forEach((buffer: Buffer, index: number) => {\n\t\t\tconst lineDecoder = new LineDecoder();\n\t\t\tconst lines = lineDecoder.write(buffer);\n\t\t\tlines.forEach((line) => {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t});\n\t\t\tconst line = lineDecoder.end();\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t\tcc({ terminated: this.terminateRequested, error: error });\n\t}\n\n\tprotected handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback, sync: boolean): void {\n\t\tconst stdoutLineDecoder = new LineDecoder();\n\t\tconst stderrLineDecoder = new LineDecoder();\n\t\tchildProcess.stdout!.on('data', (data: Buffer) => {\n\t\t\tconst lines = stdoutLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stdout }));\n\t\t});\n\t\tchildProcess.stderr!.on('data', (data: Buffer) => {\n\t\t\tconst lines = stderrLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stderr }));\n\t\t});\n\n\t\tthis.stdoutLineDecoder = stdoutLineDecoder;\n\t\tthis.stderrLineDecoder = stderrLineDecoder;\n\t}\n\n\tprotected override handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback): void {\n\t\tconst stdoutLine = this.stdoutLineDecoder ? this.stdoutLineDecoder.end() : null;\n\t\tif (stdoutLine) {\n\t\t\tpp({ line: stdoutLine, source: Source.stdout });\n\t\t}\n\t\tconst stderrLine = this.stderrLineDecoder ? this.stderrLineDecoder.end() : null;\n\t\tif (stderrLine) {\n\t\t\tpp({ line: stderrLine, source: Source.stderr });\n\t\t}\n\t}\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport async function findExecutable(command: string, cwd?: string, paths?: string[]): Promise<string> {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env['PATH'])) {\n\t\t\tpaths = process.env['PATH'].split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\n\t\tasync function fileExists(path: string): Promise<boolean> {\n\t\t\tif (await pfs.exists(path)) {\n\t\t\t\treturn !((await fs.promises.stat(path)).isDirectory());\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (let pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (await fileExists(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { release, userInfo } from 'os';\nimport * as platform from 'vs/base/common/platform';\nimport { getFirstAvailablePowerShellInstallation } from 'vs/base/node/powershell';\nimport * as processes from 'vs/base/node/processes';\n\n/**\n * Gets the detected default shell for the _system_, not to be confused with VS Code's _default_\n * shell that the terminal uses by default.\n * @param os The platform to detect the shell of.\n */\nexport async function getSystemShell(os: platform.OperatingSystem, env: platform.IProcessEnvironment): Promise<string> {\n\tif (os === platform.OperatingSystem.Windows) {\n\t\tif (platform.isWindows) {\n\t\t\treturn getSystemShellWindows();\n\t\t}\n\t\t// Don't detect Windows shell when not on Windows\n\t\treturn processes.getWindowsShell(env);\n\t}\n\n\treturn getSystemShellUnixLike(os, env);\n}\n\nexport function getSystemShellSync(os: platform.OperatingSystem, env: platform.IProcessEnvironment): string {\n\tif (os === platform.OperatingSystem.Windows) {\n\t\tif (platform.isWindows) {\n\t\t\treturn getSystemShellWindowsSync(env);\n\t\t}\n\t\t// Don't detect Windows shell when not on Windows\n\t\treturn processes.getWindowsShell(env);\n\t}\n\n\treturn getSystemShellUnixLike(os, env);\n}\n\nlet _TERMINAL_DEFAULT_SHELL_UNIX_LIKE: string | null = null;\nfunction getSystemShellUnixLike(os: platform.OperatingSystem, env: platform.IProcessEnvironment): string {\n\t// Only use $SHELL for the current OS\n\tif (platform.isLinux && os === platform.OperatingSystem.Macintosh || platform.isMacintosh && os === platform.OperatingSystem.Linux) {\n\t\treturn '/bin/bash';\n\t}\n\n\tif (!_TERMINAL_DEFAULT_SHELL_UNIX_LIKE) {\n\t\tlet unixLikeTerminal: string | undefined;\n\t\tif (platform.isWindows) {\n\t\t\tunixLikeTerminal = '/bin/bash'; // for WSL\n\t\t} else {\n\t\t\tunixLikeTerminal = env['SHELL'];\n\n\t\t\tif (!unixLikeTerminal) {\n\t\t\t\ttry {\n\t\t\t\t\t// It's possible for $SHELL to be unset, this API reads /etc/passwd. See https://github.com/github/codespaces/issues/1639\n\t\t\t\t\t// Node docs: \"Throws a SystemError if a user has no username or homedir.\"\n\t\t\t\t\tunixLikeTerminal = userInfo().shell;\n\t\t\t\t} catch (err) { }\n\t\t\t}\n\n\t\t\tif (!unixLikeTerminal) {\n\t\t\t\tunixLikeTerminal = 'sh';\n\t\t\t}\n\n\t\t\t// Some systems have $SHELL set to /bin/false which breaks the terminal\n\t\t\tif (unixLikeTerminal === '/bin/false') {\n\t\t\t\tunixLikeTerminal = '/bin/bash';\n\t\t\t}\n\t\t}\n\t\t_TERMINAL_DEFAULT_SHELL_UNIX_LIKE = unixLikeTerminal;\n\t}\n\treturn _TERMINAL_DEFAULT_SHELL_UNIX_LIKE;\n}\n\nlet _TERMINAL_DEFAULT_SHELL_WINDOWS: string | null = null;\nasync function getSystemShellWindows(): Promise<string> {\n\tif (!_TERMINAL_DEFAULT_SHELL_WINDOWS) {\n\t\t_TERMINAL_DEFAULT_SHELL_WINDOWS = (await getFirstAvailablePowerShellInstallation())!.exePath;\n\t}\n\treturn _TERMINAL_DEFAULT_SHELL_WINDOWS;\n}\n\nfunction getSystemShellWindowsSync(env: platform.IProcessEnvironment): string {\n\tif (_TERMINAL_DEFAULT_SHELL_WINDOWS) {\n\t\treturn _TERMINAL_DEFAULT_SHELL_WINDOWS;\n\t}\n\n\tconst isAtLeastWindows10 = platform.isWindows && parseFloat(release()) >= 10;\n\tconst is32ProcessOn64Windows = env.hasOwnProperty('PROCESSOR_ARCHITEW6432');\n\tconst powerShellPath = `${env['windir']}\\\\${is32ProcessOn64Windows ? 'Sysnative' : 'System32'}\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe`;\n\treturn isAtLeastWindows10 ? powerShellPath : processes.getWindowsShell(env);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, fork, ForkOptions } from 'child_process';\nimport { IDisposable, toDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Delayer, createCancelablePromise } from 'vs/base/common/async';\nimport { deepClone } from 'vs/base/common/objects';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { createQueuedSender } from 'vs/base/node/processes';\nimport { IChannel, ChannelServer as IPCServer, ChannelClient as IPCClient, IChannelClient } from 'vs/base/parts/ipc/common/ipc';\nimport { isRemoteConsoleLog, log } from 'vs/base/common/console';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { isMacintosh } from 'vs/base/common/platform';\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper({\n\t\t\tsend: r => {\n\t\t\t\ttry {\n\t\t\t\t\tif (process.send) {\n\t\t\t\t\t\tprocess.send((<Buffer>r.buffer).toString('base64'));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /* not much to do */ }\n\t\t\t},\n\t\t\tonMessage: Event.fromNodeEventEmitter(process, 'message', msg => VSBuffer.wrap(Buffer.from(msg, 'base64')))\n\t\t}, ctx);\n\n\t\tprocess.once('disconnect', () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * If set, starts the fork with empty execArgv. If not set, execArgv from the parent proces are inherited,\n\t * except --inspect= and --inspect-brk= which are filtered as they would result in a port conflict.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\n\tprivate disposeDelayer: Delayer<void> | undefined;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate readonly _onDidProcessExit = new Emitter<{ code: number, signal: string }>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(private modulePath: string, private options: IIPCOptions) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error('disposed'));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise(token => channel.call<T>(name, arg, token));\n\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(channelName: string, name: string, arg?: any): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args = this.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = { ...deepClone(process.env), 'VSCODE_PARENT_PID': String(process.pid) };\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = { ...forkOpts.env, ...this.options.env };\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n\t\t\t}\n\n\t\t\tif (forkOpts.execArgv === undefined) {\n\t\t\t\t// if not set, the forked process inherits the execArgv of the parent process\n\t\t\t\t// --inspect and --inspect-brk can not be inherited as the port would conflict\n\t\t\t\tforkOpts.execArgv = process.execArgv.filter(a => !/^--inspect(-brk)?=/.test(a)); // remove\n\t\t\t}\n\n\t\t\tif (isMacintosh && forkOpts.env) {\n\t\t\t\t// Unset `DYLD_LIBRARY_PATH`, as it leads to process crashes\n\t\t\t\t// See https://github.com/microsoft/vscode/issues/105848\n\t\t\t\tdelete forkOpts.env['DYLD_LIBRARY_PATH'];\n\t\t\t}\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<VSBuffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n\n\t\t\tonRawMessage(msg => {\n\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(VSBuffer.wrap(Buffer.from(msg, 'base64')));\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue ? createQueuedSender(this.child) : this.child;\n\t\t\tconst send = (r: VSBuffer) => this.child && this.child.connected && sender.send((<Buffer>r.buffer).toString('base64'));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once('exit', onExit);\n\n\t\t\tthis.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n\n\t\t\tthis.child.on('exit', (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener('exit' as 'loaded', onExit); // https://github.com/electron/electron/issues/21475\n\n\t\t\t\tthis.activeRequests.forEach(r => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== 'SIGTERM') {\n\t\t\t\t\tconsole.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n\t\t\t\t}\n\n\t\t\t\tif (this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.cancel();\n\t\t\t\t}\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tif (this.disposeDelayer) {\n\t\t\tthis.disposeDelayer.cancel();\n\t\t\tthis.disposeDelayer = undefined;\n\t\t}\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IProductService } from 'vs/platform/product/common/productService';\nimport { IDebugParams, IExtensionHostDebugParams, INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { NativeParsedArgs } from 'vs/platform/environment/common/argv';\nimport { dirname, join, normalize, resolve } from 'vs/base/common/path';\nimport { joinPath } from 'vs/base/common/resources';\nimport { memoize } from 'vs/base/common/decorators';\nimport { toLocalISOString } from 'vs/base/common/date';\nimport { FileAccess } from 'vs/base/common/network';\nimport { URI } from 'vs/base/common/uri';\nimport { ExtensionKind } from 'vs/platform/extensions/common/extensions';\nimport { env } from 'vs/base/common/process';\n\nexport interface INativeEnvironmentPaths {\n\n\t/**\n\t * The user data directory to use for anything that should be\n\t * persisted except for the content that is meant for the `homeDir`.\n\t *\n\t * Only one instance of VSCode can use the same `userDataDir`.\n\t */\n\tuserDataDir: string\n\n\t/**\n\t * The user home directory mainly used for persisting extensions\n\t * and global configuration that should be shared across all\n\t * versions.\n\t */\n\thomeDir: string;\n\n\t/**\n\t * OS tmp dir.\n\t */\n\ttmpDir: string,\n}\n\nexport abstract class AbstractNativeEnvironmentService implements INativeEnvironmentService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t@memoize\n\tget appRoot(): string { return dirname(FileAccess.asFileUri('', require).fsPath); }\n\n\t@memoize\n\tget userHome(): URI { return URI.file(this.paths.homeDir); }\n\n\t@memoize\n\tget userDataPath(): string { return this.paths.userDataDir; }\n\n\t@memoize\n\tget appSettingsHome(): URI { return URI.file(join(this.userDataPath, 'User')); }\n\n\t@memoize\n\tget tmpDir(): URI { return URI.file(this.paths.tmpDir); }\n\n\t@memoize\n\tget userRoamingDataHome(): URI { return this.appSettingsHome; }\n\n\t@memoize\n\tget settingsResource(): URI { return joinPath(this.userRoamingDataHome, 'settings.json'); }\n\n\t@memoize\n\tget userDataSyncHome(): URI { return joinPath(this.userRoamingDataHome, 'sync'); }\n\n\tget logsPath(): string {\n\t\tif (!this.args.logsPath) {\n\t\t\tconst key = toLocalISOString(new Date()).replace(/-|:|\\.\\d+Z$/g, '');\n\t\t\tthis.args.logsPath = join(this.userDataPath, 'logs', key);\n\t\t}\n\n\t\treturn this.args.logsPath;\n\t}\n\n\t@memoize\n\tget userDataSyncLogResource(): URI { return URI.file(join(this.logsPath, 'userDataSync.log')); }\n\n\t@memoize\n\tget sync(): 'on' | 'off' | undefined { return this.args.sync; }\n\n\t@memoize\n\tget machineSettingsResource(): URI { return joinPath(URI.file(join(this.userDataPath, 'Machine')), 'settings.json'); }\n\n\t@memoize\n\tget globalStorageHome(): URI { return URI.joinPath(this.appSettingsHome, 'globalStorage'); }\n\n\t@memoize\n\tget workspaceStorageHome(): URI { return URI.joinPath(this.appSettingsHome, 'workspaceStorage'); }\n\n\t@memoize\n\tget keybindingsResource(): URI { return joinPath(this.userRoamingDataHome, 'keybindings.json'); }\n\n\t@memoize\n\tget keyboardLayoutResource(): URI { return joinPath(this.userRoamingDataHome, 'keyboardLayout.json'); }\n\n\t@memoize\n\tget argvResource(): URI {\n\t\tconst vscodePortable = env['VSCODE_PORTABLE'];\n\t\tif (vscodePortable) {\n\t\t\treturn URI.file(join(vscodePortable, 'argv.json'));\n\t\t}\n\n\t\treturn joinPath(this.userHome, this.productService.dataFolderName, 'argv.json');\n\t}\n\n\t@memoize\n\tget snippetsHome(): URI { return joinPath(this.userRoamingDataHome, 'snippets'); }\n\n\t@memoize\n\tget isExtensionDevelopment(): boolean { return !!this.args.extensionDevelopmentPath; }\n\n\t@memoize\n\tget untitledWorkspacesHome(): URI { return URI.file(join(this.userDataPath, 'Workspaces')); }\n\n\t@memoize\n\tget installSourcePath(): string { return join(this.userDataPath, 'installSource'); }\n\n\t@memoize\n\tget builtinExtensionsPath(): string {\n\t\tconst cliBuiltinExtensionsDir = this.args['builtin-extensions-dir'];\n\t\tif (cliBuiltinExtensionsDir) {\n\t\t\treturn resolve(cliBuiltinExtensionsDir);\n\t\t}\n\n\t\treturn normalize(join(FileAccess.asFileUri('', require).fsPath, '..', 'extensions'));\n\t}\n\n\tget extensionsDownloadPath(): string {\n\t\tconst cliExtensionsDownloadDir = this.args['extensions-download-dir'];\n\t\tif (cliExtensionsDownloadDir) {\n\t\t\treturn resolve(cliExtensionsDownloadDir);\n\t\t}\n\n\t\treturn join(this.userDataPath, 'CachedExtensionVSIXs');\n\t}\n\n\t@memoize\n\tget extensionsPath(): string {\n\t\tconst cliExtensionsDir = this.args['extensions-dir'];\n\t\tif (cliExtensionsDir) {\n\t\t\treturn resolve(cliExtensionsDir);\n\t\t}\n\n\t\tconst vscodeExtensions = env['VSCODE_EXTENSIONS'];\n\t\tif (vscodeExtensions) {\n\t\t\treturn vscodeExtensions;\n\t\t}\n\n\t\tconst vscodePortable = env['VSCODE_PORTABLE'];\n\t\tif (vscodePortable) {\n\t\t\treturn join(vscodePortable, 'extensions');\n\t\t}\n\n\t\treturn joinPath(this.userHome, this.productService.dataFolderName, 'extensions').fsPath;\n\t}\n\n\t@memoize\n\tget extensionDevelopmentLocationURI(): URI[] | undefined {\n\t\tconst extensionDevelopmentPaths = this.args.extensionDevelopmentPath;\n\t\tif (Array.isArray(extensionDevelopmentPaths)) {\n\t\t\treturn extensionDevelopmentPaths.map(extensionDevelopmentPath => {\n\t\t\t\tif (/^[^:/?#]+?:\\/\\//.test(extensionDevelopmentPath)) {\n\t\t\t\t\treturn URI.parse(extensionDevelopmentPath);\n\t\t\t\t}\n\n\t\t\t\treturn URI.file(normalize(extensionDevelopmentPath));\n\t\t\t});\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@memoize\n\tget extensionDevelopmentKind(): ExtensionKind[] | undefined {\n\t\treturn this.args.extensionDevelopmentKind?.map(kind => kind === 'ui' || kind === 'workspace' || kind === 'web' ? kind : 'workspace');\n\t}\n\n\t@memoize\n\tget extensionTestsLocationURI(): URI | undefined {\n\t\tconst extensionTestsPath = this.args.extensionTestsPath;\n\t\tif (extensionTestsPath) {\n\t\t\tif (/^[^:/?#]+?:\\/\\//.test(extensionTestsPath)) {\n\t\t\t\treturn URI.parse(extensionTestsPath);\n\t\t\t}\n\n\t\t\treturn URI.file(normalize(extensionTestsPath));\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget disableExtensions(): boolean | string[] {\n\t\tif (this.args['disable-extensions']) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst disableExtensions = this.args['disable-extension'];\n\t\tif (disableExtensions) {\n\t\t\tif (typeof disableExtensions === 'string') {\n\t\t\t\treturn [disableExtensions];\n\t\t\t}\n\n\t\t\tif (Array.isArray(disableExtensions) && disableExtensions.length > 0) {\n\t\t\t\treturn disableExtensions;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t@memoize\n\tget debugExtensionHost(): IExtensionHostDebugParams { return parseExtensionHostPort(this.args, this.isBuilt); }\n\tget debugRenderer(): boolean { return !!this.args.debugRenderer; }\n\n\tget isBuilt(): boolean { return !env['VSCODE_DEV']; }\n\tget verbose(): boolean { return !!this.args.verbose; }\n\tget logLevel(): string | undefined { return this.args.log; }\n\n\t@memoize\n\tget serviceMachineIdResource(): URI { return joinPath(URI.file(this.userDataPath), 'machineid'); }\n\n\tget crashReporterId(): string | undefined { return this.args['crash-reporter-id']; }\n\tget crashReporterDirectory(): string | undefined { return this.args['crash-reporter-directory']; }\n\n\tget driverHandle(): string | undefined { return this.args['driver']; }\n\n\t@memoize\n\tget telemetryLogResource(): URI { return URI.file(join(this.logsPath, 'telemetry.log')); }\n\tget disableTelemetry(): boolean { return !!this.args['disable-telemetry']; }\n\n\tget args(): NativeParsedArgs { return this._args; }\n\n\tconstructor(\n\t\tprivate readonly _args: NativeParsedArgs,\n\t\tprivate readonly paths: INativeEnvironmentPaths,\n\t\tprotected readonly productService: IProductService\n\t) { }\n}\n\nexport function parseExtensionHostPort(args: NativeParsedArgs, isBuild: boolean): IExtensionHostDebugParams {\n\treturn parseDebugPort(args['inspect-extensions'], args['inspect-brk-extensions'], 5870, isBuild, args.debugId);\n}\n\nexport function parseSearchPort(args: NativeParsedArgs, isBuild: boolean): IDebugParams {\n\treturn parseDebugPort(args['inspect-search'], args['inspect-brk-search'], 5876, isBuild);\n}\n\nfunction parseDebugPort(debugArg: string | undefined, debugBrkArg: string | undefined, defaultBuildPort: number, isBuild: boolean, debugId?: string): IExtensionHostDebugParams {\n\tconst portStr = debugBrkArg || debugArg;\n\tconst port = Number(portStr) || (!isBuild ? defaultBuildPort : null);\n\tconst brk = port ? Boolean(!!debugBrkArg) : false;\n\n\treturn { port, break: brk, debugId };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/// <reference path=\"../../../../typings/require.d.ts\" />\n\n//@ts-check\n(function () {\n\t'use strict';\n\n\t/**\n\t * @typedef {import('../../environment/common/argv').NativeParsedArgs} NativeParsedArgs\n\t *\n\t * @param {typeof import('path')} path\n\t * @param {typeof import('os')} os\n\t * @param {string} productName\n\t * @param {string} cwd\n\t */\n\tfunction factory(path, os, productName, cwd) {\n\n\t\t/**\n\t\t * @param {NativeParsedArgs} cliArgs\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tfunction getUserDataPath(cliArgs) {\n\t\t\tconst userDataPath = doGetUserDataPath(cliArgs);\n\t\t\tconst pathsToResolve = [userDataPath];\n\n\t\t\t// If the user-data-path is not absolute, make\n\t\t\t// sure to resolve it against the passed in\n\t\t\t// current working directory. We cannot use the\n\t\t\t// node.js `path.resolve()` logic because it will\n\t\t\t// not pick up our `VSCODE_CWD` environment variable\n\t\t\t// (https://github.com/microsoft/vscode/issues/120269)\n\t\t\tif (!path.isAbsolute(userDataPath)) {\n\t\t\t\tpathsToResolve.unshift(cwd);\n\t\t\t}\n\n\t\t\treturn path.resolve(...pathsToResolve);\n\t\t}\n\n\t\t/**\n\t\t * @param {NativeParsedArgs} cliArgs\n\t\t *\n\t\t * @returns {string}\n\t\t */\n\t\tfunction doGetUserDataPath(cliArgs) {\n\n\t\t\t// 1. Support portable mode\n\t\t\tconst portablePath = process.env['VSCODE_PORTABLE'];\n\t\t\tif (portablePath) {\n\t\t\t\treturn path.join(portablePath, 'user-data');\n\t\t\t}\n\n\t\t\t// 2. Support explicit --user-data-dir\n\t\t\tconst cliPath = cliArgs['user-data-dir'];\n\t\t\tif (cliPath) {\n\t\t\t\treturn cliPath;\n\t\t\t}\n\n\t\t\t// 3. Support global VSCODE_APPDATA environment variable\n\t\t\tlet appDataPath = process.env['VSCODE_APPDATA'];\n\n\t\t\t// 4. Otherwise check per platform\n\t\t\tif (!appDataPath) {\n\t\t\t\tswitch (process.platform) {\n\t\t\t\t\tcase 'win32':\n\t\t\t\t\t\tappDataPath = process.env['APPDATA'];\n\t\t\t\t\t\tif (!appDataPath) {\n\t\t\t\t\t\t\tconst userProfile = process.env['USERPROFILE'];\n\t\t\t\t\t\t\tif (typeof userProfile !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error('Windows: Unexpected undefined %USERPROFILE% environment variable');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tappDataPath = path.join(userProfile, 'AppData', 'Roaming');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'darwin':\n\t\t\t\t\t\tappDataPath = path.join(os.homedir(), 'Library', 'Application Support');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'linux':\n\t\t\t\t\t\tappDataPath = process.env['XDG_CONFIG_HOME'] || path.join(os.homedir(), '.config');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Platform not supported');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn path.join(appDataPath, productName);\n\t\t}\n\n\t\treturn {\n\t\t\tgetUserDataPath\n\t\t};\n\t}\n\n\tif (typeof define === 'function') {\n\t\tdefine(__m[87/*vs/platform/environment/node/userDataPath*/], __M([0/*require*/,88/*path*/,32/*os*/,10/*vs/base/common/network*/,18/*vs/base/common/resources*/,34/*vs/base/common/process*/]), function (\n\t\t\trequire,\n\t\t\t/** @type {typeof import('path')} */ path,\n\t\t\t/** @type {typeof import('os')} */ os,\n\t\t\t/** @type {typeof import('../../../base/common/network')} */ network,\n\t\t\t/** @type {typeof import(\"../../../base/common/resources\")} */ resources,\n\t\t\t/** @type {typeof import(\"../../../base/common/process\")} */ process\n\t\t) {\n\t\t\tconst rootPath = resources.dirname(network.FileAccess.asFileUri('', require));\n\t\t\tconst pkg = require.__$__nodeRequire(resources.joinPath(rootPath, 'package.json').fsPath);\n\n\t\t\treturn factory(path, os, pkg.name, process.cwd());\n\t\t}); // amd\n\t} else if (typeof module === 'object' && typeof module.exports === 'object') {\n\t\tconst pkg = require('../../../../../package.json');\n\t\tconst path = require('path');\n\t\tconst os = require('os');\n\n\t\tmodule.exports = factory(path, os, pkg.name, process.env['VSCODE_CWD'] || process.cwd()); // commonjs\n\t} else {\n\t\tthrow new Error('Unknown context');\n\t}\n}());\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { homedir, tmpdir } from 'os';\nimport { NativeParsedArgs } from 'vs/platform/environment/common/argv';\nimport { getUserDataPath } from 'vs/platform/environment/node/userDataPath';\nimport { AbstractNativeEnvironmentService } from 'vs/platform/environment/common/environmentService';\nimport { IProductService } from 'vs/platform/product/common/productService';\n\nexport class NativeEnvironmentService extends AbstractNativeEnvironmentService {\n\n\tconstructor(args: NativeParsedArgs, productService: IProductService) {\n\t\tsuper(args, {\n\t\t\thomeDir: homedir(),\n\t\t\ttmpDir: tmpdir(),\n\t\t\tuserDataDir: getUserDataPath(args)\n\t\t}, productService);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { cloneAndChange } from 'vs/base/common/objects';\nimport { IExtensionManifest } from 'vs/platform/extensions/common/extensions';\n\nconst nlsRegex = /^%([\\w\\d.-]+)%$/i;\n\nexport interface ITranslations {\n\t[key: string]: string;\n}\n\nexport function localizeManifest(manifest: IExtensionManifest, translations: ITranslations): IExtensionManifest {\n\tconst patcher = (value: string) => {\n\t\tif (typeof value !== 'string') {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst match = nlsRegex.exec(value);\n\n\t\tif (!match) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn translations[match[1]] || value;\n\t};\n\n\treturn cloneAndChange(manifest, patcher);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\n\nexport interface IParsedVersion {\n\thasCaret: boolean;\n\thasGreaterEquals: boolean;\n\tmajorBase: number;\n\tmajorMustEqual: boolean;\n\tminorBase: number;\n\tminorMustEqual: boolean;\n\tpatchBase: number;\n\tpatchMustEqual: boolean;\n\tpreRelease: string | null;\n}\n\nexport interface INormalizedVersion {\n\tmajorBase: number;\n\tmajorMustEqual: boolean;\n\tminorBase: number;\n\tminorMustEqual: boolean;\n\tpatchBase: number;\n\tpatchMustEqual: boolean;\n\tisMinimum: boolean;\n}\n\nconst VERSION_REGEXP = /^(\\^|>=)?((\\d+)|x)\\.((\\d+)|x)\\.((\\d+)|x)(\\-.*)?$/;\n\nexport function isValidVersionStr(version: string): boolean {\n\tversion = version.trim();\n\treturn (version === '*' || VERSION_REGEXP.test(version));\n}\n\nexport function parseVersion(version: string): IParsedVersion | null {\n\tif (!isValidVersionStr(version)) {\n\t\treturn null;\n\t}\n\n\tversion = version.trim();\n\n\tif (version === '*') {\n\t\treturn {\n\t\t\thasCaret: false,\n\t\t\thasGreaterEquals: false,\n\t\t\tmajorBase: 0,\n\t\t\tmajorMustEqual: false,\n\t\t\tminorBase: 0,\n\t\t\tminorMustEqual: false,\n\t\t\tpatchBase: 0,\n\t\t\tpatchMustEqual: false,\n\t\t\tpreRelease: null\n\t\t};\n\t}\n\n\tlet m = version.match(VERSION_REGEXP);\n\tif (!m) {\n\t\treturn null;\n\t}\n\treturn {\n\t\thasCaret: m[1] === '^',\n\t\thasGreaterEquals: m[1] === '>=',\n\t\tmajorBase: m[2] === 'x' ? 0 : parseInt(m[2], 10),\n\t\tmajorMustEqual: (m[2] === 'x' ? false : true),\n\t\tminorBase: m[4] === 'x' ? 0 : parseInt(m[4], 10),\n\t\tminorMustEqual: (m[4] === 'x' ? false : true),\n\t\tpatchBase: m[6] === 'x' ? 0 : parseInt(m[6], 10),\n\t\tpatchMustEqual: (m[6] === 'x' ? false : true),\n\t\tpreRelease: m[8] || null\n\t};\n}\n\nexport function normalizeVersion(version: IParsedVersion | null): INormalizedVersion | null {\n\tif (!version) {\n\t\treturn null;\n\t}\n\n\tlet majorBase = version.majorBase,\n\t\tmajorMustEqual = version.majorMustEqual,\n\t\tminorBase = version.minorBase,\n\t\tminorMustEqual = version.minorMustEqual,\n\t\tpatchBase = version.patchBase,\n\t\tpatchMustEqual = version.patchMustEqual;\n\n\tif (version.hasCaret) {\n\t\tif (majorBase === 0) {\n\t\t\tpatchMustEqual = false;\n\t\t} else {\n\t\t\tminorMustEqual = false;\n\t\t\tpatchMustEqual = false;\n\t\t}\n\t}\n\n\treturn {\n\t\tmajorBase: majorBase,\n\t\tmajorMustEqual: majorMustEqual,\n\t\tminorBase: minorBase,\n\t\tminorMustEqual: minorMustEqual,\n\t\tpatchBase: patchBase,\n\t\tpatchMustEqual: patchMustEqual,\n\t\tisMinimum: version.hasGreaterEquals\n\t};\n}\n\nexport function isValidVersion(_version: string | INormalizedVersion, _desiredVersion: string | INormalizedVersion): boolean {\n\tlet version: INormalizedVersion | null;\n\tif (typeof _version === 'string') {\n\t\tversion = normalizeVersion(parseVersion(_version));\n\t} else {\n\t\tversion = _version;\n\t}\n\n\tlet desiredVersion: INormalizedVersion | null;\n\tif (typeof _desiredVersion === 'string') {\n\t\tdesiredVersion = normalizeVersion(parseVersion(_desiredVersion));\n\t} else {\n\t\tdesiredVersion = _desiredVersion;\n\t}\n\n\tif (!version || !desiredVersion) {\n\t\treturn false;\n\t}\n\n\tlet majorBase = version.majorBase;\n\tlet minorBase = version.minorBase;\n\tlet patchBase = version.patchBase;\n\n\tlet desiredMajorBase = desiredVersion.majorBase;\n\tlet desiredMinorBase = desiredVersion.minorBase;\n\tlet desiredPatchBase = desiredVersion.patchBase;\n\n\tlet majorMustEqual = desiredVersion.majorMustEqual;\n\tlet minorMustEqual = desiredVersion.minorMustEqual;\n\tlet patchMustEqual = desiredVersion.patchMustEqual;\n\n\tif (desiredVersion.isMinimum) {\n\t\tif (majorBase > desiredMajorBase) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (majorBase < desiredMajorBase) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (minorBase > desiredMinorBase) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (minorBase < desiredMinorBase) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn patchBase >= desiredPatchBase;\n\t}\n\n\t// Anything < 1.0.0 is compatible with >= 1.0.0, except exact matches\n\tif (majorBase === 1 && desiredMajorBase === 0 && (!majorMustEqual || !minorMustEqual || !patchMustEqual)) {\n\t\tdesiredMajorBase = 1;\n\t\tdesiredMinorBase = 0;\n\t\tdesiredPatchBase = 0;\n\t\tmajorMustEqual = true;\n\t\tminorMustEqual = false;\n\t\tpatchMustEqual = false;\n\t}\n\n\tif (majorBase < desiredMajorBase) {\n\t\t// smaller major version\n\t\treturn false;\n\t}\n\n\tif (majorBase > desiredMajorBase) {\n\t\t// higher major version\n\t\treturn (!majorMustEqual);\n\t}\n\n\t// at this point, majorBase are equal\n\n\tif (minorBase < desiredMinorBase) {\n\t\t// smaller minor version\n\t\treturn false;\n\t}\n\n\tif (minorBase > desiredMinorBase) {\n\t\t// higher minor version\n\t\treturn (!minorMustEqual);\n\t}\n\n\t// at this point, minorBase are equal\n\n\tif (patchBase < desiredPatchBase) {\n\t\t// smaller patch version\n\t\treturn false;\n\t}\n\n\tif (patchBase > desiredPatchBase) {\n\t\t// higher patch version\n\t\treturn (!patchMustEqual);\n\t}\n\n\t// at this point, patchBase are equal\n\treturn true;\n}\n\nexport interface IReducedExtensionDescription {\n\tisBuiltin: boolean;\n\tengines: {\n\t\tvscode: string;\n\t};\n\tmain?: string;\n}\n\nexport function isValidExtensionVersion(version: string, extensionDesc: IReducedExtensionDescription, notices: string[]): boolean {\n\n\tif (extensionDesc.isBuiltin || typeof extensionDesc.main === 'undefined') {\n\t\t// No version check for builtin or declarative extensions\n\t\treturn true;\n\t}\n\n\treturn isVersionValid(version, extensionDesc.engines.vscode, notices);\n}\n\nexport function isEngineValid(engine: string, version: string): boolean {\n\t// TODO@joao: discuss with alex '*' doesn't seem to be a valid engine version\n\treturn engine === '*' || isVersionValid(version, engine);\n}\n\nexport function isVersionValid(currentVersion: string, requestedVersion: string, notices: string[] = []): boolean {\n\n\tlet desiredVersion = normalizeVersion(parseVersion(requestedVersion));\n\tif (!desiredVersion) {\n\t\tnotices.push(nls.localize('versionSyntax', \"Could not parse `engines.vscode` value {0}. Please use, for example: ^1.22.0, ^1.22.x, etc.\", requestedVersion));\n\t\treturn false;\n\t}\n\n\t// enforce that a breaking API version is specified.\n\t// for 0.X.Y, that means up to 0.X must be specified\n\t// otherwise for Z.X.Y, that means Z must be specified\n\tif (desiredVersion.majorBase === 0) {\n\t\t// force that major and minor must be specific\n\t\tif (!desiredVersion.majorMustEqual || !desiredVersion.minorMustEqual) {\n\t\t\tnotices.push(nls.localize('versionSpecificity1', \"Version specified in `engines.vscode` ({0}) is not specific enough. For vscode versions before 1.0.0, please define at a minimum the major and minor desired version. E.g. ^0.10.0, 0.10.x, 0.11.0, etc.\", requestedVersion));\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// force that major must be specific\n\t\tif (!desiredVersion.majorMustEqual) {\n\t\t\tnotices.push(nls.localize('versionSpecificity2', \"Version specified in `engines.vscode` ({0}) is not specific enough. For vscode versions after 1.0.0, please define at a minimum the major desired version. E.g. ^1.10.0, 1.10.x, 1.x.x, 2.x.x, etc.\", requestedVersion));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!isValidVersion(currentVersion, desiredVersion)) {\n\t\tnotices.push(nls.localize('versionMismatch', \"Extension is not compatible with Code {0}. Extension requires: {1}.\", currentVersion, requestedVersion));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ProxyChannel, getNextTickChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { Client } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { IDiskFileChange, ILogMessage } from 'vs/platform/files/node/watcher/watcher';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IWatcherRequest, IWatcherService } from 'vs/platform/files/node/watcher/nsfw/watcher';\nimport { FileAccess } from 'vs/base/common/network';\n\nexport class FileWatcher extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate service: IWatcherService | undefined;\n\tprivate isDisposed: boolean;\n\tprivate restartCounter: number;\n\n\tconstructor(\n\t\tprivate folders: IWatcherRequest[],\n\t\tprivate onDidFilesChange: (changes: IDiskFileChange[]) => void,\n\t\tprivate onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t) {\n\t\tsuper();\n\n\t\tthis.isDisposed = false;\n\t\tthis.restartCounter = 0;\n\n\t\tthis.startWatching();\n\t}\n\n\tprivate startWatching(): void {\n\t\tconst client = this._register(new Client(\n\t\t\tFileAccess.asFileUri('bootstrap-fork', require).fsPath,\n\t\t\t{\n\t\t\t\tserverName: 'File Watcher (nsfw)',\n\t\t\t\targs: ['--type=watcherService'],\n\t\t\t\tenv: {\n\t\t\t\t\tVSCODE_AMD_ENTRYPOINT: 'vs/platform/files/node/watcher/nsfw/watcherApp',\n\t\t\t\t\tVSCODE_PIPE_LOGGING: 'true',\n\t\t\t\t\tVSCODE_VERBOSE_LOGGING: 'true' // transmit console logs from server to client\n\t\t\t\t}\n\t\t\t}\n\t\t));\n\n\t\tthis._register(client.onDidProcessExit(() => {\n\t\t\t// our watcher app should never be completed because it keeps on watching. being in here indicates\n\t\t\t// that the watcher process died and we want to restart it here. we only do it a max number of times\n\t\t\tif (!this.isDisposed) {\n\t\t\t\tif (this.restartCounter <= FileWatcher.MAX_RESTARTS) {\n\t\t\t\t\tthis.error('terminated unexpectedly and is restarted again...');\n\t\t\t\t\tthis.restartCounter++;\n\t\t\t\t\tthis.startWatching();\n\t\t\t\t} else {\n\t\t\t\t\tthis.error('failed to start after retrying for some time, giving up. Please report this as a bug report!');\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\t// Initialize watcher\n\t\tthis.service = ProxyChannel.toService<IWatcherService>(getNextTickChannel(client.getChannel('watcher')));\n\n\t\tthis.service.setVerboseLogging(this.verboseLogging);\n\n\t\tthis._register(this.service.onDidChangeFile(e => !this.isDisposed && this.onDidFilesChange(e)));\n\t\tthis._register(this.service.onDidLogMessage(m => this.onLogMessage(m)));\n\n\t\t// Start watching\n\t\tthis.setFolders(this.folders);\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t\tif (!this.isDisposed && this.service) {\n\t\t\tthis.service.setVerboseLogging(verboseLogging);\n\t\t}\n\t}\n\n\terror(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (nsfw)] ${message}` });\n\t}\n\n\tsetFolders(folders: IWatcherRequest[]): void {\n\t\tthis.folders = folders;\n\n\t\tif (this.service) {\n\t\t\tthis.service.setRoots(folders);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.isDisposed = true;\n\n\t\tsuper.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ProxyChannel, getNextTickChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { Client } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { IDiskFileChange, ILogMessage } from 'vs/platform/files/node/watcher/watcher';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IWatcherRequest, IWatcherOptions, IWatcherService } from 'vs/platform/files/node/watcher/unix/watcher';\nimport { FileAccess } from 'vs/base/common/network';\n\nexport class FileWatcher extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate isDisposed: boolean;\n\tprivate restartCounter: number;\n\tprivate service: IWatcherService | undefined;\n\n\tconstructor(\n\t\tprivate folders: IWatcherRequest[],\n\t\tprivate onDidFilesChange: (changes: IDiskFileChange[]) => void,\n\t\tprivate onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate watcherOptions: IWatcherOptions = {}\n\t) {\n\t\tsuper();\n\n\t\tthis.isDisposed = false;\n\t\tthis.restartCounter = 0;\n\n\t\tthis.startWatching();\n\t}\n\n\tprivate startWatching(): void {\n\t\tconst client = this._register(new Client(\n\t\t\tFileAccess.asFileUri('bootstrap-fork', require).fsPath,\n\t\t\t{\n\t\t\t\tserverName: 'File Watcher (chokidar)',\n\t\t\t\targs: ['--type=watcherService'],\n\t\t\t\tenv: {\n\t\t\t\t\tVSCODE_AMD_ENTRYPOINT: 'vs/platform/files/node/watcher/unix/watcherApp',\n\t\t\t\t\tVSCODE_PIPE_LOGGING: 'true',\n\t\t\t\t\tVSCODE_VERBOSE_LOGGING: 'true' // transmit console logs from server to client\n\t\t\t\t}\n\t\t\t}\n\t\t));\n\n\t\tthis._register(client.onDidProcessExit(() => {\n\t\t\t// our watcher app should never be completed because it keeps on watching. being in here indicates\n\t\t\t// that the watcher process died and we want to restart it here. we only do it a max number of times\n\t\t\tif (!this.isDisposed) {\n\t\t\t\tif (this.restartCounter <= FileWatcher.MAX_RESTARTS) {\n\t\t\t\t\tthis.error('terminated unexpectedly and is restarted again...');\n\t\t\t\t\tthis.restartCounter++;\n\t\t\t\t\tthis.startWatching();\n\t\t\t\t} else {\n\t\t\t\t\tthis.error('failed to start after retrying for some time, giving up. Please report this as a bug report!');\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\t// Initialize watcher\n\t\tthis.service = ProxyChannel.toService<IWatcherService>(getNextTickChannel(client.getChannel('watcher')));\n\t\tthis.service.init({ ...this.watcherOptions, verboseLogging: this.verboseLogging });\n\n\t\tthis._register(this.service.onDidChangeFile(e => !this.isDisposed && this.onDidFilesChange(e)));\n\t\tthis._register(this.service.onDidLogMessage(m => this.onLogMessage(m)));\n\n\t\t// Start watching\n\t\tthis.service.setRoots(this.folders);\n\t}\n\n\terror(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (chokidar)] ${message}` });\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tif (this.service) {\n\t\t\tthis.service.setVerboseLogging(verboseLogging);\n\t\t}\n\t}\n\n\tsetFolders(folders: IWatcherRequest[]): void {\n\t\tthis.folders = folders;\n\n\t\tif (this.service) {\n\t\t\tthis.service.setRoots(folders);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.isDisposed = true;\n\n\t\tsuper.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { FileChangeType } from 'vs/platform/files/common/files';\nimport * as decoder from 'vs/base/node/decoder';\nimport * as glob from 'vs/base/common/glob';\nimport { IDiskFileChange, ILogMessage } from 'vs/platform/files/node/watcher/watcher';\nimport { FileAccess } from 'vs/base/common/network';\n\nexport class OutOfProcessWin32FolderWatcher {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate static changeTypeMap: FileChangeType[] = [FileChangeType.UPDATED, FileChangeType.ADDED, FileChangeType.DELETED];\n\n\tprivate ignored: glob.ParsedPattern[];\n\n\tprivate handle: cp.ChildProcess | undefined;\n\tprivate restartCounter: number;\n\n\tconstructor(\n\t\tprivate watchedFolder: string,\n\t\tignored: string[],\n\t\tprivate eventCallback: (events: IDiskFileChange[]) => void,\n\t\tprivate logCallback: (message: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean\n\t) {\n\t\tthis.restartCounter = 0;\n\n\t\tif (Array.isArray(ignored)) {\n\t\t\tthis.ignored = ignored.map(i => glob.parse(i));\n\t\t} else {\n\t\t\tthis.ignored = [];\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.log(`Start watching: ${watchedFolder}`);\n\t\t}\n\n\t\tthis.startWatcher();\n\t}\n\n\tprivate startWatcher(): void {\n\t\tconst args = [this.watchedFolder];\n\t\tif (this.verboseLogging) {\n\t\t\targs.push('-verbose');\n\t\t}\n\n\t\tthis.handle = cp.spawn(FileAccess.asFileUri('vs/platform/files/node/watcher/win32/CodeHelper.exe', require).fsPath, args);\n\n\t\tconst stdoutLineDecoder = new decoder.LineDecoder();\n\n\t\t// Events over stdout\n\t\tthis.handle.stdout!.on('data', (data: Buffer) => {\n\n\t\t\t// Collect raw events from output\n\t\t\tconst rawEvents: IDiskFileChange[] = [];\n\t\t\tstdoutLineDecoder.write(data).forEach((line) => {\n\t\t\t\tconst eventParts = line.split('|');\n\t\t\t\tif (eventParts.length === 2) {\n\t\t\t\t\tconst changeType = Number(eventParts[0]);\n\t\t\t\t\tconst absolutePath = eventParts[1];\n\n\t\t\t\t\t// File Change Event (0 Changed, 1 Created, 2 Deleted)\n\t\t\t\t\tif (changeType >= 0 && changeType < 3) {\n\n\t\t\t\t\t\t// Support ignores\n\t\t\t\t\t\tif (this.ignored && this.ignored.some(ignore => ignore(absolutePath))) {\n\t\t\t\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\t\t\t\tthis.log(absolutePath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise record as event\n\t\t\t\t\t\trawEvents.push({\n\t\t\t\t\t\t\ttype: OutOfProcessWin32FolderWatcher.changeTypeMap[changeType],\n\t\t\t\t\t\t\tpath: absolutePath\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// 3 Logging\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.log(eventParts[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Trigger processing of events through the delayer to batch them up properly\n\t\t\tif (rawEvents.length > 0) {\n\t\t\t\tthis.eventCallback(rawEvents);\n\t\t\t}\n\t\t});\n\n\t\t// Errors\n\t\tthis.handle.on('error', (error: Error) => this.onError(error));\n\t\tthis.handle.stderr!.on('data', (data: Buffer) => this.onError(data));\n\n\t\t// Exit\n\t\tthis.handle.on('exit', (code: number, signal: string) => this.onExit(code, signal));\n\t}\n\n\tprivate onError(error: Error | Buffer): void {\n\t\tthis.error('process error: ' + error.toString());\n\t}\n\n\tprivate onExit(code: number, signal: string): void {\n\t\tif (this.handle) { // exit while not yet being disposed is unexpected!\n\t\t\tthis.error(`terminated unexpectedly (code: ${code}, signal: ${signal})`);\n\n\t\t\tif (this.restartCounter <= OutOfProcessWin32FolderWatcher.MAX_RESTARTS) {\n\t\t\t\tthis.error('is restarted again...');\n\t\t\t\tthis.restartCounter++;\n\t\t\t\tthis.startWatcher(); // restart\n\t\t\t} else {\n\t\t\t\tthis.error('Watcher failed to start after retrying for some time, giving up. Please report this as a bug report!');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.logCallback({ type: 'error', message: `[File Watcher (C#)] ${message}` });\n\t}\n\n\tprivate log(message: string) {\n\t\tthis.logCallback({ type: 'trace', message: `[File Watcher (C#)] ${message}` });\n\t}\n\n\tdispose(): void {\n\t\tif (this.handle) {\n\t\t\tthis.handle.kill();\n\t\t\tthis.handle = undefined;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiskFileChange, ILogMessage } from 'vs/platform/files/node/watcher/watcher';\nimport { OutOfProcessWin32FolderWatcher } from 'vs/platform/files/node/watcher/win32/csharpWatcherService';\nimport { posix } from 'vs/base/common/path';\nimport { rtrim } from 'vs/base/common/strings';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport class FileWatcher implements IDisposable {\n\n\tprivate folder: { path: string, excludes: string[] };\n\tprivate service: OutOfProcessWin32FolderWatcher | undefined = undefined;\n\n\tconstructor(\n\t\tfolders: { path: string, excludes: string[] }[],\n\t\tprivate onDidFilesChange: (changes: IDiskFileChange[]) => void,\n\t\tprivate onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean\n\t) {\n\t\tthis.folder = folders[0];\n\n\t\tif (this.folder.path.indexOf('\\\\\\\\') === 0 && this.folder.path.endsWith(posix.sep)) {\n\t\t\t// for some weird reason, node adds a trailing slash to UNC paths\n\t\t\t// we never ever want trailing slashes as our base path unless\n\t\t\t// someone opens root (\"/\").\n\t\t\t// See also https://github.com/nodejs/io.js/issues/1765\n\t\t\tthis.folder.path = rtrim(this.folder.path, posix.sep);\n\t\t}\n\n\t\tthis.service = this.startWatching();\n\t}\n\n\tprivate get isDisposed(): boolean {\n\t\treturn !this.service;\n\t}\n\n\tprivate startWatching(): OutOfProcessWin32FolderWatcher {\n\t\treturn new OutOfProcessWin32FolderWatcher(\n\t\t\tthis.folder.path,\n\t\t\tthis.folder.excludes,\n\t\t\tevents => this.onFileEvents(events),\n\t\t\tmessage => this.onLogMessage(message),\n\t\t\tthis.verboseLogging\n\t\t);\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t\tif (this.service) {\n\t\t\tthis.service.dispose();\n\t\t\tthis.service = this.startWatching();\n\t\t}\n\t}\n\n\tprivate onFileEvents(events: IDiskFileChange[]): void {\n\t\tif (this.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Emit through event emitter\n\t\tif (events.length > 0) {\n\t\t\tthis.onDidFilesChange(events);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this.service) {\n\t\t\tthis.service.dispose();\n\t\t\tthis.service = undefined;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as instantiation from './instantiation';\n\nexport class SyncDescriptor<T> {\n\n\treadonly ctor: any;\n\treadonly staticArguments: any[];\n\treadonly supportsDelayedInstantiation: boolean;\n\n\tconstructor(ctor: new (...args: any[]) => T, staticArguments: any[] = [], supportsDelayedInstantiation: boolean = false) {\n\t\tthis.ctor = ctor;\n\t\tthis.staticArguments = staticArguments;\n\t\tthis.supportsDelayedInstantiation = supportsDelayedInstantiation;\n\t}\n}\n\nexport interface CreateSyncFunc {\n\n\t<T>(ctor: instantiation.IConstructorSignature0<T>): SyncDescriptor0<T>;\n\n\t<A1, T>(ctor: instantiation.IConstructorSignature1<A1, T>): SyncDescriptor1<A1, T>;\n\t<A1, T>(ctor: instantiation.IConstructorSignature1<A1, T>, a1: A1): SyncDescriptor0<T>;\n\n\t<A1, A2, T>(ctor: instantiation.IConstructorSignature2<A1, A2, T>): SyncDescriptor2<A1, A2, T>;\n\t<A1, A2, T>(ctor: instantiation.IConstructorSignature2<A1, A2, T>, a1: A1): SyncDescriptor1<A2, T>;\n\t<A1, A2, T>(ctor: instantiation.IConstructorSignature2<A1, A2, T>, a1: A1, a2: A2): SyncDescriptor0<T>;\n\n\t<A1, A2, A3, T>(ctor: instantiation.IConstructorSignature3<A1, A2, A3, T>): SyncDescriptor3<A1, A2, A3, T>;\n\t<A1, A2, A3, T>(ctor: instantiation.IConstructorSignature3<A1, A2, A3, T>, a1: A1): SyncDescriptor2<A2, A3, T>;\n\t<A1, A2, A3, T>(ctor: instantiation.IConstructorSignature3<A1, A2, A3, T>, a1: A1, a2: A2): SyncDescriptor1<A3, T>;\n\t<A1, A2, A3, T>(ctor: instantiation.IConstructorSignature3<A1, A2, A3, T>, a1: A1, a2: A2, a3: A3): SyncDescriptor0<T>;\n\n\t<A1, A2, A3, A4, T>(ctor: instantiation.IConstructorSignature4<A1, A2, A3, A4, T>): SyncDescriptor4<A1, A2, A3, A4, T>;\n\t<A1, A2, A3, A4, T>(ctor: instantiation.IConstructorSignature4<A1, A2, A3, A4, T>, a1: A1): SyncDescriptor3<A2, A3, A4, T>;\n\t<A1, A2, A3, A4, T>(ctor: instantiation.IConstructorSignature4<A1, A2, A3, A4, T>, a1: A1, a2: A2): SyncDescriptor2<A3, A4, T>;\n\t<A1, A2, A3, A4, T>(ctor: instantiation.IConstructorSignature4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3): SyncDescriptor1<A4, T>;\n\t<A1, A2, A3, A4, T>(ctor: instantiation.IConstructorSignature4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor0<T>;\n\n\t<A1, A2, A3, A4, A5, T>(ctor: instantiation.IConstructorSignature5<A1, A2, A3, A4, A5, T>): SyncDescriptor5<A1, A2, A3, A4, A5, T>;\n\t<A1, A2, A3, A4, A5, T>(ctor: instantiation.IConstructorSignature5<A1, A2, A3, A4, A5, T>, a1: A1): SyncDescriptor4<A2, A3, A4, A5, T>;\n\t<A1, A2, A3, A4, A5, T>(ctor: instantiation.IConstructorSignature5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2): SyncDescriptor3<A3, A4, A5, T>;\n\t<A1, A2, A3, A4, A5, T>(ctor: instantiation.IConstructorSignature5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3): SyncDescriptor2<A4, A5, T>;\n\t<A1, A2, A3, A4, A5, T>(ctor: instantiation.IConstructorSignature5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor1<A5, T>;\n\t<A1, A2, A3, A4, A5, T>(ctor: instantiation.IConstructorSignature5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor0<T>;\n\n\t<A1, A2, A3, A4, A5, A6, T>(ctor: instantiation.IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>): SyncDescriptor6<A1, A2, A3, A4, A5, A6, T>;\n\t<A1, A2, A3, A4, A5, A6, T>(ctor: instantiation.IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, a1: A1): SyncDescriptor5<A2, A3, A4, A5, A6, T>;\n\t<A1, A2, A3, A4, A5, A6, T>(ctor: instantiation.IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2): SyncDescriptor4<A3, A4, A5, A6, T>;\n\t<A1, A2, A3, A4, A5, A6, T>(ctor: instantiation.IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3): SyncDescriptor3<A4, A5, A6, T>;\n\t<A1, A2, A3, A4, A5, A6, T>(ctor: instantiation.IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor2<A5, A6, T>;\n\t<A1, A2, A3, A4, A5, A6, T>(ctor: instantiation.IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor1<A6, T>;\n\t<A1, A2, A3, A4, A5, A6, T>(ctor: instantiation.IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): SyncDescriptor0<T>;\n\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>): SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1): SyncDescriptor6<A2, A3, A4, A5, A6, A7, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2): SyncDescriptor5<A3, A4, A5, A6, A7, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3): SyncDescriptor4<A4, A5, A6, A7, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor3<A5, A6, A7, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor2<A6, A7, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): SyncDescriptor1<A7, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, T>(ctor: instantiation.IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): SyncDescriptor0<T>;\n\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>): SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1): SyncDescriptor7<A2, A3, A4, A5, A6, A7, A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2): SyncDescriptor6<A3, A4, A5, A6, A7, A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3): SyncDescriptor5<A4, A5, A6, A7, A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor4<A5, A6, A7, A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor3<A6, A7, A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): SyncDescriptor2<A7, A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): SyncDescriptor1<A8, T>;\n\t<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: instantiation.IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): SyncDescriptor0<T>;\n}\nexport const createSyncDescriptor: CreateSyncFunc = <T>(ctor: any, ...staticArguments: any[]): any => {\n\treturn new SyncDescriptor<T>(ctor, staticArguments);\n};\n\nexport interface SyncDescriptor0<T> {\n\tctor: any;\n\tbind(): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor1<A1, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor2<A1, A2, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor1<A2, T>;\n\tbind(a1: A1, a2: A2): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor3<A1, A2, A3, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor2<A2, A3, T>;\n\tbind(a1: A1, a2: A2): SyncDescriptor1<A3, T>;\n\tbind(a1: A1, a2: A2, a3: A3): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor4<A1, A2, A3, A4, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor3<A2, A3, A4, T>;\n\tbind(a1: A1, a2: A2): SyncDescriptor2<A3, A4, T>;\n\tbind(a1: A1, a2: A2, a3: A3): SyncDescriptor1<A4, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor5<A1, A2, A3, A4, A5, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor4<A2, A3, A4, A5, T>;\n\tbind(a1: A1, a2: A2): SyncDescriptor3<A3, A4, A5, T>;\n\tbind(a1: A1, a2: A2, a3: A3): SyncDescriptor2<A4, A5, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor1<A5, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor6<A1, A2, A3, A4, A5, A6, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor5<A2, A3, A4, A5, A6, T>;\n\tbind(a1: A1, a2: A2): SyncDescriptor4<A3, A4, A5, A6, T>;\n\tbind(a1: A1, a2: A2, a3: A3): SyncDescriptor3<A4, A5, A6, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor2<A5, A6, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor1<A6, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor6<A2, A3, A4, A5, A6, A7, T>;\n\tbind(a1: A1, a2: A2): SyncDescriptor5<A3, A4, A5, A6, A7, T>;\n\tbind(a1: A1, a2: A2, a3: A3): SyncDescriptor4<A4, A5, A6, A7, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor3<A5, A6, A7, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor2<A6, A7, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): SyncDescriptor1<A7, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): SyncDescriptor0<T>;\n}\nexport interface SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\tctor: any;\n\tbind(a1: A1): SyncDescriptor7<A2, A3, A4, A5, A6, A7, A8, T>;\n\tbind(a1: A1, a2: A2): SyncDescriptor6<A3, A4, A5, A6, A7, A8, T>;\n\tbind(a1: A1, a2: A2, a3: A3): SyncDescriptor5<A4, A5, A6, A7, A8, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4): SyncDescriptor4<A5, A6, A7, A8, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): SyncDescriptor3<A6, A7, A8, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): SyncDescriptor2<A7, A8, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): SyncDescriptor1<A8, T>;\n\tbind(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): SyncDescriptor0<T>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport class Node<T> {\n\n\treadonly data: T;\n\treadonly incoming = new Map<string, Node<T>>();\n\treadonly outgoing = new Map<string, Node<T>>();\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t}\n}\n\nexport class Graph<T> {\n\n\tprivate readonly _nodes = new Map<string, Node<T>>();\n\n\tconstructor(private readonly _hashFn: (element: T) => string) {\n\t\t// empty\n\t}\n\n\troots(): Node<T>[] {\n\t\tconst ret: Node<T>[] = [];\n\t\tfor (let node of this._nodes.values()) {\n\t\t\tif (node.outgoing.size === 0) {\n\t\t\t\tret.push(node);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tinsertEdge(from: T, to: T): void {\n\t\tconst fromNode = this.lookupOrInsertNode(from);\n\t\tconst toNode = this.lookupOrInsertNode(to);\n\n\t\tfromNode.outgoing.set(this._hashFn(to), toNode);\n\t\ttoNode.incoming.set(this._hashFn(from), fromNode);\n\t}\n\n\tremoveNode(data: T): void {\n\t\tconst key = this._hashFn(data);\n\t\tthis._nodes.delete(key);\n\t\tfor (let node of this._nodes.values()) {\n\t\t\tnode.outgoing.delete(key);\n\t\t\tnode.incoming.delete(key);\n\t\t}\n\t}\n\n\tlookupOrInsertNode(data: T): Node<T> {\n\t\tconst key = this._hashFn(data);\n\t\tlet node = this._nodes.get(key);\n\n\t\tif (!node) {\n\t\t\tnode = new Node(data);\n\t\t\tthis._nodes.set(key, node);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tlookup(data: T): Node<T> | undefined {\n\t\treturn this._nodes.get(this._hashFn(data));\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._nodes.size === 0;\n\t}\n\n\ttoString(): string {\n\t\tlet data: string[] = [];\n\t\tfor (let [key, value] of this._nodes) {\n\t\t\tdata.push(`${key}, (incoming)[${[...value.incoming.keys()].join(', ')}], (outgoing)[${[...value.outgoing.keys()].join(',')}]`);\n\n\t\t}\n\t\treturn data.join('\\n');\n\t}\n\n\t/**\n\t * This is brute force and slow and **only** be used\n\t * to trouble shoot.\n\t */\n\tfindCycleSlow() {\n\t\tfor (let [id, node] of this._nodes) {\n\t\t\tconst seen = new Set<string>([id]);\n\t\t\tconst res = this._findCycle(node, seen);\n\t\t\tif (res) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _findCycle(node: Node<T>, seen: Set<string>): string | undefined {\n\t\tfor (let [id, outgoing] of node.outgoing) {\n\t\t\tif (seen.has(id)) {\n\t\t\t\treturn [...seen, id].join(' -> ');\n\t\t\t}\n\t\t\tseen.add(id);\n\t\t\tconst value = this._findCycle(outgoing, seen);\n\t\t\tif (value) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tseen.delete(id);\n\t\t}\n\t\treturn undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { CancellationToken } from 'vs/base/common/cancellation';\n\nexport const IDownloadService = createDecorator<IDownloadService>('downloadService');\n\nexport interface IDownloadService {\n\n\treadonly _serviceBrand: undefined;\n\n\tdownload(uri: URI, to: URI, cancellationToken?: CancellationToken): Promise<void>;\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator, refineServiceDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { URI } from 'vs/base/common/uri';\nimport { NativeParsedArgs } from 'vs/platform/environment/common/argv';\nimport { ExtensionKind } from 'vs/platform/extensions/common/extensions';\n\nexport const IEnvironmentService = createDecorator<IEnvironmentService>('environmentService');\nexport const INativeEnvironmentService = refineServiceDecorator<IEnvironmentService, INativeEnvironmentService>(IEnvironmentService);\n\nexport interface IDebugParams {\n\tport: number | null;\n\tbreak: boolean;\n}\n\nexport interface IExtensionHostDebugParams extends IDebugParams {\n\tdebugId?: string;\n}\n\n/**\n * A basic environment service that can be used in various processes,\n * such as main, renderer and shared process. Use subclasses of this\n * service for specific environment.\n */\nexport interface IEnvironmentService {\n\n\treadonly _serviceBrand: undefined;\n\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t//\n\t// NOTE: KEEP THIS INTERFACE AS SMALL AS POSSIBLE.\n\t//\n\t// AS SUCH:\n\t//   - PUT NON-WEB PROPERTIES INTO NATIVE ENVIRONMENT SERVICE\n\t//   - PUT WORKBENCH ONLY PROPERTIES INTO WORKBENCH ENVIRONMENT SERVICE\n\t//   - PUT ELECTRON-MAIN ONLY PROPERTIES INTO MAIN ENVIRONMENT SERVICE\n\t//\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t// --- user roaming data\n\tuserRoamingDataHome: URI;\n\tsettingsResource: URI;\n\tkeybindingsResource: URI;\n\tkeyboardLayoutResource: URI;\n\targvResource: URI;\n\tsnippetsHome: URI;\n\n\t// --- data paths\n\tuntitledWorkspacesHome: URI;\n\tglobalStorageHome: URI;\n\tworkspaceStorageHome: URI;\n\n\t// --- settings sync\n\tuserDataSyncHome: URI;\n\tuserDataSyncLogResource: URI;\n\tsync: 'on' | 'off' | undefined;\n\n\t// --- extension development\n\tdebugExtensionHost: IExtensionHostDebugParams;\n\tisExtensionDevelopment: boolean;\n\tdisableExtensions: boolean | string[];\n\textensionDevelopmentLocationURI?: URI[];\n\textensionDevelopmentKind?: ExtensionKind[];\n\textensionTestsLocationURI?: URI;\n\n\t// --- logging\n\tlogsPath: string;\n\tlogLevel?: string;\n\tverbose: boolean;\n\tisBuilt: boolean;\n\n\t// --- telemetry\n\tdisableTelemetry: boolean;\n\ttelemetryLogResource: URI;\n\tserviceMachineIdResource: URI;\n\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t//\n\t// NOTE: KEEP THIS INTERFACE AS SMALL AS POSSIBLE.\n\t//\n\t// AS SUCH:\n\t//   - PUT NON-WEB PROPERTIES INTO NATIVE ENVIRONMENT SERVICE\n\t//   - PUT WORKBENCH ONLY PROPERTIES INTO WORKBENCH ENVIRONMENT SERVICE\n\t//   - PUT ELECTRON-MAIN ONLY PROPERTIES INTO MAIN ENVIRONMENT SERVICE\n\t//\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n}\n\n/**\n * A subclass of the `IEnvironmentService` to be used only in native\n * environments (Windows, Linux, macOS) but not e.g. web.\n */\nexport interface INativeEnvironmentService extends IEnvironmentService {\n\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t//\n\t// NOTE: KEEP THIS INTERFACE AS SMALL AS POSSIBLE.\n\t//\n\t// AS SUCH:\n\t//   - PUT WORKBENCH ONLY PROPERTIES INTO WORKBENCH ENVIRONMENT SERVICE\n\t//   - PUT ELECTRON-MAIN ONLY PROPERTIES INTO MAIN ENVIRONMENT SERVICE\n\t//\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t// --- CLI Arguments\n\targs: NativeParsedArgs;\n\n\t// --- data paths\n\tappRoot: string;\n\tuserHome: URI;\n\tappSettingsHome: URI;\n\ttmpDir: URI;\n\tuserDataPath: string;\n\tmachineSettingsResource: URI;\n\tinstallSourcePath: string;\n\n\t// --- extensions\n\textensionsPath: string;\n\textensionsDownloadPath: string;\n\tbuiltinExtensionsPath: string;\n\n\t// --- smoke test support\n\tdriverHandle?: string;\n\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t//\n\t// NOTE: KEEP THIS INTERFACE AS SMALL AS POSSIBLE.\n\t//\n\t// AS SUCH:\n\t//   - PUT NON-WEB PROPERTIES INTO NATIVE ENVIRONMENT SERVICE\n\t//   - PUT WORKBENCH ONLY PROPERTIES INTO WORKBENCH ENVIRONMENT SERVICE\n\t//   - PUT ELECTRON-MAIN ONLY PROPERTIES INTO MAIN ENVIRONMENT SERVICE\n\t//\n\t// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { Event } from 'vs/base/common/event';\nimport { IPager } from 'vs/base/common/paging';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { URI } from 'vs/base/common/uri';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IExtensionManifest, IExtension, ExtensionType } from 'vs/platform/extensions/common/extensions';\nimport { FileAccess } from 'vs/base/common/network';\n\nexport const EXTENSION_IDENTIFIER_PATTERN = '^([a-z0-9A-Z][a-z0-9-A-Z]*)\\\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$';\nexport const EXTENSION_IDENTIFIER_REGEX = new RegExp(EXTENSION_IDENTIFIER_PATTERN);\n\nexport interface IGalleryExtensionProperties {\n\tdependencies?: string[];\n\textensionPack?: string[];\n\tengine?: string;\n\tlocalizedLanguages?: string[];\n\twebExtension?: boolean;\n}\n\nexport interface IGalleryExtensionAsset {\n\turi: string;\n\tfallbackUri: string;\n}\n\nexport interface IGalleryExtensionAssets {\n\tmanifest: IGalleryExtensionAsset | null;\n\treadme: IGalleryExtensionAsset | null;\n\tchangelog: IGalleryExtensionAsset | null;\n\tlicense: IGalleryExtensionAsset | null;\n\trepository: IGalleryExtensionAsset | null;\n\tdownload: IGalleryExtensionAsset;\n\ticon: IGalleryExtensionAsset;\n\tcoreTranslations: [string, IGalleryExtensionAsset][];\n}\n\nexport function isIExtensionIdentifier(thing: any): thing is IExtensionIdentifier {\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof thing.id === 'string'\n\t\t&& (!thing.uuid || typeof thing.uuid === 'string');\n}\n\n/* __GDPR__FRAGMENT__\n\t\"ExtensionIdentifier\" : {\n\t\t\"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"uuid\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t}\n */\nexport interface IExtensionIdentifier {\n\tid: string;\n\tuuid?: string;\n}\n\nexport interface IExtensionIdentifierWithVersion extends IExtensionIdentifier {\n\tid: string;\n\tuuid?: string;\n\tversion: string;\n}\n\nexport interface IGalleryExtensionIdentifier extends IExtensionIdentifier {\n\tuuid: string;\n}\n\nexport interface IGalleryExtensionVersion {\n\tversion: string;\n\tdate: string;\n}\n\nexport interface IGalleryExtension {\n\tname: string;\n\tidentifier: IGalleryExtensionIdentifier;\n\tversion: string;\n\tdate: string;\n\tdisplayName: string;\n\tpublisherId: string;\n\tpublisher: string;\n\tpublisherDisplayName: string;\n\tdescription: string;\n\tinstallCount: number;\n\trating: number;\n\tratingCount: number;\n\tassetUri: URI;\n\tassetTypes: string[];\n\tassets: IGalleryExtensionAssets;\n\tproperties: IGalleryExtensionProperties;\n\ttelemetryData: any;\n\tpreview: boolean;\n\twebResource?: URI;\n}\n\nexport interface IGalleryMetadata {\n\tid: string;\n\tpublisherId: string;\n\tpublisherDisplayName: string;\n}\n\nexport interface ILocalExtension extends IExtension {\n\tisMachineScoped: boolean;\n\tpublisherId: string | null;\n\tpublisherDisplayName: string | null;\n\tinstalledTimestamp?: number;\n}\n\nexport const enum SortBy {\n\tNoneOrRelevance = 0,\n\tLastUpdatedDate = 1,\n\tTitle = 2,\n\tPublisherName = 3,\n\tInstallCount = 4,\n\tPublishedDate = 5,\n\tAverageRating = 6,\n\tWeightedRating = 12\n}\n\nexport const enum SortOrder {\n\tDefault = 0,\n\tAscending = 1,\n\tDescending = 2\n}\n\nexport interface IQueryOptions {\n\ttext?: string;\n\tids?: string[];\n\tnames?: string[];\n\tpageSize?: number;\n\tsortBy?: SortBy;\n\tsortOrder?: SortOrder;\n\tsource?: string;\n}\n\nexport const enum StatisticType {\n\tUninstall = 'uninstall'\n}\n\nexport interface IReportedExtension {\n\tid: IExtensionIdentifier;\n\tmalicious: boolean;\n}\n\nexport const enum InstallOperation {\n\tNone = 0,\n\tInstall,\n\tUpdate\n}\n\nexport interface ITranslation {\n\tcontents: { [key: string]: {} };\n}\n\nexport const IExtensionGalleryService = createDecorator<IExtensionGalleryService>('extensionGalleryService');\nexport interface IExtensionGalleryService {\n\treadonly _serviceBrand: undefined;\n\tisEnabled(): boolean;\n\tquery(token: CancellationToken): Promise<IPager<IGalleryExtension>>;\n\tquery(options: IQueryOptions, token: CancellationToken): Promise<IPager<IGalleryExtension>>;\n\tgetExtensions(ids: string[], token: CancellationToken): Promise<IGalleryExtension[]>;\n\tdownload(extension: IGalleryExtension, location: URI, operation: InstallOperation): Promise<void>;\n\treportStatistic(publisher: string, name: string, version: string, type: StatisticType): Promise<void>;\n\tgetReadme(extension: IGalleryExtension, token: CancellationToken): Promise<string>;\n\tgetManifest(extension: IGalleryExtension, token: CancellationToken): Promise<IExtensionManifest | null>;\n\tgetChangelog(extension: IGalleryExtension, token: CancellationToken): Promise<string>;\n\tgetCoreTranslation(extension: IGalleryExtension, languageId: string): Promise<ITranslation | null>;\n\tgetAllVersions(extension: IGalleryExtension, compatible: boolean): Promise<IGalleryExtensionVersion[]>;\n\tgetExtensionsReport(): Promise<IReportedExtension[]>;\n\tgetCompatibleExtension(extension: IGalleryExtension): Promise<IGalleryExtension | null>;\n\tgetCompatibleExtension(id: IExtensionIdentifier, version?: string): Promise<IGalleryExtension | null>;\n}\n\nexport interface InstallExtensionEvent {\n\tidentifier: IExtensionIdentifier;\n\tzipPath?: string;\n\tgallery?: IGalleryExtension;\n}\n\nexport interface DidInstallExtensionEvent {\n\tidentifier: IExtensionIdentifier;\n\toperation: InstallOperation;\n\tzipPath?: string;\n\tgallery?: IGalleryExtension;\n\tlocal?: ILocalExtension;\n\terror?: string;\n}\n\nexport interface DidUninstallExtensionEvent {\n\tidentifier: IExtensionIdentifier;\n\terror?: string;\n}\n\nexport const INSTALL_ERROR_NOT_SUPPORTED = 'notsupported';\nexport const INSTALL_ERROR_MALICIOUS = 'malicious';\nexport const INSTALL_ERROR_INCOMPATIBLE = 'incompatible';\n\nexport class ExtensionManagementError extends Error {\n\tconstructor(message: string, readonly code: string) {\n\t\tsuper(message);\n\t}\n}\n\nexport type InstallOptions = { isBuiltin?: boolean, isMachineScoped?: boolean, donotIncludePackAndDependencies?: boolean };\nexport type UninstallOptions = { donotIncludePack?: boolean, donotCheckDependents?: boolean };\n\nexport const IExtensionManagementService = createDecorator<IExtensionManagementService>('extensionManagementService');\nexport interface IExtensionManagementService {\n\treadonly _serviceBrand: undefined;\n\n\tonInstallExtension: Event<InstallExtensionEvent>;\n\tonDidInstallExtension: Event<DidInstallExtensionEvent>;\n\tonUninstallExtension: Event<IExtensionIdentifier>;\n\tonDidUninstallExtension: Event<DidUninstallExtensionEvent>;\n\n\tzip(extension: ILocalExtension): Promise<URI>;\n\tunzip(zipLocation: URI): Promise<IExtensionIdentifier>;\n\tgetManifest(vsix: URI): Promise<IExtensionManifest>;\n\tinstall(vsix: URI, options?: InstallOptions): Promise<ILocalExtension>;\n\tcanInstall(extension: IGalleryExtension): Promise<boolean>;\n\tinstallFromGallery(extension: IGalleryExtension, options?: InstallOptions): Promise<ILocalExtension>;\n\tuninstall(extension: ILocalExtension, options?: UninstallOptions): Promise<void>;\n\treinstallFromGallery(extension: ILocalExtension): Promise<void>;\n\tgetInstalled(type?: ExtensionType): Promise<ILocalExtension[]>;\n\tgetExtensionsReport(): Promise<IReportedExtension[]>;\n\n\tupdateMetadata(local: ILocalExtension, metadata: IGalleryMetadata): Promise<ILocalExtension>;\n\tupdateExtensionScope(local: ILocalExtension, isMachineScoped: boolean): Promise<ILocalExtension>;\n}\n\nexport const DISABLED_EXTENSIONS_STORAGE_PATH = 'extensionsIdentifiers/disabled';\nexport const ENABLED_EXTENSIONS_STORAGE_PATH = 'extensionsIdentifiers/enabled';\nexport const IGlobalExtensionEnablementService = createDecorator<IGlobalExtensionEnablementService>('IGlobalExtensionEnablementService');\n\nexport interface IGlobalExtensionEnablementService {\n\treadonly _serviceBrand: undefined;\n\treadonly onDidChangeEnablement: Event<{ readonly extensions: IExtensionIdentifier[], readonly source?: string }>;\n\n\tgetDisabledExtensions(): IExtensionIdentifier[];\n\tenableExtension(extension: IExtensionIdentifier, source?: string): Promise<boolean>;\n\tdisableExtension(extension: IExtensionIdentifier, source?: string): Promise<boolean>;\n\n}\n\nexport type IConfigBasedExtensionTip = {\n\treadonly extensionId: string,\n\treadonly extensionName: string,\n\treadonly isExtensionPack: boolean,\n\treadonly configName: string,\n\treadonly important: boolean,\n};\n\nexport type IExecutableBasedExtensionTip = {\n\treadonly extensionId: string,\n\treadonly extensionName: string,\n\treadonly isExtensionPack: boolean,\n\treadonly exeName: string,\n\treadonly exeFriendlyName: string,\n\treadonly windowsPath?: string,\n};\n\nexport type IWorkspaceTips = { readonly remoteSet: string[]; readonly recommendations: string[]; };\n\nexport const IExtensionTipsService = createDecorator<IExtensionTipsService>('IExtensionTipsService');\nexport interface IExtensionTipsService {\n\treadonly _serviceBrand: undefined;\n\n\tgetConfigBasedTips(folder: URI): Promise<IConfigBasedExtensionTip[]>;\n\tgetImportantExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]>;\n\tgetOtherExecutableBasedTips(): Promise<IExecutableBasedExtensionTip[]>;\n\tgetAllWorkspacesTips(): Promise<IWorkspaceTips[]>;\n}\n\n\nexport const DefaultIconPath = FileAccess.asBrowserUri('./media/defaultIcon.png', require).toString(true);\nexport const ExtensionsLabel = localize('extensions', \"Extensions\");\nexport const ExtensionsLocalizedLabel = { value: ExtensionsLabel, original: 'Extensions' };\nexport const ExtensionsChannelId = 'extensions';\nexport const PreferencesLabel = localize('preferences', \"Preferences\");\nexport const PreferencesLocalizedLabel = { value: PreferencesLabel, original: 'Preferences' };\n\n\nexport interface CLIOutput {\n\tlog(s: string): void;\n\terror(s: string): void;\n}\n\nexport const IExtensionManagementCLIService = createDecorator<IExtensionManagementCLIService>('IExtensionManagementCLIService');\nexport interface IExtensionManagementCLIService {\n\treadonly _serviceBrand: undefined;\n\n\tlistExtensions(showVersions: boolean, category?: string, output?: CLIOutput): Promise<void>;\n\tinstallExtensions(extensions: (string | URI)[], builtinExtensionIds: string[], isMachineScoped: boolean, force: boolean, output?: CLIOutput): Promise<void>;\n\tuninstallExtensions(extensions: (string | URI)[], force: boolean, output?: CLIOutput): Promise<void>;\n\tlocateExtension(extensions: string[], output?: CLIOutput): Promise<void>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport { ILocalization } from 'vs/platform/localizations/common/localizations';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport const MANIFEST_CACHE_FOLDER = 'CachedExtensions';\nexport const USER_MANIFEST_CACHE_FILE = 'user';\nexport const BUILTIN_MANIFEST_CACHE_FILE = 'builtin';\n\nexport interface ICommand {\n\tcommand: string;\n\ttitle: string;\n\tcategory?: string;\n}\n\nexport interface IConfigurationProperty {\n\tdescription: string;\n\ttype: string | string[];\n\tdefault?: any;\n}\n\nexport interface IConfiguration {\n\tproperties: { [key: string]: IConfigurationProperty; };\n}\n\nexport interface IDebugger {\n\tlabel?: string;\n\ttype: string;\n\truntime?: string;\n}\n\nexport interface IGrammar {\n\tlanguage: string;\n}\n\nexport interface IJSONValidation {\n\tfileMatch: string | string[];\n\turl: string;\n}\n\nexport interface IKeyBinding {\n\tcommand: string;\n\tkey: string;\n\twhen?: string;\n\tmac?: string;\n\tlinux?: string;\n\twin?: string;\n}\n\nexport interface ILanguage {\n\tid: string;\n\textensions: string[];\n\taliases: string[];\n}\n\nexport interface IMenu {\n\tcommand: string;\n\talt?: string;\n\twhen?: string;\n\tgroup?: string;\n}\n\nexport interface ISnippet {\n\tlanguage: string;\n}\n\nexport interface ITheme {\n\tlabel: string;\n}\n\nexport interface IViewContainer {\n\tid: string;\n\ttitle: string;\n}\n\nexport interface IView {\n\tid: string;\n\tname: string;\n}\n\nexport interface IColor {\n\tid: string;\n\tdescription: string;\n\tdefaults: { light: string, dark: string, highContrast: string };\n}\n\nexport interface IWebviewEditor {\n\treadonly viewType: string;\n\treadonly priority: string;\n\treadonly selector: readonly {\n\t\treadonly filenamePattern?: string;\n\t}[];\n}\n\nexport interface ICodeActionContributionAction {\n\treadonly kind: string;\n\treadonly title: string;\n\treadonly description?: string;\n}\n\nexport interface ICodeActionContribution {\n\treadonly languages: readonly string[];\n\treadonly actions: readonly ICodeActionContributionAction[];\n}\n\nexport interface IAuthenticationContribution {\n\treadonly id: string;\n\treadonly label: string;\n}\n\nexport interface IWalkthroughStep {\n\treadonly id: string;\n\treadonly title: string;\n\treadonly description: string;\n\treadonly media:\n\t| { path: string | { dark: string, light: string, hc: string }, altText: string }\n\t| { path: string, },\n\treadonly doneOn?: { command: string };\n\treadonly when?: string;\n}\n\nexport interface IWalkthrough {\n\treadonly id: string,\n\treadonly title: string;\n\treadonly description: string;\n\treadonly steps: IWalkthroughStep[];\n\treadonly primary?: boolean;\n\treadonly when?: string;\n}\n\nexport interface IStartEntry {\n\treadonly title: string;\n\treadonly description: string;\n\treadonly command: string;\n\treadonly type?: 'sample-folder' | 'sample-notebook' | string;\n\treadonly when?: string;\n}\n\nexport interface IExtensionContributions {\n\tcommands?: ICommand[];\n\tconfiguration?: IConfiguration | IConfiguration[];\n\tdebuggers?: IDebugger[];\n\tgrammars?: IGrammar[];\n\tjsonValidation?: IJSONValidation[];\n\tkeybindings?: IKeyBinding[];\n\tlanguages?: ILanguage[];\n\tmenus?: { [context: string]: IMenu[] };\n\tsnippets?: ISnippet[];\n\tthemes?: ITheme[];\n\ticonThemes?: ITheme[];\n\tproductIconThemes?: ITheme[];\n\tviewsContainers?: { [location: string]: IViewContainer[] };\n\tviews?: { [location: string]: IView[] };\n\tcolors?: IColor[];\n\tlocalizations?: ILocalization[];\n\treadonly customEditors?: readonly IWebviewEditor[];\n\treadonly codeActions?: readonly ICodeActionContribution[];\n\tauthentication?: IAuthenticationContribution[];\n\twalkthroughs?: IWalkthrough[];\n\tstartEntries?: IStartEntry[];\n}\n\nexport interface IExtensionCapabilities {\n\treadonly virtualWorkspaces?: boolean;\n\treadonly untrustedWorkspaces?: ExtensionUntrustedWorkspaceSupport;\n}\n\nexport type ExtensionKind = 'ui' | 'workspace' | 'web';\nexport type ExtensionUntrustedWorkpaceSupportType = boolean | 'limited';\nexport type ExtensionUntrustedWorkspaceSupport = { supported: true; } | { supported: false, description: string } | { supported: 'limited', description: string, restrictedConfigurations?: string[] };\n\nexport function isIExtensionIdentifier(thing: any): thing is IExtensionIdentifier {\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof thing.id === 'string'\n\t\t&& (!thing.uuid || typeof thing.uuid === 'string');\n}\n\nexport interface IExtensionIdentifier {\n\tid: string;\n\tuuid?: string;\n}\n\nexport const EXTENSION_CATEGORIES = [\n\t'Azure',\n\t'Data Science',\n\t'Debuggers',\n\t'Extension Packs',\n\t'Education',\n\t'Formatters',\n\t'Keymaps',\n\t'Language Packs',\n\t'Linters',\n\t'Machine Learning',\n\t'Notebooks',\n\t'Programming Languages',\n\t'SCM Providers',\n\t'Snippets',\n\t'Testing',\n\t'Themes',\n\t'Visualization',\n\t'Other',\n];\n\nexport interface IExtensionManifest {\n\treadonly name: string;\n\treadonly displayName?: string;\n\treadonly publisher: string;\n\treadonly version: string;\n\treadonly engines: { readonly vscode: string };\n\treadonly description?: string;\n\treadonly main?: string;\n\treadonly browser?: string;\n\treadonly icon?: string;\n\treadonly categories?: string[];\n\treadonly keywords?: string[];\n\treadonly activationEvents?: string[];\n\treadonly extensionDependencies?: string[];\n\treadonly extensionPack?: string[];\n\treadonly extensionKind?: ExtensionKind | ExtensionKind[];\n\treadonly contributes?: IExtensionContributions;\n\treadonly repository?: { url: string; };\n\treadonly bugs?: { url: string; };\n\treadonly enableProposedApi?: boolean;\n\treadonly api?: string;\n\treadonly scripts?: { [key: string]: string; };\n\treadonly capabilities?: IExtensionCapabilities;\n}\n\nexport const enum ExtensionType {\n\tSystem,\n\tUser\n}\n\nexport interface IExtension {\n\treadonly type: ExtensionType;\n\treadonly isBuiltin: boolean;\n\treadonly identifier: IExtensionIdentifier;\n\treadonly manifest: IExtensionManifest;\n\treadonly location: URI;\n\treadonly readmeUrl?: URI;\n\treadonly changelogUrl?: URI;\n}\n\n/**\n * **!Do not construct directly!**\n *\n * **!Only static methods because it gets serialized!**\n *\n * This represents the \"canonical\" version for an extension identifier. Extension ids\n * have to be case-insensitive (due to the marketplace), but we must ensure case\n * preservation because the extension API is already public at this time.\n *\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\n *\n * To make matters more complicated, an extension can optionally have an UUID. When two\n * extensions have the same UUID, they are considered equal even if their identifier is different.\n */\nexport class ExtensionIdentifier {\n\tpublic readonly value: string;\n\tprivate readonly _lower: string;\n\n\tconstructor(value: string) {\n\t\tthis.value = value;\n\t\tthis._lower = value.toLowerCase();\n\t}\n\n\tpublic static equals(a: ExtensionIdentifier | string | null | undefined, b: ExtensionIdentifier | string | null | undefined) {\n\t\tif (typeof a === 'undefined' || a === null) {\n\t\t\treturn (typeof b === 'undefined' || b === null);\n\t\t}\n\t\tif (typeof b === 'undefined' || b === null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof a === 'string' || typeof b === 'string') {\n\t\t\t// At least one of the arguments is an extension id in string form,\n\t\t\t// so we have to use the string comparison which ignores case.\n\t\t\tlet aValue = (typeof a === 'string' ? a : a.value);\n\t\t\tlet bValue = (typeof b === 'string' ? b : b.value);\n\t\t\treturn strings.equalsIgnoreCase(aValue, bValue);\n\t\t}\n\n\t\t// Now we know both arguments are ExtensionIdentifier\n\t\treturn (a._lower === b._lower);\n\t}\n\n\t/**\n\t * Gives the value by which to index (for equality).\n\t */\n\tpublic static toKey(id: ExtensionIdentifier | string): string {\n\t\tif (typeof id === 'string') {\n\t\t\treturn id.toLowerCase();\n\t\t}\n\t\treturn id._lower;\n\t}\n}\n\nexport interface IExtensionDescription extends IExtensionManifest {\n\treadonly identifier: ExtensionIdentifier;\n\treadonly uuid?: string;\n\treadonly isBuiltin: boolean;\n\treadonly isUserBuiltin: boolean;\n\treadonly isUnderDevelopment: boolean;\n\treadonly extensionLocation: URI;\n\tenableProposedApi?: boolean;\n}\n\nexport function isLanguagePackExtension(manifest: IExtensionManifest): boolean {\n\treturn manifest.contributes && manifest.contributes.localizations ? manifest.contributes.localizations.length > 0 : false;\n}\n\nexport function isAuthenticaionProviderExtension(manifest: IExtensionManifest): boolean {\n\treturn manifest.contributes && manifest.contributes.authentication ? manifest.contributes.authentication.length > 0 : false;\n}\n\nexport interface IScannedExtension {\n\treadonly identifier: IExtensionIdentifier;\n\treadonly location: URI;\n\treadonly type: ExtensionType;\n\treadonly packageJSON: IExtensionManifest;\n\treadonly packageNLS?: any;\n\treadonly packageNLSUrl?: URI;\n\treadonly readmeUrl?: URI;\n\treadonly changelogUrl?: URI;\n\treadonly isUnderDevelopment: boolean;\n}\n\nexport interface ITranslatedScannedExtension {\n\treadonly identifier: IExtensionIdentifier;\n\treadonly location: URI;\n\treadonly type: ExtensionType;\n\treadonly packageJSON: IExtensionManifest;\n\treadonly readmeUrl?: URI;\n\treadonly changelogUrl?: URI;\n\treadonly isUnderDevelopment: boolean;\n}\n\nexport const IBuiltinExtensionsScannerService = createDecorator<IBuiltinExtensionsScannerService>('IBuiltinExtensionsScannerService');\nexport interface IBuiltinExtensionsScannerService {\n\treadonly _serviceBrand: undefined;\n\tscanBuiltinExtensions(): Promise<IScannedExtension[]>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILocalExtension, IGalleryExtension, IExtensionIdentifier, IReportedExtension, IExtensionIdentifierWithVersion } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { compareIgnoreCase } from 'vs/base/common/strings';\nimport { ExtensionIdentifier } from 'vs/platform/extensions/common/extensions';\n\nexport function areSameExtensions(a: IExtensionIdentifier, b: IExtensionIdentifier): boolean {\n\tif (a.uuid && b.uuid) {\n\t\treturn a.uuid === b.uuid;\n\t}\n\tif (a.id === b.id) {\n\t\treturn true;\n\t}\n\treturn compareIgnoreCase(a.id, b.id) === 0;\n}\n\nexport class ExtensionIdentifierWithVersion implements IExtensionIdentifierWithVersion {\n\n\treadonly id: string;\n\treadonly uuid?: string;\n\n\tconstructor(\n\t\tidentifier: IExtensionIdentifier,\n\t\treadonly version: string\n\t) {\n\t\tthis.id = identifier.id;\n\t\tthis.uuid = identifier.uuid;\n\t}\n\n\tkey(): string {\n\t\treturn `${this.id}-${this.version}`;\n\t}\n\n\tequals(o: any): boolean {\n\t\tif (!(o instanceof ExtensionIdentifierWithVersion)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areSameExtensions(this, o) && this.version === o.version;\n\t}\n}\n\nexport function getExtensionId(publisher: string, name: string): string {\n\treturn `${publisher}.${name}`;\n}\n\nexport function adoptToGalleryExtensionId(id: string): string {\n\treturn id.toLocaleLowerCase();\n}\n\nexport function getGalleryExtensionId(publisher: string, name: string): string {\n\treturn adoptToGalleryExtensionId(getExtensionId(publisher, name));\n}\n\nexport function groupByExtension<T>(extensions: T[], getExtensionIdentifier: (t: T) => IExtensionIdentifier): T[][] {\n\tconst byExtension: T[][] = [];\n\tconst findGroup = (extension: T) => {\n\t\tfor (const group of byExtension) {\n\t\t\tif (group.some(e => areSameExtensions(getExtensionIdentifier(e), getExtensionIdentifier(extension)))) {\n\t\t\t\treturn group;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tfor (const extension of extensions) {\n\t\tconst group = findGroup(extension);\n\t\tif (group) {\n\t\t\tgroup.push(extension);\n\t\t} else {\n\t\t\tbyExtension.push([extension]);\n\t\t}\n\t}\n\treturn byExtension;\n}\n\nexport function getLocalExtensionTelemetryData(extension: ILocalExtension): any {\n\treturn {\n\t\tid: extension.identifier.id,\n\t\tname: extension.manifest.name,\n\t\tgalleryId: null,\n\t\tpublisherId: extension.publisherId,\n\t\tpublisherName: extension.manifest.publisher,\n\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\tdependencies: extension.manifest.extensionDependencies && extension.manifest.extensionDependencies.length > 0\n\t};\n}\n\n\n/* __GDPR__FRAGMENT__\n\t\"GalleryExtensionTelemetryData\" : {\n\t\t\"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"name\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"galleryId\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"publisherId\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"publisherName\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"publisherDisplayName\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"dependencies\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"${include}\": [\n\t\t\t\"${GalleryExtensionTelemetryData2}\"\n\t\t]\n\t}\n*/\nexport function getGalleryExtensionTelemetryData(extension: IGalleryExtension): any {\n\treturn {\n\t\tid: extension.identifier.id,\n\t\tname: extension.name,\n\t\tgalleryId: extension.identifier.uuid,\n\t\tpublisherId: extension.publisherId,\n\t\tpublisherName: extension.publisher,\n\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\tdependencies: !!(extension.properties.dependencies && extension.properties.dependencies.length > 0),\n\t\t...extension.telemetryData\n\t};\n}\n\nexport const BetterMergeId = new ExtensionIdentifier('pprice.better-merge');\n\nexport function getMaliciousExtensionsSet(report: IReportedExtension[]): Set<string> {\n\tconst result = new Set<string>();\n\n\tfor (const extension of report) {\n\t\tif (extension.malicious) {\n\t\t\tresult.add(extension.id.id);\n\t\t}\n\t}\n\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\n\nimport { isPromiseCanceledError } from 'vs/base/common/errors';\nimport { URI } from 'vs/base/common/uri';\nimport { gt } from 'vs/base/common/semver/semver';\nimport { CLIOutput, IExtensionGalleryService, IExtensionManagementCLIService, IExtensionManagementService, IGalleryExtension, ILocalExtension, InstallOptions } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { adoptToGalleryExtensionId, areSameExtensions, getGalleryExtensionId } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { ExtensionType, EXTENSION_CATEGORIES, IExtensionManifest } from 'vs/platform/extensions/common/extensions';\nimport { getBaseLabel } from 'vs/base/common/labels';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Schemas } from 'vs/base/common/network';\n\nconst notFound = (id: string) => localize('notFound', \"Extension '{0}' not found.\", id);\nconst useId = localize('useId', \"Make sure you use the full extension ID, including the publisher, e.g.: {0}\", 'ms-dotnettools.csharp');\n\n\nfunction getId(manifest: IExtensionManifest, withVersion?: boolean): string {\n\tif (withVersion) {\n\t\treturn `${manifest.publisher}.${manifest.name}@${manifest.version}`;\n\t} else {\n\t\treturn `${manifest.publisher}.${manifest.name}`;\n\t}\n}\n\nconst EXTENSION_ID_REGEX = /^([^.]+\\..+)@(\\d+\\.\\d+\\.\\d+(-.*)?)$/;\n\nexport function getIdAndVersion(id: string): [string, string | undefined] {\n\tconst matches = EXTENSION_ID_REGEX.exec(id);\n\tif (matches && matches[1]) {\n\t\treturn [adoptToGalleryExtensionId(matches[1]), matches[2]];\n\t}\n\treturn [adoptToGalleryExtensionId(id), undefined];\n}\n\ntype InstallExtensionInfo = { id: string, version?: string, installOptions: InstallOptions };\n\n\nexport class ExtensionManagementCLIService implements IExtensionManagementCLIService {\n\n\t_serviceBrand: any;\n\n\tconstructor(\n\t\t@IExtensionManagementService private readonly extensionManagementService: IExtensionManagementService,\n\t\t@IExtensionGalleryService private readonly extensionGalleryService: IExtensionGalleryService\n\t) { }\n\n\tprotected get location(): string | undefined {\n\t\treturn undefined;\n\t}\n\n\tpublic async listExtensions(showVersions: boolean, category?: string, output: CLIOutput = console): Promise<void> {\n\t\tlet extensions = await this.extensionManagementService.getInstalled(ExtensionType.User);\n\t\tconst categories = EXTENSION_CATEGORIES.map(c => c.toLowerCase());\n\t\tif (category && category !== '') {\n\t\t\tif (categories.indexOf(category.toLowerCase()) < 0) {\n\t\t\t\toutput.log('Invalid category please enter a valid category. To list valid categories run --category without a category specified');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\textensions = extensions.filter(e => {\n\t\t\t\tif (e.manifest.categories) {\n\t\t\t\t\tconst lowerCaseCategories: string[] = e.manifest.categories.map(c => c.toLowerCase());\n\t\t\t\t\treturn lowerCaseCategories.indexOf(category.toLowerCase()) > -1;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t} else if (category === '') {\n\t\t\toutput.log('Possible Categories: ');\n\t\t\tcategories.forEach(category => {\n\t\t\t\toutput.log(category);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (this.location) {\n\t\t\toutput.log(localize('listFromLocation', \"Extensions installed on {0}:\", this.location));\n\t\t}\n\n\t\textensions = extensions.sort((e1, e2) => e1.identifier.id.localeCompare(e2.identifier.id));\n\t\tlet lastId: string | undefined = undefined;\n\t\tfor (let extension of extensions) {\n\t\t\tif (lastId !== extension.identifier.id) {\n\t\t\t\tlastId = extension.identifier.id;\n\t\t\t\toutput.log(getId(extension.manifest, showVersions));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async installExtensions(extensions: (string | URI)[], builtinExtensionIds: string[], isMachineScoped: boolean, force: boolean, output: CLIOutput = console): Promise<void> {\n\t\tconst failed: string[] = [];\n\t\tconst installedExtensionsManifests: IExtensionManifest[] = [];\n\t\tif (extensions.length) {\n\t\t\toutput.log(this.location ? localize('installingExtensionsOnLocation', \"Installing extensions on {0}...\", this.location) : localize('installingExtensions', \"Installing extensions...\"));\n\t\t}\n\n\t\tconst installed = await this.extensionManagementService.getInstalled(ExtensionType.User);\n\t\tconst checkIfNotInstalled = (id: string, version?: string): boolean => {\n\t\t\tconst installedExtension = installed.find(i => areSameExtensions(i.identifier, { id }));\n\t\t\tif (installedExtension) {\n\t\t\t\tif (!version && !force) {\n\t\t\t\t\toutput.log(localize('alreadyInstalled-checkAndUpdate', \"Extension '{0}' v{1} is already installed. Use '--force' option to update to latest version or provide '@<version>' to install a specific version, for example: '{2}@1.2.3'.\", id, installedExtension.manifest.version, id));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (version && installedExtension.manifest.version === version) {\n\t\t\t\t\toutput.log(localize('alreadyInstalled', \"Extension '{0}' is already installed.\", `${id}@${version}`));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tconst vsixs: URI[] = [];\n\t\tconst installExtensionInfos: InstallExtensionInfo[] = [];\n\t\tfor (const extension of extensions) {\n\t\t\tif (extension instanceof URI) {\n\t\t\t\tvsixs.push(extension);\n\t\t\t} else {\n\t\t\t\tconst [id, version] = getIdAndVersion(extension);\n\t\t\t\tif (checkIfNotInstalled(id, version)) {\n\t\t\t\t\tinstallExtensionInfos.push({ id, version, installOptions: { isBuiltin: false, isMachineScoped } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const extension of builtinExtensionIds) {\n\t\t\tconst [id, version] = getIdAndVersion(extension);\n\t\t\tif (checkIfNotInstalled(id, version)) {\n\t\t\t\tinstallExtensionInfos.push({ id, version, installOptions: { isBuiltin: true, isMachineScoped: false } });\n\t\t\t}\n\t\t}\n\n\t\tif (vsixs.length) {\n\t\t\tawait Promise.all(vsixs.map(async vsix => {\n\t\t\t\ttry {\n\t\t\t\t\tconst manifest = await this.installVSIX(vsix, { isBuiltin: false, isMachineScoped }, force, output);\n\t\t\t\t\tif (manifest) {\n\t\t\t\t\t\tinstalledExtensionsManifests.push(manifest);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\toutput.error(err.message || err.stack || err);\n\t\t\t\t\tfailed.push(vsix.toString());\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\tif (installExtensionInfos.length) {\n\n\t\t\tconst galleryExtensions = await this.getGalleryExtensions(installExtensionInfos);\n\n\t\t\tawait Promise.all(installExtensionInfos.map(async extensionInfo => {\n\t\t\t\tconst gallery = galleryExtensions.get(extensionInfo.id.toLowerCase());\n\t\t\t\tif (gallery) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst manifest = await this.installFromGallery(extensionInfo, gallery, installed, force, output);\n\t\t\t\t\t\tif (manifest) {\n\t\t\t\t\t\t\tinstalledExtensionsManifests.push(manifest);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\toutput.error(err.message || err.stack || err);\n\t\t\t\t\t\tfailed.push(extensionInfo.id);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.error(`${notFound(extensionInfo.version ? `${extensionInfo.id}@${extensionInfo.version}` : extensionInfo.id)}\\n${useId}`);\n\t\t\t\t\tfailed.push(extensionInfo.id);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t}\n\n\t\tif (failed.length) {\n\t\t\tthrow new Error(localize('installation failed', \"Failed Installing Extensions: {0}\", failed.join(', ')));\n\t\t}\n\t}\n\n\tprivate async installVSIX(vsix: URI, installOptions: InstallOptions, force: boolean, output: CLIOutput): Promise<IExtensionManifest | null> {\n\n\t\tconst manifest = await this.extensionManagementService.getManifest(vsix);\n\t\tif (!manifest) {\n\t\t\tthrow new Error('Invalid vsix');\n\t\t}\n\n\t\tconst valid = await this.validateVSIX(manifest, force, output);\n\t\tif (valid) {\n\t\t\ttry {\n\t\t\t\tawait this.extensionManagementService.install(vsix, installOptions);\n\t\t\t\toutput.log(localize('successVsixInstall', \"Extension '{0}' was successfully installed.\", getBaseLabel(vsix)));\n\t\t\t\treturn manifest;\n\t\t\t} catch (error) {\n\t\t\t\tif (isPromiseCanceledError(error)) {\n\t\t\t\t\toutput.log(localize('cancelVsixInstall', \"Cancelled installing extension '{0}'.\", getBaseLabel(vsix)));\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate async getGalleryExtensions(extensions: InstallExtensionInfo[]): Promise<Map<string, IGalleryExtension>> {\n\t\tconst extensionIds = extensions.filter(({ version }) => version === undefined).map(({ id }) => id);\n\t\tconst extensionsWithIdAndVersion = extensions.filter(({ version }) => version !== undefined);\n\n\t\tconst galleryExtensions = new Map<string, IGalleryExtension>();\n\t\tawait Promise.all([\n\t\t\t(async () => {\n\t\t\t\tconst result = await this.extensionGalleryService.getExtensions(extensionIds, CancellationToken.None);\n\t\t\t\tresult.forEach(extension => galleryExtensions.set(extension.identifier.id.toLowerCase(), extension));\n\t\t\t})(),\n\t\t\tPromise.all(extensionsWithIdAndVersion.map(async ({ id, version }) => {\n\t\t\t\tconst extension = await this.extensionGalleryService.getCompatibleExtension({ id }, version);\n\t\t\t\tif (extension) {\n\t\t\t\t\tgalleryExtensions.set(extension.identifier.id.toLowerCase(), extension);\n\t\t\t\t}\n\t\t\t}))\n\t\t]);\n\n\t\treturn galleryExtensions;\n\t}\n\n\tprivate async installFromGallery({ id, version, installOptions }: InstallExtensionInfo, galleryExtension: IGalleryExtension, installed: ILocalExtension[], force: boolean, output: CLIOutput): Promise<IExtensionManifest | null> {\n\t\tconst manifest = await this.extensionGalleryService.getManifest(galleryExtension, CancellationToken.None);\n\t\tif (manifest && !this.validateExtensionKind(manifest, output)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst installedExtension = installed.find(e => areSameExtensions(e.identifier, galleryExtension.identifier));\n\t\tif (installedExtension) {\n\t\t\tif (galleryExtension.version === installedExtension.manifest.version) {\n\t\t\t\toutput.log(localize('alreadyInstalled', \"Extension '{0}' is already installed.\", version ? `${id}@${version}` : id));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\toutput.log(localize('updateMessage', \"Updating the extension '{0}' to the version {1}\", id, galleryExtension.version));\n\t\t}\n\n\t\ttry {\n\t\t\tif (installOptions.isBuiltin) {\n\t\t\t\toutput.log(localize('installing builtin ', \"Installing builtin extension '{0}' v{1}...\", id, galleryExtension.version));\n\t\t\t} else {\n\t\t\t\toutput.log(localize('installing', \"Installing extension '{0}' v{1}...\", id, galleryExtension.version));\n\t\t\t}\n\n\t\t\tawait this.extensionManagementService.installFromGallery(galleryExtension, installOptions);\n\t\t\toutput.log(localize('successInstall', \"Extension '{0}' v{1} was successfully installed.\", id, galleryExtension.version));\n\t\t\treturn manifest;\n\t\t} catch (error) {\n\t\t\tif (isPromiseCanceledError(error)) {\n\t\t\t\toutput.log(localize('cancelInstall', \"Cancelled installing extension '{0}'.\", id));\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected validateExtensionKind(_manifest: IExtensionManifest, output: CLIOutput): boolean {\n\t\treturn true;\n\t}\n\n\tprivate async validateVSIX(manifest: IExtensionManifest, force: boolean, output: CLIOutput): Promise<boolean> {\n\t\tconst extensionIdentifier = { id: getGalleryExtensionId(manifest.publisher, manifest.name) };\n\t\tconst installedExtensions = await this.extensionManagementService.getInstalled(ExtensionType.User);\n\t\tconst newer = installedExtensions.find(local => areSameExtensions(extensionIdentifier, local.identifier) && gt(local.manifest.version, manifest.version));\n\n\t\tif (newer && !force) {\n\t\t\toutput.log(localize('forceDowngrade', \"A newer version of extension '{0}' v{1} is already installed. Use '--force' option to downgrade to older version.\", newer.identifier.id, newer.manifest.version, manifest.version));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.validateExtensionKind(manifest, output);\n\t}\n\n\tpublic async uninstallExtensions(extensions: (string | URI)[], force: boolean, output: CLIOutput = console): Promise<void> {\n\t\tconst getExtensionId = async (extensionDescription: string | URI): Promise<string> => {\n\t\t\tif (extensionDescription instanceof URI) {\n\t\t\t\tconst manifest = await this.extensionManagementService.getManifest(extensionDescription);\n\t\t\t\treturn getId(manifest);\n\t\t\t}\n\t\t\treturn extensionDescription;\n\t\t};\n\n\t\tconst uninstalledExtensions: ILocalExtension[] = [];\n\t\tfor (const extension of extensions) {\n\t\t\tconst id = await getExtensionId(extension);\n\t\t\tconst installed = await this.extensionManagementService.getInstalled();\n\t\t\tconst extensionsToUninstall = installed.filter(e => areSameExtensions(e.identifier, { id }));\n\t\t\tif (!extensionsToUninstall.length) {\n\t\t\t\tthrow new Error(`${this.notInstalled(id)}\\n${useId}`);\n\t\t\t}\n\t\t\tif (extensionsToUninstall.some(e => e.type === ExtensionType.System)) {\n\t\t\t\toutput.log(localize('builtin', \"Extension '{0}' is a Built-in extension and cannot be uninstalled\", id));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!force && extensionsToUninstall.some(e => e.isBuiltin)) {\n\t\t\t\toutput.log(localize('forceUninstall', \"Extension '{0}' is marked as a Built-in extension by user. Please use '--force' option to uninstall it.\", id));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toutput.log(localize('uninstalling', \"Uninstalling {0}...\", id));\n\t\t\tfor (const extensionToUninstall of extensionsToUninstall) {\n\t\t\t\tawait this.extensionManagementService.uninstall(extensionToUninstall);\n\t\t\t\tuninstalledExtensions.push(extensionToUninstall);\n\t\t\t}\n\n\t\t\tif (this.location) {\n\t\t\t\toutput.log(localize('successUninstallFromLocation', \"Extension '{0}' was successfully uninstalled from {1}!\", id, this.location));\n\t\t\t} else {\n\t\t\t\toutput.log(localize('successUninstall', \"Extension '{0}' was successfully uninstalled!\", id));\n\t\t\t}\n\n\t\t}\n\t}\n\n\tpublic async locateExtension(extensions: string[], output: CLIOutput = console): Promise<void> {\n\t\tconst installed = await this.extensionManagementService.getInstalled();\n\t\textensions.forEach(e => {\n\t\t\tinstalled.forEach(i => {\n\t\t\t\tif (i.identifier.id === e) {\n\t\t\t\t\tif (i.location.scheme === Schemas.file) {\n\t\t\t\t\t\toutput.log(i.location.fsPath);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate notInstalled(id: string) {\n\t\treturn this.location ? localize('notInstalleddOnLocation', \"Extension '{0}' is not installed on {1}.\", id, this.location) : localize('notInstalled', \"Extension '{0}' is not installed.\", id);\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { join } from 'vs/base/common/path';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IExtensionManagementService, DidInstallExtensionEvent, DidUninstallExtensionEvent } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { MANIFEST_CACHE_FOLDER, USER_MANIFEST_CACHE_FILE } from 'vs/platform/extensions/common/extensions';\nimport * as pfs from 'vs/base/node/pfs';\n\nexport class ExtensionsManifestCache extends Disposable {\n\n\tprivate extensionsManifestCache = join(this.environmentService.userDataPath, MANIFEST_CACHE_FOLDER, USER_MANIFEST_CACHE_FILE);\n\n\tconstructor(\n\t\tprivate readonly environmentService: INativeEnvironmentService,\n\t\textensionsManagementService: IExtensionManagementService\n\t) {\n\t\tsuper();\n\t\tthis._register(extensionsManagementService.onDidInstallExtension(e => this.onDidInstallExtension(e)));\n\t\tthis._register(extensionsManagementService.onDidUninstallExtension(e => this.onDidUnInstallExtension(e)));\n\t}\n\n\tprivate onDidInstallExtension(e: DidInstallExtensionEvent): void {\n\t\tif (!e.error) {\n\t\t\tthis.invalidate();\n\t\t}\n\t}\n\n\tprivate onDidUnInstallExtension(e: DidUninstallExtensionEvent): void {\n\t\tif (!e.error) {\n\t\t\tthis.invalidate();\n\t\t}\n\t}\n\n\tinvalidate(): void {\n\t\tpfs.rimraf(this.extensionsManifestCache, pfs.RimRafMode.MOVE).then(() => { }, () => { });\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'path';\nimport { spawn } from 'child_process';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { IProcessEnvironment, isWindows, OS } from 'vs/base/common/platform';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { NativeParsedArgs } from 'vs/platform/environment/common/argv';\nimport { isLaunchedFromCli } from 'vs/platform/environment/node/argvHelper';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { getSystemShell } from 'vs/base/node/shell';\n\n/**\n * We need to get the environment from a user's shell.\n * This should only be done when Code itself is not launched\n * from within a shell.\n */\nexport async function resolveShellEnv(logService: ILogService, args: NativeParsedArgs, env: IProcessEnvironment): Promise<typeof process.env> {\n\n\t// Skip if --force-disable-user-env\n\tif (args['force-disable-user-env']) {\n\t\tlogService.trace('resolveShellEnv(): skipped (--force-disable-user-env)');\n\n\t\treturn {};\n\t}\n\n\t// Skip on windows\n\telse if (isWindows) {\n\t\tlogService.trace('resolveShellEnv(): skipped (Windows)');\n\n\t\treturn {};\n\t}\n\n\t// Skip if running from CLI already\n\telse if (isLaunchedFromCli(env) && !args['force-user-env']) {\n\t\tlogService.trace('resolveShellEnv(): skipped (VSCODE_CLI is set)');\n\n\t\treturn {};\n\t}\n\n\t// Otherwise resolve (macOS, Linux)\n\telse {\n\t\tif (isLaunchedFromCli(env)) {\n\t\t\tlogService.trace('resolveShellEnv(): running (--force-user-env)');\n\t\t} else {\n\t\t\tlogService.trace('resolveShellEnv(): running (macOS/Linux)');\n\t\t}\n\n\t\tif (!unixShellEnvPromise) {\n\t\t\tunixShellEnvPromise = doResolveUnixShellEnv(logService);\n\t\t}\n\n\t\treturn unixShellEnvPromise;\n\t}\n}\n\nlet unixShellEnvPromise: Promise<typeof process.env> | undefined = undefined;\n\nasync function doResolveUnixShellEnv(logService: ILogService): Promise<typeof process.env> {\n\tconst promise = new Promise<typeof process.env>(async (resolve, reject) => {\n\t\tconst runAsNode = process.env['ELECTRON_RUN_AS_NODE'];\n\t\tlogService.trace('getUnixShellEnvironment#runAsNode', runAsNode);\n\n\t\tconst noAttach = process.env['ELECTRON_NO_ATTACH_CONSOLE'];\n\t\tlogService.trace('getUnixShellEnvironment#noAttach', noAttach);\n\n\t\tconst mark = generateUuid().replace(/-/g, '').substr(0, 12);\n\t\tconst regex = new RegExp(mark + '(.*)' + mark);\n\n\t\tconst env = {\n\t\t\t...process.env,\n\t\t\tELECTRON_RUN_AS_NODE: '1',\n\t\t\tELECTRON_NO_ATTACH_CONSOLE: '1'\n\t\t};\n\n\t\tlogService.trace('getUnixShellEnvironment#env', env);\n\t\tconst systemShellUnix = await getSystemShell(OS, env);\n\t\tlogService.trace('getUnixShellEnvironment#shell', systemShellUnix);\n\n\t\t// handle popular non-POSIX shells\n\t\tconst name = path.basename(systemShellUnix);\n\t\tlet command: string, shellArgs: Array<string>;\n\t\tif (/^pwsh(-preview)?$/.test(name)) {\n\t\t\t// Older versions of PowerShell removes double quotes sometimes so we use \"double single quotes\" which is how\n\t\t\t// you escape single quotes inside of a single quoted string.\n\t\t\tcommand = `& '${process.execPath}' -p '''${mark}'' + JSON.stringify(process.env) + ''${mark}'''`;\n\t\t\tshellArgs = ['-Login', '-Command'];\n\t\t} else {\n\t\t\tcommand = `'${process.execPath}' -p '\"${mark}\" + JSON.stringify(process.env) + \"${mark}\"'`;\n\t\t\tshellArgs = ['-ilc'];\n\t\t}\n\n\t\tlogService.trace('getUnixShellEnvironment#spawn', JSON.stringify(shellArgs), command);\n\n\t\tconst child = spawn(systemShellUnix, [...shellArgs, command], {\n\t\t\tdetached: true,\n\t\t\tstdio: ['ignore', 'pipe', 'pipe'],\n\t\t\tenv\n\t\t});\n\n\t\tchild.on('error', err => {\n\t\t\tlogService.error('getUnixShellEnvironment#errorChildProcess', toErrorMessage(err));\n\t\t\tresolve({});\n\t\t});\n\n\t\tconst buffers: Buffer[] = [];\n\t\tchild.stdout.on('data', b => buffers.push(b));\n\n\t\tconst stderr: Buffer[] = [];\n\t\tchild.stderr.on('data', b => stderr.push(b));\n\n\t\tchild.on('close', (code, signal) => {\n\t\t\tconst raw = Buffer.concat(buffers).toString('utf8');\n\t\t\tlogService.trace('getUnixShellEnvironment#raw', raw);\n\n\t\t\tconst stderrStr = Buffer.concat(stderr).toString('utf8');\n\t\t\tif (stderrStr.trim()) {\n\t\t\t\tlogService.trace('getUnixShellEnvironment#stderr', stderrStr);\n\t\t\t}\n\n\t\t\tif (code || signal) {\n\t\t\t\treturn reject(new Error(`Failed to get environment (code ${code}, signal ${signal})`));\n\t\t\t}\n\n\t\t\tconst match = regex.exec(raw);\n\t\t\tconst rawStripped = match ? match[1] : '{}';\n\n\t\t\ttry {\n\t\t\t\tconst env = JSON.parse(rawStripped);\n\n\t\t\t\tif (runAsNode) {\n\t\t\t\t\tenv['ELECTRON_RUN_AS_NODE'] = runAsNode;\n\t\t\t\t} else {\n\t\t\t\t\tdelete env['ELECTRON_RUN_AS_NODE'];\n\t\t\t\t}\n\n\t\t\t\tif (noAttach) {\n\t\t\t\t\tenv['ELECTRON_NO_ATTACH_CONSOLE'] = noAttach;\n\t\t\t\t} else {\n\t\t\t\t\tdelete env['ELECTRON_NO_ATTACH_CONSOLE'];\n\t\t\t\t}\n\n\t\t\t\t// https://github.com/microsoft/vscode/issues/22593#issuecomment-336050758\n\t\t\t\tdelete env['XDG_RUNTIME_DIR'];\n\n\t\t\t\tlogService.trace('getUnixShellEnvironment#result', env);\n\t\t\t\tresolve(env);\n\t\t\t} catch (err) {\n\t\t\t\tlogService.error('getUnixShellEnvironment#errorCaught', toErrorMessage(err));\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t});\n\n\ttry {\n\t\treturn await promise;\n\t} catch (error) {\n\t\tlogService.error('getUnixShellEnvironment#error', toErrorMessage(error));\n\n\t\treturn {}; // ignore any errors\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI as uri } from 'vs/base/common/uri';\nimport { FileChangeType, isParent, IFileChange } from 'vs/platform/files/common/files';\nimport { isLinux } from 'vs/base/common/platform';\n\nexport interface IDiskFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport interface ILogMessage {\n\ttype: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\tmessage: string;\n}\n\nexport function toFileChanges(changes: IDiskFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: uri.file(change.path)\n\t}));\n}\n\nexport function normalizeFileChanges(changes: IDiskFileChange[]): IDiskFileChange[] {\n\n\t// Build deltas\n\tconst normalizer = new EventNormalizer();\n\tfor (const event of changes) {\n\t\tnormalizer.processEvent(event);\n\t}\n\n\treturn normalizer.normalize();\n}\n\nclass EventNormalizer {\n\tprivate normalized: IDiskFileChange[] = [];\n\tprivate mapPathToChange: Map<string, IDiskFileChange> = new Map();\n\n\tprocessEvent(event: IDiskFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(event.path);\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// ignore CREATE followed by DELETE in one go\n\t\t\tif (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(event.path);\n\t\t\t\tthis.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n\t\t\t}\n\n\t\t\t// flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise store new\n\t\telse {\n\t\t\tthis.normalized.push(event);\n\t\t\tthis.mapPathToChange.set(event.path, event);\n\t\t}\n\t}\n\n\tnormalize(): IDiskFileChange[] {\n\t\tconst addedChangeEvents: IDiskFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn this.normalized.filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddedChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(d => isParent(e.path, d, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addedChangeEvents);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiskFileChange, normalizeFileChanges, ILogMessage } from 'vs/platform/files/node/watcher/watcher';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { SymlinkSupport } from 'vs/base/node/pfs';\nimport { realpath } from 'vs/base/node/extpath';\nimport { watchFolder, watchFile, CHANGE_BUFFER_DELAY } from 'vs/base/node/watcher';\nimport { FileChangeType } from 'vs/platform/files/common/files';\nimport { ThrottledDelayer } from 'vs/base/common/async';\nimport { join, basename } from 'vs/base/common/path';\n\nexport class FileWatcher extends Disposable {\n\tprivate isDisposed: boolean | undefined;\n\n\tprivate fileChangesDelayer: ThrottledDelayer<void> = this._register(new ThrottledDelayer<void>(CHANGE_BUFFER_DELAY * 2 /* sync on delay from underlying library */));\n\tprivate fileChangesBuffer: IDiskFileChange[] = [];\n\n\tconstructor(\n\t\tprivate path: string,\n\t\tprivate onDidFilesChange: (changes: IDiskFileChange[]) => void,\n\t\tprivate onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean\n\t) {\n\t\tsuper();\n\n\t\tthis.startWatching();\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate async startWatching(): Promise<void> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(this.path);\n\n\t\t\tif (this.isDisposed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet pathToWatch = this.path;\n\t\t\tif (symbolicLink) {\n\t\t\t\ttry {\n\t\t\t\t\tpathToWatch = await realpath(pathToWatch);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.onError(error);\n\n\t\t\t\t\tif (symbolicLink.dangling) {\n\t\t\t\t\t\treturn; // give up if symbolic link is dangling\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Watch Folder\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tthis._register(watchFolder(pathToWatch, (eventType, path) => {\n\t\t\t\t\tthis.onFileChange({\n\t\t\t\t\t\ttype: eventType === 'changed' ? FileChangeType.UPDATED : eventType === 'added' ? FileChangeType.ADDED : FileChangeType.DELETED,\n\t\t\t\t\t\tpath: join(this.path, basename(path)) // ensure path is identical with what was passed in\n\t\t\t\t\t});\n\t\t\t\t}, error => this.onError(error)));\n\t\t\t}\n\n\t\t\t// Watch File\n\t\t\telse {\n\t\t\t\tthis._register(watchFile(pathToWatch, eventType => {\n\t\t\t\t\tthis.onFileChange({\n\t\t\t\t\t\ttype: eventType === 'changed' ? FileChangeType.UPDATED : FileChangeType.DELETED,\n\t\t\t\t\t\tpath: this.path // ensure path is identical with what was passed in\n\t\t\t\t\t});\n\t\t\t\t}, error => this.onError(error)));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.onError(error);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onFileChange(event: IDiskFileChange): void {\n\n\t\t// Add to buffer\n\t\tthis.fileChangesBuffer.push(event);\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.onVerbose(`${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.path}`);\n\t\t}\n\n\t\t// Handle emit through delayer to accommodate for bulk changes and thus reduce spam\n\t\tthis.fileChangesDelayer.trigger(async () => {\n\t\t\tconst fileChanges = this.fileChangesBuffer;\n\t\t\tthis.fileChangesBuffer = [];\n\n\t\t\t// Event normalization\n\t\t\tconst normalizedFileChanges = normalizeFileChanges(fileChanges);\n\n\t\t\t// Logging\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tnormalizedFileChanges.forEach(event => {\n\t\t\t\t\tthis.onVerbose(`>> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.path}`);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Fire\n\t\t\tif (normalizedFileChanges.length > 0) {\n\t\t\t\tthis.onDidFilesChange(normalizedFileChanges);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate onError(error: string): void {\n\t\tif (!this.isDisposed) {\n\t\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (node.js)] ${error}` });\n\t\t}\n\t}\n\n\tprivate onVerbose(message: string): void {\n\t\tif (!this.isDisposed) {\n\t\t\tthis.onLogMessage({ type: 'trace', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.isDisposed = true;\n\n\t\tsuper.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';\nimport { SyncDescriptor } from './descriptors';\n\nexport class ServiceCollection {\n\n\tprivate _entries = new Map<ServiceIdentifier<any>, any>();\n\n\tconstructor(...entries: [ServiceIdentifier<any>, any][]) {\n\t\tfor (let [id, service] of entries) {\n\t\t\tthis.set(id, service);\n\t\t}\n\t}\n\n\tset<T>(id: ServiceIdentifier<T>, instanceOrDescriptor: T | SyncDescriptor<T>): T | SyncDescriptor<T> {\n\t\tconst result = this._entries.get(id);\n\t\tthis._entries.set(id, instanceOrDescriptor);\n\t\treturn result;\n\t}\n\n\thas(id: ServiceIdentifier<any>): boolean {\n\t\treturn this._entries.has(id);\n\t}\n\n\tget<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\treturn this._entries.get(id);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { illegalState } from 'vs/base/common/errors';\nimport { Graph } from 'vs/platform/instantiation/common/graph';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { ServiceIdentifier, IInstantiationService, ServicesAccessor, _util, optional } from 'vs/platform/instantiation/common/instantiation';\nimport { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';\nimport { IdleValue } from 'vs/base/common/async';\n\n// TRACING\nconst _enableTracing = false;\n\nclass CyclicDependencyError extends Error {\n\tconstructor(graph: Graph<any>) {\n\t\tsuper('cyclic dependency between services');\n\t\tthis.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n\t}\n}\n\nexport class InstantiationService implements IInstantiationService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _services: ServiceCollection;\n\tprivate readonly _strict: boolean;\n\tprivate readonly _parent?: InstantiationService;\n\n\tconstructor(services: ServiceCollection = new ServiceCollection(), strict: boolean = false, parent?: InstantiationService) {\n\t\tthis._services = services;\n\t\tthis._strict = strict;\n\t\tthis._parent = parent;\n\n\t\tthis._services.set(IInstantiationService, this);\n\t}\n\n\tcreateChild(services: ServiceCollection): IInstantiationService {\n\t\treturn new InstantiationService(services, this._strict, this);\n\t}\n\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R {\n\t\tlet _trace = Trace.traceInvocation(fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>, isOptional?: typeof optional) => {\n\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result && isOptional !== optional) {\n\t\t\t\t\t\tthrow new Error(`[invokeFunction] unknown service '${id}'`);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn fn(accessor, ...args);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance(ctorOrDescriptor: any | SyncDescriptor<any>, ...rest: any[]): any {\n\t\tlet _trace: Trace;\n\t\tlet result: any;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\n\t\t// arguments defined by service decorators\n\t\tlet serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\t\tlet serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tlet service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\t\t\tif (!service && this._strict && !dependency.optional) {\n\t\t\t\tthrow new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tlet firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n\n\t\t\tlet delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn <T>new ctor(...[...args, ...serviceArgs]);\n\t}\n\n\tprivate _setServiceInstance<T>(id: ServiceIdentifier<T>, instance: T): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - setting UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\tlet instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprivate _getOrCreateServiceInstance<T>(id: ServiceIdentifier<T>, _trace: Trace): T {\n\t\tlet thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate readonly _activeInstantiations = new Set<ServiceIdentifier<any>>();\n\n\n\tprivate _safeCreateAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\t\tif (this._activeInstantiations.has(id)) {\n\t\t\tthrow new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n\t\t}\n\t\tthis._activeInstantiations.add(id);\n\t\ttry {\n\t\t\treturn this._createAndCacheServiceInstance(id, desc, _trace);\n\t\t} finally {\n\t\t\tthis._activeInstantiations.delete(id);\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\n\t\ttype Triple = { id: ServiceIdentifier<any>, desc: SyncDescriptor<any>, _trace: Trace; };\n\t\tconst graph = new Graph<Triple>(data => data.id.toString());\n\n\t\tlet cycleCount = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// a weak but working heuristic for cycle checks\n\t\t\tif (cycleCount++ > 1000) {\n\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tfor (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n\n\t\t\t\tlet instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\t\t\t\tif (!instanceOrDesc && !dependency.optional) {\n\t\t\t\t\tconsole.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n\t\t\t\t}\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const { data } of roots) {\n\t\t\t\t// Repeat the check for this still being a service sync descriptor. That's because\n\t\t\t\t// instantiating a dependency might have side-effect and recursively trigger instantiation\n\t\t\t\t// so that some dependencies are now fullfilled already.\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\t\tconst instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\t\t\t\t\tthis._setServiceInstance(data.id, instance);\n\t\t\t\t}\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else {\n\t\t\tthrow new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(ctor: any, args: any[] = [], _supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (!_supportsDelayedInstantiation) {\n\t\t\t// eager instantiation\n\t\t\treturn this._createInstance(ctor, args, _trace);\n\n\t\t} else {\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\t\t\tconst idle = new IdleValue<any>(() => this._createInstance<T>(ctor, args, _trace));\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(target: any, key: PropertyKey): any {\n\t\t\t\t\tif (key in target) {\n\t\t\t\t\t\treturn target[key];\n\t\t\t\t\t}\n\t\t\t\t\tlet obj = idle.value;\n\t\t\t\t\tlet prop = obj[key];\n\t\t\t\t\tif (typeof prop !== 'function') {\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t\t\t\tprop = prop.bind(obj);\n\t\t\t\t\ttarget[key] = prop;\n\t\t\t\t\treturn prop;\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.value[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nconst enum TraceType {\n\tCreation, Invocation, Branch\n}\n\nclass Trace {\n\n\tprivate static readonly _None = new class extends Trace {\n\t\tconstructor() { super(-1, null); }\n\t\toverride stop() { }\n\t\toverride branch() { return this; }\n\t};\n\n\tstatic traceInvocation(ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || (ctor.toString() as string).substring(0, 42).replace(/\\n/g, ''));\n\t}\n\n\tstatic traceCreation(ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n\t}\n\n\tprivate static _totals: number = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null\n\t) { }\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tlet child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tlet dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tlet res: string[] = [];\n\t\t\tlet prefix = new Array(n + 1).join('\\t');\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tlet nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join('\\n');\n\t\t}\n\n\t\tlet lines = [\n\t\t\t`${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tconsole.log(lines.join('\\n'));\n\t\t}\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event } from 'vs/base/common/event';\n\nexport interface ILocalization {\n\tlanguageId: string;\n\tlanguageName?: string;\n\tlocalizedLanguageName?: string;\n\ttranslations: ITranslation[];\n\tminimalTranslations?: { [key: string]: string };\n}\n\nexport interface ITranslation {\n\tid: string;\n\tpath: string;\n}\n\nexport const ILocalizationsService = createDecorator<ILocalizationsService>('localizationsService');\nexport interface ILocalizationsService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onDidLanguagesChange: Event<void>;\n\tgetLanguageIds(): Promise<string[]>;\n}\n\nexport function isValidLocalization(localization: ILocalization): boolean {\n\tif (typeof localization.languageId !== 'string') {\n\t\treturn false;\n\t}\n\tif (!Array.isArray(localization.translations) || localization.translations.length === 0) {\n\t\treturn false;\n\t}\n\tfor (const translation of localization.translations) {\n\t\tif (typeof translation.id !== 'string') {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof translation.path !== 'string') {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (localization.languageName && typeof localization.languageName !== 'string') {\n\t\treturn false;\n\t}\n\tif (localization.localizedLanguageName && typeof localization.localizedLanguageName !== 'string') {\n\t\treturn false;\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator as createServiceDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable, Disposable } from 'vs/base/common/lifecycle';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { URI } from 'vs/base/common/uri';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\n\nexport const ILogService = createServiceDecorator<ILogService>('logService');\nexport const ILoggerService = createServiceDecorator<ILoggerService>('loggerService');\n\nfunction now(): string {\n\treturn new Date().toISOString();\n}\n\nexport enum LogLevel {\n\tTrace,\n\tDebug,\n\tInfo,\n\tWarning,\n\tError,\n\tCritical,\n\tOff\n}\n\nexport const DEFAULT_LOG_LEVEL: LogLevel = LogLevel.Info;\n\nexport interface ILogger extends IDisposable {\n\tonDidChangeLogLevel: Event<LogLevel>;\n\tgetLevel(): LogLevel;\n\tsetLevel(level: LogLevel): void;\n\n\ttrace(message: string, ...args: any[]): void;\n\tdebug(message: string, ...args: any[]): void;\n\tinfo(message: string, ...args: any[]): void;\n\twarn(message: string, ...args: any[]): void;\n\terror(message: string | Error, ...args: any[]): void;\n\tcritical(message: string | Error, ...args: any[]): void;\n\n\t/**\n\t * An operation to flush the contents. Can be synchronous.\n\t */\n\tflush(): void;\n}\n\nexport interface ILogService extends ILogger {\n\treadonly _serviceBrand: undefined;\n}\n\nexport interface ILoggerOptions {\n\n\t/**\n\t * Name of the logger.\n\t */\n\tname?: string;\n\n\t/**\n\t * Do not create rotating files if max size exceeds.\n\t */\n\tdonotRotate?: boolean;\n\n\t/**\n\t * Do not use formatters.\n\t */\n\tdonotUseFormatters?: boolean;\n\n\t/**\n\t * If set, logger logs the message always.\n\t */\n\talways?: boolean;\n}\n\nexport interface ILoggerService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Creates a logger\n\t */\n\tcreateLogger(file: URI, options?: ILoggerOptions): ILogger;\n}\n\nexport abstract class AbstractLogger extends Disposable {\n\n\tprivate level: LogLevel = DEFAULT_LOG_LEVEL;\n\tprivate readonly _onDidChangeLogLevel: Emitter<LogLevel> = this._register(new Emitter<LogLevel>());\n\treadonly onDidChangeLogLevel: Event<LogLevel> = this._onDidChangeLogLevel.event;\n\n\tsetLevel(level: LogLevel): void {\n\t\tif (this.level !== level) {\n\t\t\tthis.level = level;\n\t\t\tthis._onDidChangeLogLevel.fire(this.level);\n\t\t}\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.level;\n\t}\n\n}\n\nexport abstract class AbstractMessageLogger extends AbstractLogger implements ILogger {\n\n\tprotected abstract log(level: LogLevel, message: string): void;\n\n\tconstructor(private readonly logAlways?: boolean) {\n\t\tsuper();\n\t}\n\n\tprivate checkLogLevel(level: LogLevel): boolean {\n\t\treturn this.logAlways || this.getLevel() <= level;\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.checkLogLevel(LogLevel.Trace)) {\n\t\t\tthis.log(LogLevel.Trace, this.format([message, ...args]));\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.checkLogLevel(LogLevel.Debug)) {\n\t\t\tthis.log(LogLevel.Debug, this.format([message, ...args]));\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.checkLogLevel(LogLevel.Info)) {\n\t\t\tthis.log(LogLevel.Info, this.format([message, ...args]));\n\t\t}\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tif (this.checkLogLevel(LogLevel.Warning)) {\n\t\t\tthis.log(LogLevel.Warning, this.format([message, ...args]));\n\t\t}\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tif (this.checkLogLevel(LogLevel.Error)) {\n\n\t\t\tif (message instanceof Error) {\n\t\t\t\tconst array = Array.prototype.slice.call(arguments) as any[];\n\t\t\t\tarray[0] = message.stack;\n\t\t\t\tthis.log(LogLevel.Error, this.format(array));\n\t\t\t} else {\n\t\t\t\tthis.log(LogLevel.Error, this.format([message, ...args]));\n\t\t\t}\n\t\t}\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tif (this.checkLogLevel(LogLevel.Critical)) {\n\t\t\tthis.log(LogLevel.Critical, this.format([message, ...args]));\n\t\t}\n\t}\n\n\tflush(): void { }\n\n\tprivate format(args: any): string {\n\t\tlet result = '';\n\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tlet a = args[i];\n\n\t\t\tif (typeof a === 'object') {\n\t\t\t\ttry {\n\t\t\t\t\ta = JSON.stringify(a);\n\t\t\t\t} catch (e) { }\n\t\t\t}\n\n\t\t\tresult += (i > 0 ? ' ' : '') + a;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n\nexport class ConsoleMainLogger extends AbstractLogger implements ILogger {\n\n\tprivate useColors: boolean;\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t\tthis.useColors = !isWindows;\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Trace) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Debug) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Info) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Warning) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.warn(`\\x1b[93m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Error) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error(`\\x1b[91m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tcritical(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Critical) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\t// noop\n\t}\n\n\tflush(): void {\n\t\t// noop\n\t}\n\n}\n\nexport class ConsoleLogger extends AbstractLogger implements ILogger {\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Trace) {\n\t\t\tconsole.log('%cTRACE', 'color: #888', message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Debug) {\n\t\t\tconsole.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Info) {\n\t\t\tconsole.log('%c INFO', 'color: #33f', message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Warning) {\n\t\t\tconsole.log('%c WARN', 'color: #993', message, ...args);\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Error) {\n\t\t\tconsole.log('%c  ERR', 'color: #f33', message, ...args);\n\t\t}\n\t}\n\n\tcritical(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Critical) {\n\t\t\tconsole.log('%cCRITI', 'background: #f33; color: white', message, ...args);\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\t// noop\n\t}\n\n\tflush(): void {\n\t\t// noop\n\t}\n}\n\nexport class AdapterLogger extends AbstractLogger implements ILogger {\n\n\tconstructor(private readonly adapter: { log: (logLevel: LogLevel, args: any[]) => void }, logLevel: LogLevel = DEFAULT_LOG_LEVEL) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Trace) {\n\t\t\tthis.adapter.log(LogLevel.Trace, [this.extractMessage(message), ...args]);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Debug) {\n\t\t\tthis.adapter.log(LogLevel.Debug, [this.extractMessage(message), ...args]);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Info) {\n\t\t\tthis.adapter.log(LogLevel.Info, [this.extractMessage(message), ...args]);\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Warning) {\n\t\t\tthis.adapter.log(LogLevel.Warning, [this.extractMessage(message), ...args]);\n\t\t}\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Error) {\n\t\t\tthis.adapter.log(LogLevel.Error, [this.extractMessage(message), ...args]);\n\t\t}\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Critical) {\n\t\t\tthis.adapter.log(LogLevel.Critical, [this.extractMessage(message), ...args]);\n\t\t}\n\t}\n\n\tprivate extractMessage(msg: string | Error): string {\n\t\tif (typeof msg === 'string') {\n\t\t\treturn msg;\n\t\t}\n\n\t\treturn toErrorMessage(msg, this.getLevel() <= LogLevel.Trace);\n\t}\n\n\toverride dispose(): void {\n\t\t// noop\n\t}\n\n\tflush(): void {\n\t\t// noop\n\t}\n}\n\nexport class MultiplexLogService extends AbstractLogger implements ILogService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(private readonly logServices: ReadonlyArray<ILogger>) {\n\t\tsuper();\n\t\tif (logServices.length) {\n\t\t\tthis.setLevel(logServices[0].getLevel());\n\t\t}\n\t}\n\n\toverride setLevel(level: LogLevel): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.setLevel(level);\n\t\t}\n\t\tsuper.setLevel(level);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.trace(message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.debug(message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.info(message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.warn(message, ...args);\n\t\t}\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.error(message, ...args);\n\t\t}\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.critical(message, ...args);\n\t\t}\n\t}\n\n\tflush(): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.flush();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.dispose();\n\t\t}\n\t}\n}\n\nexport class LogService extends Disposable implements ILogService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(private logger: ILogger) {\n\t\tsuper();\n\t\tthis._register(logger);\n\t}\n\n\tget onDidChangeLogLevel(): Event<LogLevel> {\n\t\treturn this.logger.onDidChangeLogLevel;\n\t}\n\n\tsetLevel(level: LogLevel): void {\n\t\tthis.logger.setLevel(level);\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.logger.getLevel();\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tthis.logger.trace(message, ...args);\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tthis.logger.debug(message, ...args);\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tthis.logger.info(message, ...args);\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tthis.logger.warn(message, ...args);\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tthis.logger.error(message, ...args);\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tthis.logger.critical(message, ...args);\n\t}\n\n\tflush(): void {\n\t\tthis.logger.flush();\n\t}\n}\n\nexport abstract class AbstractLoggerService extends Disposable implements ILoggerService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly loggers = new Map<string, ILogger>();\n\tprivate readonly logLevelChangeableLoggers: ILogger[] = [];\n\n\tconstructor(\n\t\tprivate logLevel: LogLevel,\n\t\tonDidChangeLogLevel: Event<LogLevel>,\n\t) {\n\t\tsuper();\n\t\tthis._register(onDidChangeLogLevel(logLevel => {\n\t\t\tthis.logLevel = logLevel;\n\t\t\tthis.logLevelChangeableLoggers.forEach(logger => logger.setLevel(logLevel));\n\t\t}));\n\t}\n\n\tcreateLogger(resource: URI, options?: ILoggerOptions): ILogger {\n\t\tlet logger = this.loggers.get(resource.toString());\n\t\tif (!logger) {\n\t\t\tlogger = this.doCreateLogger(resource, options?.always ? LogLevel.Trace : this.logLevel, options);\n\t\t\tthis.loggers.set(resource.toString(), logger);\n\t\t\tif (!options?.always) {\n\t\t\t\tthis.logLevelChangeableLoggers.push(logger);\n\t\t\t}\n\t\t}\n\t\treturn logger;\n\t}\n\n\toverride dispose(): void {\n\t\tthis.logLevelChangeableLoggers.splice(0, this.logLevelChangeableLoggers.length);\n\t\tthis.loggers.forEach(logger => logger.dispose());\n\t\tthis.loggers.clear();\n\t\tsuper.dispose();\n\t}\n\n\tprotected abstract doCreateLogger(resource: URI, logLevel: LogLevel, options?: ILoggerOptions): ILogger;\n}\n\nexport class NullLogService implements ILogService {\n\tdeclare readonly _serviceBrand: undefined;\n\treadonly onDidChangeLogLevel: Event<LogLevel> = new Emitter<LogLevel>().event;\n\tsetLevel(level: LogLevel): void { }\n\tgetLevel(): LogLevel { return LogLevel.Info; }\n\ttrace(message: string, ...args: any[]): void { }\n\tdebug(message: string, ...args: any[]): void { }\n\tinfo(message: string, ...args: any[]): void { }\n\twarn(message: string, ...args: any[]): void { }\n\terror(message: string | Error, ...args: any[]): void { }\n\tcritical(message: string | Error, ...args: any[]): void { }\n\tdispose(): void { }\n\tflush(): void { }\n}\n\nexport function getLogLevel(environmentService: IEnvironmentService): LogLevel {\n\tif (environmentService.verbose) {\n\t\treturn LogLevel.Trace;\n\t}\n\tif (typeof environmentService.logLevel === 'string') {\n\t\tconst logLevel = parseLogLevel(environmentService.logLevel.toLowerCase());\n\t\tif (logLevel !== undefined) {\n\t\t\treturn logLevel;\n\t\t}\n\t}\n\treturn DEFAULT_LOG_LEVEL;\n}\n\nexport function parseLogLevel(logLevel: string): LogLevel | undefined {\n\tswitch (logLevel) {\n\t\tcase 'trace':\n\t\t\treturn LogLevel.Trace;\n\t\tcase 'debug':\n\t\t\treturn LogLevel.Debug;\n\t\tcase 'info':\n\t\t\treturn LogLevel.Info;\n\t\tcase 'warn':\n\t\t\treturn LogLevel.Warning;\n\t\tcase 'error':\n\t\t\treturn LogLevel.Error;\n\t\tcase 'critical':\n\t\t\treturn LogLevel.Critical;\n\t\tcase 'off':\n\t\t\treturn LogLevel.Off;\n\t}\n\treturn undefined;\n}\n\nexport function LogLevelToString(logLevel: LogLevel): string {\n\tswitch (logLevel) {\n\t\tcase LogLevel.Trace: return 'trace';\n\t\tcase LogLevel.Debug: return 'debug';\n\t\tcase LogLevel.Info: return 'info';\n\t\tcase LogLevel.Warning: return 'warn';\n\t\tcase LogLevel.Error: return 'error';\n\t\tcase LogLevel.Critical: return 'critical';\n\t\tcase LogLevel.Off: return 'off';\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promises } from 'fs';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IFileService, IFileStatWithMetadata } from 'vs/platform/files/common/files';\nimport { IExtensionGalleryService, IGalleryExtension, InstallOperation } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { URI } from 'vs/base/common/uri';\nimport { joinPath } from 'vs/base/common/resources';\nimport { ExtensionIdentifierWithVersion, groupByExtension } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport * as semver from 'vs/base/common/semver/semver';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Promises } from 'vs/base/common/async';\nimport { getErrorMessage } from 'vs/base/common/errors';\n\nconst ExtensionIdVersionRegex = /^([^.]+\\..+)-(\\d+\\.\\d+\\.\\d+)$/;\n\nexport class ExtensionsDownloader extends Disposable {\n\n\tprivate readonly extensionsDownloadDir: URI;\n\tprivate readonly cache: number;\n\tprivate readonly cleanUpPromise: Promise<void>;\n\n\tconstructor(\n\t\t@INativeEnvironmentService environmentService: INativeEnvironmentService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IExtensionGalleryService private readonly extensionGalleryService: IExtensionGalleryService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tthis.extensionsDownloadDir = URI.file(environmentService.extensionsDownloadPath);\n\t\tthis.cache = 20; // Cache 20 downloads\n\t\tthis.cleanUpPromise = this.cleanUp();\n\t}\n\n\tasync downloadExtension(extension: IGalleryExtension, operation: InstallOperation): Promise<URI> {\n\t\tawait this.cleanUpPromise;\n\t\tconst vsixName = this.getName(extension);\n\t\tconst location = joinPath(this.extensionsDownloadDir, vsixName);\n\n\t\t// Download only if vsix does not exist\n\t\tif (!await this.fileService.exists(location)) {\n\t\t\t// Download to temporary location first only if vsix does not exist\n\t\t\tconst tempLocation = joinPath(this.extensionsDownloadDir, `.${generateUuid()}`);\n\t\t\tif (!await this.fileService.exists(tempLocation)) {\n\t\t\t\tawait this.extensionGalleryService.download(extension, tempLocation, operation);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Rename temp location to original\n\t\t\t\tawait this.rename(tempLocation, location, Date.now() + (2 * 60 * 1000) /* Retry for 2 minutes */);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.fileService.del(tempLocation);\n\t\t\t\t} catch (e) { /* ignore */ }\n\t\t\t\tif (error.code === 'ENOTEMPTY') {\n\t\t\t\t\tthis.logService.info(`Rename failed because vsix was downloaded by another source. So ignoring renaming.`, extension.identifier.id);\n\t\t\t\t} else {\n\t\t\t\t\tthis.logService.info(`Rename failed because of ${getErrorMessage(error)}. Deleted the vsix from downloaded location`, tempLocation.path);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn location;\n\t}\n\n\tasync delete(location: URI): Promise<void> {\n\t\t// noop as caching is enabled always\n\t}\n\n\tprivate async rename(from: URI, to: URI, retryUntil: number): Promise<void> {\n\t\ttry {\n\t\t\tawait promises.rename(from.fsPath, to.fsPath);\n\t\t} catch (error) {\n\t\t\tif (isWindows && error && error.code === 'EPERM' && Date.now() < retryUntil) {\n\t\t\t\tthis.logService.info(`Failed renaming ${from} to ${to} with 'EPERM' error. Trying again...`);\n\t\t\t\treturn this.rename(from, to, retryUntil);\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async cleanUp(): Promise<void> {\n\t\ttry {\n\t\t\tif (!(await this.fileService.exists(this.extensionsDownloadDir))) {\n\t\t\t\tthis.logService.trace('Extension VSIX downlads cache dir does not exist');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst folderStat = await this.fileService.resolve(this.extensionsDownloadDir, { resolveMetadata: true });\n\t\t\tif (folderStat.children) {\n\t\t\t\tconst toDelete: URI[] = [];\n\t\t\t\tconst all: [ExtensionIdentifierWithVersion, IFileStatWithMetadata][] = [];\n\t\t\t\tfor (const stat of folderStat.children) {\n\t\t\t\t\tconst extension = this.parse(stat.name);\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tall.push([extension, stat]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst byExtension = groupByExtension(all, ([extension]) => extension);\n\t\t\t\tconst distinct: IFileStatWithMetadata[] = [];\n\t\t\t\tfor (const p of byExtension) {\n\t\t\t\t\tp.sort((a, b) => semver.rcompare(a[0].version, b[0].version));\n\t\t\t\t\ttoDelete.push(...p.slice(1).map(e => e[1].resource)); // Delete outdated extensions\n\t\t\t\t\tdistinct.push(p[0][1]);\n\t\t\t\t}\n\t\t\t\tdistinct.sort((a, b) => a.mtime - b.mtime); // sort by modified time\n\t\t\t\ttoDelete.push(...distinct.slice(0, Math.max(0, distinct.length - this.cache)).map(s => s.resource)); // Retain minimum cacheSize and delete the rest\n\t\t\t\tawait Promises.settled(toDelete.map(resource => {\n\t\t\t\t\tthis.logService.trace('Deleting vsix from cache', resource.path);\n\t\t\t\t\treturn this.fileService.del(resource);\n\t\t\t\t}));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.logService.error(e);\n\t\t}\n\t}\n\n\tprivate getName(extension: IGalleryExtension): string {\n\t\treturn this.cache ? new ExtensionIdentifierWithVersion(extension.identifier, extension.version).key().toLowerCase() : generateUuid();\n\t}\n\n\tprivate parse(name: string): ExtensionIdentifierWithVersion | null {\n\t\tconst matches = ExtensionIdVersionRegex.exec(name);\n\t\treturn matches && matches[1] && matches[2] ? new ExtensionIdentifierWithVersion({ id: matches[1] }, matches[2]) : null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ILocalExtension } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { fork, ChildProcess } from 'child_process';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { join } from 'vs/base/common/path';\nimport { Limiter } from 'vs/base/common/async';\nimport { Event } from 'vs/base/common/event';\nimport { Schemas } from 'vs/base/common/network';\nimport { rimraf } from 'vs/base/node/pfs';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\n\nexport class ExtensionsLifecycle extends Disposable {\n\n\tprivate processesLimiter: Limiter<void> = new Limiter(5); // Run max 5 processes in parallel\n\n\tconstructor(\n\t\t@IEnvironmentService private environmentService: IEnvironmentService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t}\n\n\tasync postUninstall(extension: ILocalExtension): Promise<void> {\n\t\tconst script = this.parseScript(extension, 'uninstall');\n\t\tif (script) {\n\t\t\tthis.logService.info(extension.identifier.id, extension.manifest.version, `Running post uninstall script`);\n\t\t\tawait this.processesLimiter.queue(() =>\n\t\t\t\tthis.runLifecycleHook(script.script, 'uninstall', script.args, true, extension)\n\t\t\t\t\t.then(() => this.logService.info(extension.identifier.id, extension.manifest.version, `Finished running post uninstall script`), err => this.logService.error(extension.identifier.id, extension.manifest.version, `Failed to run post uninstall script: ${err}`)));\n\t\t}\n\t\treturn rimraf(this.getExtensionStoragePath(extension)).then(undefined, e => this.logService.error('Error while removing extension storage path', e));\n\t}\n\n\tprivate parseScript(extension: ILocalExtension, type: string): { script: string, args: string[] } | null {\n\t\tconst scriptKey = `vscode:${type}`;\n\t\tif (extension.location.scheme === Schemas.file && extension.manifest && extension.manifest['scripts'] && typeof extension.manifest['scripts'][scriptKey] === 'string') {\n\t\t\tconst script = (<string>extension.manifest['scripts'][scriptKey]).split(' ');\n\t\t\tif (script.length < 2 || script[0] !== 'node' || !script[1]) {\n\t\t\t\tthis.logService.warn(extension.identifier.id, extension.manifest.version, `${scriptKey} should be a node script`);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn { script: join(extension.location.fsPath, script[1]), args: script.slice(2) || [] };\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate runLifecycleHook(lifecycleHook: string, lifecycleType: string, args: string[], timeout: boolean, extension: ILocalExtension): Promise<void> {\n\t\treturn new Promise<void>((c, e) => {\n\n\t\t\tconst extensionLifecycleProcess = this.start(lifecycleHook, lifecycleType, args, extension);\n\t\t\tlet timeoutHandler: any;\n\n\t\t\tconst onexit = (error?: string) => {\n\t\t\t\tif (timeoutHandler) {\n\t\t\t\t\tclearTimeout(timeoutHandler);\n\t\t\t\t\ttimeoutHandler = null;\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\te(error);\n\t\t\t\t} else {\n\t\t\t\t\tc(undefined);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// on error\n\t\t\textensionLifecycleProcess.on('error', (err) => {\n\t\t\t\tonexit(toErrorMessage(err) || 'Unknown');\n\t\t\t});\n\n\t\t\t// on exit\n\t\t\textensionLifecycleProcess.on('exit', (code: number, signal: string) => {\n\t\t\t\tonexit(code ? `post-${lifecycleType} process exited with code ${code}` : undefined);\n\t\t\t});\n\n\t\t\tif (timeout) {\n\t\t\t\t// timeout: kill process after waiting for 5s\n\t\t\t\ttimeoutHandler = setTimeout(() => {\n\t\t\t\t\ttimeoutHandler = null;\n\t\t\t\t\textensionLifecycleProcess.kill();\n\t\t\t\t\te('timed out');\n\t\t\t\t}, 5000);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate start(uninstallHook: string, lifecycleType: string, args: string[], extension: ILocalExtension): ChildProcess {\n\t\tconst opts = {\n\t\t\tsilent: true,\n\t\t\texecArgv: undefined\n\t\t};\n\t\tconst extensionUninstallProcess = fork(uninstallHook, [`--type=extension-post-${lifecycleType}`, ...args], opts);\n\n\t\t// Catch all output coming from the process\n\t\ttype Output = { data: string, format: string[] };\n\t\textensionUninstallProcess.stdout!.setEncoding('utf8');\n\t\textensionUninstallProcess.stderr!.setEncoding('utf8');\n\n\t\tconst onStdout = Event.fromNodeEventEmitter<string>(extensionUninstallProcess.stdout!, 'data');\n\t\tconst onStderr = Event.fromNodeEventEmitter<string>(extensionUninstallProcess.stderr!, 'data');\n\n\t\t// Log output\n\t\tonStdout(data => this.logService.info(extension.identifier.id, extension.manifest.version, `post-${lifecycleType}`, data));\n\t\tonStderr(data => this.logService.error(extension.identifier.id, extension.manifest.version, `post-${lifecycleType}`, data));\n\n\t\tconst onOutput = Event.any(\n\t\t\tEvent.map(onStdout, o => ({ data: `%c${o}`, format: [''] })),\n\t\t\tEvent.map(onStderr, o => ({ data: `%c${o}`, format: ['color: red'] }))\n\t\t);\n\t\t// Debounce all output, so we can render it in the Chrome console as a group\n\t\tconst onDebouncedOutput = Event.debounce<Output>(onOutput, (r, o) => {\n\t\t\treturn r\n\t\t\t\t? { data: r.data + o.data, format: [...r.format, ...o.format] }\n\t\t\t\t: { data: o.data, format: o.format };\n\t\t}, 100);\n\n\t\t// Print out output\n\t\tonDebouncedOutput(data => {\n\t\t\tconsole.group(extension.identifier.id);\n\t\t\tconsole.log(data.data, ...data.format);\n\t\t\tconsole.groupEnd();\n\t\t});\n\n\t\treturn extensionUninstallProcess;\n\t}\n\n\tprivate getExtensionStoragePath(extension: ILocalExtension): string {\n\t\treturn join(this.environmentService.globalStorageHome.fsPath, extension.identifier.id.toLowerCase());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { DidInstallExtensionEvent, DidUninstallExtensionEvent, IExtensionManagementService, ILocalExtension, InstallExtensionEvent } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { ExtensionType, IExtensionIdentifier } from 'vs/platform/extensions/common/extensions';\nimport { FileChangeType, FileSystemProviderCapabilities, IFileChange, IFileService } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { areSameExtensions } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { ExtUri } from 'vs/base/common/resources';\nimport { ILogService } from 'vs/platform/log/common/log';\n\nexport class ExtensionsWatcher extends Disposable {\n\n\tprivate readonly _onDidChangeExtensionsByAnotherSource = this._register(new Emitter<{ added: ILocalExtension[], removed: IExtensionIdentifier[] }>());\n\treadonly onDidChangeExtensionsByAnotherSource = this._onDidChangeExtensionsByAnotherSource.event;\n\n\tprivate startTimestamp = 0;\n\tprivate installingExtensions: IExtensionIdentifier[] = [];\n\tprivate installedExtensions: IExtensionIdentifier[] | undefined;\n\n\tconstructor(\n\t\tprivate readonly extensionsManagementService: IExtensionManagementService,\n\t\t@IFileService fileService: IFileService,\n\t\t@INativeEnvironmentService environmentService: INativeEnvironmentService,\n\t\t@ILogService private readonly logService: ILogService,\n\t) {\n\t\tsuper();\n\t\tthis.extensionsManagementService.getInstalled(ExtensionType.User).then(extensions => {\n\t\t\tthis.installedExtensions = extensions.map(e => e.identifier);\n\t\t\tthis.startTimestamp = Date.now();\n\t\t});\n\t\tthis._register(extensionsManagementService.onInstallExtension(e => this.onInstallExtension(e)));\n\t\tthis._register(extensionsManagementService.onDidInstallExtension(e => this.onDidInstallExtension(e)));\n\t\tthis._register(extensionsManagementService.onDidUninstallExtension(e => this.onDidUninstallExtension(e)));\n\n\t\tconst extensionsResource = URI.file(environmentService.extensionsPath);\n\t\tconst extUri = new ExtUri(resource => !fileService.hasCapability(resource, FileSystemProviderCapabilities.PathCaseSensitive));\n\t\tthis._register(fileService.watch(extensionsResource));\n\t\tthis._register(Event.filter(fileService.onDidFilesChange, e => e.changes.some(change => this.doesChangeAffects(change, extensionsResource, extUri)))(() => this.onDidChange()));\n\t}\n\n\tprivate doesChangeAffects(change: IFileChange, extensionsResource: URI, extUri: ExtUri): boolean {\n\t\t// Is not immediate child of extensions resource\n\t\tif (!extUri.isEqual(extUri.dirname(change.resource), extensionsResource)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// .obsolete file changed\n\t\tif (extUri.isEqual(change.resource, extUri.joinPath(extensionsResource, '.obsolete'))) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Only interested in added/deleted changes\n\t\tif (change.type !== FileChangeType.ADDED && change.type !== FileChangeType.DELETED) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Ingore changes to files starting with `.`\n\t\tif (extUri.basename(change.resource).startsWith('.')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate onInstallExtension(e: InstallExtensionEvent): void {\n\t\tthis.addInstallingExtension(e.identifier);\n\t}\n\n\tprivate onDidInstallExtension(e: DidInstallExtensionEvent): void {\n\t\tthis.removeInstallingExtension(e.identifier);\n\t\tif (!e.error) {\n\t\t\tthis.addInstalledExtension(e.identifier);\n\t\t}\n\t}\n\n\tprivate onDidUninstallExtension(e: DidUninstallExtensionEvent): void {\n\t\tif (!e.error) {\n\t\t\tthis.removeInstalledExtension(e.identifier);\n\t\t}\n\t}\n\n\tprivate addInstallingExtension(extension: IExtensionIdentifier) {\n\t\tthis.removeInstallingExtension(extension);\n\t\tthis.installingExtensions.push(extension);\n\t}\n\n\tprivate removeInstallingExtension(identifier: IExtensionIdentifier) {\n\t\tthis.installingExtensions = this.installingExtensions.filter(e => !areSameExtensions(e, identifier));\n\t}\n\n\tprivate addInstalledExtension(extension: IExtensionIdentifier): void {\n\t\tif (this.installedExtensions) {\n\t\t\tthis.removeInstalledExtension(extension);\n\t\t\tthis.installedExtensions.push(extension);\n\t\t}\n\t}\n\n\tprivate removeInstalledExtension(identifier: IExtensionIdentifier): void {\n\t\tif (this.installedExtensions) {\n\t\t\tthis.installedExtensions = this.installedExtensions.filter(e => !areSameExtensions(e, identifier));\n\t\t}\n\t}\n\n\tprivate async onDidChange(): Promise<void> {\n\t\tif (this.installedExtensions) {\n\t\t\tconst extensions = await this.extensionsManagementService.getInstalled(ExtensionType.User);\n\t\t\tconst added = extensions.filter(e => {\n\t\t\t\tif ([...this.installingExtensions, ...this.installedExtensions!].some(identifier => areSameExtensions(identifier, e.identifier))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (e.installedTimestamp && e.installedTimestamp > this.startTimestamp) {\n\t\t\t\t\tthis.logService.info('Detected extension installed from another source', e.identifier.id);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.logService.info('Ignored extension installed by another source because of invalid timestamp', e.identifier.id);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst removed = this.installedExtensions.filter(identifier => {\n\t\t\t\t// Extension being installed\n\t\t\t\tif (this.installingExtensions.some(installingExtension => areSameExtensions(installingExtension, identifier))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (extensions.every(e => !areSameExtensions(e.identifier, identifier))) {\n\t\t\t\t\tthis.logService.info('Detected extension removed from another source', identifier.id);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\tthis.installedExtensions = extensions.map(e => e.identifier);\n\t\t\tif (added.length || removed.length) {\n\t\t\t\tthis._onDidChangeExtensionsByAnotherSource.fire({ added, removed });\n\t\t\t}\n\t\t}\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { writeFile } from 'vs/base/node/pfs';\nimport { promises } from 'fs';\nimport { createHash } from 'crypto';\nimport { IExtensionManagementService, ILocalExtension, IExtensionIdentifier } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { Queue } from 'vs/base/common/async';\nimport { areSameExtensions } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { isValidLocalization, ILocalizationsService } from 'vs/platform/localizations/common/localizations';\nimport { distinct, equals } from 'vs/base/common/arrays';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { Schemas } from 'vs/base/common/network';\nimport { join } from 'vs/base/common/path';\n\ninterface ILanguagePack {\n\thash: string;\n\textensions: {\n\t\textensionIdentifier: IExtensionIdentifier;\n\t\tversion: string;\n\t}[];\n\ttranslations: { [id: string]: string };\n}\n\nexport class LocalizationsService extends Disposable implements ILocalizationsService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly cache: LanguagePacksCache;\n\n\tprivate readonly _onDidLanguagesChange: Emitter<void> = this._register(new Emitter<void>());\n\treadonly onDidLanguagesChange: Event<void> = this._onDidLanguagesChange.event;\n\n\tconstructor(\n\t\t@IExtensionManagementService private readonly extensionManagementService: IExtensionManagementService,\n\t\t@INativeEnvironmentService environmentService: INativeEnvironmentService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis.cache = this._register(new LanguagePacksCache(environmentService, logService));\n\n\t\tthis._register(extensionManagementService.onDidInstallExtension(({ local }) => this.onDidInstallExtension(local)));\n\t\tthis._register(extensionManagementService.onDidUninstallExtension(({ identifier }) => this.onDidUninstallExtension(identifier)));\n\t}\n\n\tgetLanguageIds(): Promise<string[]> {\n\t\treturn this.cache.getLanguagePacks()\n\t\t\t.then(languagePacks => {\n\t\t\t\t// Contributed languages are those installed via extension packs, so does not include English\n\t\t\t\tconst languages = ['en', ...Object.keys(languagePacks)];\n\t\t\t\treturn distinct(languages);\n\t\t\t});\n\t}\n\n\tprivate onDidInstallExtension(extension: ILocalExtension | undefined): void {\n\t\tif (extension && extension.manifest && extension.manifest.contributes && extension.manifest.contributes.localizations && extension.manifest.contributes.localizations.length) {\n\t\t\tthis.logService.debug('Adding language packs from the extension', extension.identifier.id);\n\t\t\tthis.update().then(changed => { if (changed) { this._onDidLanguagesChange.fire(); } });\n\t\t}\n\t}\n\n\tprivate onDidUninstallExtension(identifier: IExtensionIdentifier): void {\n\t\tthis.cache.getLanguagePacks()\n\t\t\t.then(languagePacks => {\n\t\t\t\tif (Object.keys(languagePacks).some(language => languagePacks[language] && languagePacks[language].extensions.some(e => areSameExtensions(e.extensionIdentifier, identifier)))) {\n\t\t\t\t\tthis.logService.debug('Removing language packs from the extension', identifier.id);\n\t\t\t\t\tthis.update().then(changed => { if (changed) { this._onDidLanguagesChange.fire(); } });\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tasync update(): Promise<boolean> {\n\t\tconst [current, installed] = await Promise.all([this.cache.getLanguagePacks(), this.extensionManagementService.getInstalled()]);\n\t\tconst updated = await this.cache.update(installed);\n\t\treturn !equals(Object.keys(current), Object.keys(updated));\n\t}\n}\n\nclass LanguagePacksCache extends Disposable {\n\n\tprivate languagePacks: { [language: string]: ILanguagePack } = {};\n\tprivate languagePacksFilePath: string;\n\tprivate languagePacksFileLimiter: Queue<any>;\n\tprivate initializedCache: boolean | undefined;\n\n\tconstructor(\n\t\t@INativeEnvironmentService environmentService: INativeEnvironmentService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis.languagePacksFilePath = join(environmentService.userDataPath, 'languagepacks.json');\n\t\tthis.languagePacksFileLimiter = new Queue();\n\t}\n\n\tgetLanguagePacks(): Promise<{ [language: string]: ILanguagePack }> {\n\t\t// if queue is not empty, fetch from disk\n\t\tif (this.languagePacksFileLimiter.size || !this.initializedCache) {\n\t\t\treturn this.withLanguagePacks()\n\t\t\t\t.then(() => this.languagePacks);\n\t\t}\n\t\treturn Promise.resolve(this.languagePacks);\n\t}\n\n\tupdate(extensions: ILocalExtension[]): Promise<{ [language: string]: ILanguagePack }> {\n\t\treturn this.withLanguagePacks(languagePacks => {\n\t\t\tObject.keys(languagePacks).forEach(language => delete languagePacks[language]);\n\t\t\tthis.createLanguagePacksFromExtensions(languagePacks, ...extensions);\n\t\t}).then(() => this.languagePacks);\n\t}\n\n\tprivate createLanguagePacksFromExtensions(languagePacks: { [language: string]: ILanguagePack }, ...extensions: ILocalExtension[]): void {\n\t\tfor (const extension of extensions) {\n\t\t\tif (extension && extension.manifest && extension.manifest.contributes && extension.manifest.contributes.localizations && extension.manifest.contributes.localizations.length) {\n\t\t\t\tthis.createLanguagePacksFromExtension(languagePacks, extension);\n\t\t\t}\n\t\t}\n\t\tObject.keys(languagePacks).forEach(languageId => this.updateHash(languagePacks[languageId]));\n\t}\n\n\tprivate createLanguagePacksFromExtension(languagePacks: { [language: string]: ILanguagePack }, extension: ILocalExtension): void {\n\t\tconst extensionIdentifier = extension.identifier;\n\t\tconst localizations = extension.manifest.contributes && extension.manifest.contributes.localizations ? extension.manifest.contributes.localizations : [];\n\t\tfor (const localizationContribution of localizations) {\n\t\t\tif (extension.location.scheme === Schemas.file && isValidLocalization(localizationContribution)) {\n\t\t\t\tlet languagePack = languagePacks[localizationContribution.languageId];\n\t\t\t\tif (!languagePack) {\n\t\t\t\t\tlanguagePack = { hash: '', extensions: [], translations: {} };\n\t\t\t\t\tlanguagePacks[localizationContribution.languageId] = languagePack;\n\t\t\t\t}\n\t\t\t\tlet extensionInLanguagePack = languagePack.extensions.filter(e => areSameExtensions(e.extensionIdentifier, extensionIdentifier))[0];\n\t\t\t\tif (extensionInLanguagePack) {\n\t\t\t\t\textensionInLanguagePack.version = extension.manifest.version;\n\t\t\t\t} else {\n\t\t\t\t\tlanguagePack.extensions.push({ extensionIdentifier, version: extension.manifest.version });\n\t\t\t\t}\n\t\t\t\tfor (const translation of localizationContribution.translations) {\n\t\t\t\t\tlanguagePack.translations[translation.id] = join(extension.location.fsPath, translation.path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate updateHash(languagePack: ILanguagePack): void {\n\t\tif (languagePack) {\n\t\t\tconst md5 = createHash('md5');\n\t\t\tfor (const extension of languagePack.extensions) {\n\t\t\t\tmd5.update(extension.extensionIdentifier.uuid || extension.extensionIdentifier.id).update(extension.version);\n\t\t\t}\n\t\t\tlanguagePack.hash = md5.digest('hex');\n\t\t}\n\t}\n\n\tprivate withLanguagePacks<T>(fn: (languagePacks: { [language: string]: ILanguagePack }) => T | null = () => null): Promise<T> {\n\t\treturn this.languagePacksFileLimiter.queue(() => {\n\t\t\tlet result: T | null = null;\n\t\t\treturn promises.readFile(this.languagePacksFilePath, 'utf8')\n\t\t\t\t.then(undefined, err => err.code === 'ENOENT' ? Promise.resolve('{}') : Promise.reject(err))\n\t\t\t\t.then<{ [language: string]: ILanguagePack }>(raw => { try { return JSON.parse(raw); } catch (e) { return {}; } })\n\t\t\t\t.then(languagePacks => { result = fn(languagePacks); return languagePacks; })\n\t\t\t\t.then(languagePacks => {\n\t\t\t\t\tfor (const language of Object.keys(languagePacks)) {\n\t\t\t\t\t\tif (!languagePacks[language]) {\n\t\t\t\t\t\t\tdelete languagePacks[language];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.languagePacks = languagePacks;\n\t\t\t\t\tthis.initializedCache = true;\n\t\t\t\t\tconst raw = JSON.stringify(this.languagePacks);\n\t\t\t\t\tthis.logService.debug('Writing language packs', raw);\n\t\t\t\t\treturn writeFile(this.languagePacksFilePath, raw);\n\t\t\t\t})\n\t\t\t\t.then(() => result, error => this.logService.error(error));\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LogLevel, ILogger, AbstractMessageLogger } from 'vs/platform/log/common/log';\nimport * as spdlog from 'spdlog';\nimport { ByteSize } from 'vs/platform/files/common/files';\n\nasync function createSpdLogLogger(name: string, logfilePath: string, filesize: number, filecount: number): Promise<spdlog.RotatingLogger | null> {\n\t// Do not crash if spdlog cannot be loaded\n\ttry {\n\t\tconst _spdlog = await import('spdlog');\n\t\t_spdlog.setAsyncMode(8192, 500);\n\t\treturn _spdlog.createRotatingLoggerAsync(name, logfilePath, filesize, filecount);\n\t} catch (e) {\n\t\tconsole.error(e);\n\t}\n\treturn null;\n}\n\nexport function createRotatingLogger(name: string, filename: string, filesize: number, filecount: number): spdlog.RotatingLogger {\n\tconst _spdlog: typeof spdlog = require.__$__nodeRequire('spdlog');\n\treturn _spdlog.createRotatingLogger(name, filename, filesize, filecount);\n}\n\ninterface ILog {\n\tlevel: LogLevel;\n\tmessage: string;\n}\n\nfunction log(logger: spdlog.RotatingLogger, level: LogLevel, message: string): void {\n\tswitch (level) {\n\t\tcase LogLevel.Trace: logger.trace(message); break;\n\t\tcase LogLevel.Debug: logger.debug(message); break;\n\t\tcase LogLevel.Info: logger.info(message); break;\n\t\tcase LogLevel.Warning: logger.warn(message); break;\n\t\tcase LogLevel.Error: logger.error(message); break;\n\t\tcase LogLevel.Critical: logger.critical(message); break;\n\t\tdefault: throw new Error('Invalid log level');\n\t}\n}\n\nexport class SpdLogLogger extends AbstractMessageLogger implements ILogger {\n\n\tprivate buffer: ILog[] = [];\n\tprivate readonly _loggerCreationPromise: Promise<void>;\n\tprivate _logger: spdlog.RotatingLogger | undefined;\n\n\tconstructor(\n\t\tprivate readonly name: string,\n\t\tprivate readonly filepath: string,\n\t\tprivate readonly rotating: boolean,\n\t\tlevel: LogLevel\n\t) {\n\t\tsuper();\n\t\tthis.setLevel(level);\n\t\tthis._loggerCreationPromise = this._createSpdLogLogger();\n\t\tthis._register(this.onDidChangeLogLevel(level => {\n\t\t\tif (this._logger) {\n\t\t\t\tthis._logger.setLevel(level);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate _createSpdLogLogger(): Promise<void> {\n\t\tconst filecount = this.rotating ? 6 : 1;\n\t\tconst filesize = (30 / filecount) * ByteSize.MB;\n\t\treturn createSpdLogLogger(this.name, this.filepath, filesize, filecount)\n\t\t\t.then(logger => {\n\t\t\t\tif (logger) {\n\t\t\t\t\tthis._logger = logger;\n\t\t\t\t\tthis._logger.setLevel(this.getLevel());\n\t\t\t\t\tfor (const { level, message } of this.buffer) {\n\t\t\t\t\t\tlog(this._logger, level, message);\n\t\t\t\t\t}\n\t\t\t\t\tthis.buffer = [];\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tprotected log(level: LogLevel, message: string): void {\n\t\tif (this._logger) {\n\t\t\tlog(this._logger, level, message);\n\t\t} else if (this.getLevel() <= level) {\n\t\t\tthis.buffer.push({ level, message });\n\t\t}\n\t}\n\n\tclearFormatters(): void {\n\t\tif (this._logger) {\n\t\t\tthis._logger.clearFormatters();\n\t\t} else {\n\t\t\tthis._loggerCreationPromise.then(() => this.clearFormatters());\n\t\t}\n\t}\n\n\toverride flush(): void {\n\t\tif (this._logger) {\n\t\t\tthis._logger.flush();\n\t\t} else {\n\t\t\tthis._loggerCreationPromise.then(() => this.flush());\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tif (this._logger) {\n\t\t\tthis.disposeLogger();\n\t\t} else {\n\t\t\tthis._loggerCreationPromise.then(() => this.disposeLogger());\n\t\t}\n\t}\n\n\tprivate disposeLogger(): void {\n\t\tif (this._logger) {\n\t\t\tthis._logger.drop();\n\t\t\tthis._logger = undefined;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { URI } from 'vs/base/common/uri';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IFileSystemProviderWithOpenReadWriteCloseCapability, FileReadStreamOptions, createFileSystemProviderError, FileSystemProviderErrorCode, ensureFileSystemProviderError } from 'vs/platform/files/common/files';\nimport { canceled } from 'vs/base/common/errors';\nimport { IErrorTransformer, IDataTransformer, WriteableStream } from 'vs/base/common/stream';\nimport product from 'vs/platform/product/common/product';\n\nexport interface ICreateReadStreamOptions extends FileReadStreamOptions {\n\n\t/**\n\t * The size of the buffer to use before sending to the stream.\n\t */\n\tbufferSize: number;\n\n\t/**\n\t * Allows to massage any possibly error that happens during reading.\n\t */\n\terrorTransformer?: IErrorTransformer;\n}\n\n/**\n * A helper to read a file from a provider with open/read/close capability into a stream.\n */\nexport async function readFileIntoStream<T>(\n\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\tresource: URI,\n\ttarget: WriteableStream<T>,\n\ttransformer: IDataTransformer<VSBuffer, T>,\n\toptions: ICreateReadStreamOptions,\n\ttoken: CancellationToken\n): Promise<void> {\n\tlet error: Error | undefined = undefined;\n\n\ttry {\n\t\tawait doReadFileIntoStream(provider, resource, target, transformer, options, token);\n\t} catch (err) {\n\t\terror = err;\n\t} finally {\n\t\tif (error && options.errorTransformer) {\n\t\t\terror = options.errorTransformer(error);\n\t\t}\n\n\t\tif (typeof error !== 'undefined') {\n\t\t\ttarget.error(error);\n\t\t}\n\n\t\ttarget.end();\n\t}\n}\n\nasync function doReadFileIntoStream<T>(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, target: WriteableStream<T>, transformer: IDataTransformer<VSBuffer, T>, options: ICreateReadStreamOptions, token: CancellationToken): Promise<void> {\n\n\t// Check for cancellation\n\tthrowIfCancelled(token);\n\n\t// open handle through provider\n\tconst handle = await provider.open(resource, { create: false });\n\n\ttry {\n\n\t\t// Check for cancellation\n\t\tthrowIfCancelled(token);\n\n\t\tlet totalBytesRead = 0;\n\t\tlet bytesRead = 0;\n\t\tlet allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;\n\n\t\tlet buffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n\t\tlet posInFile = options && typeof options.position === 'number' ? options.position : 0;\n\t\tlet posInBuffer = 0;\n\t\tdo {\n\t\t\t// read from source (handle) at current position (pos) into buffer (buffer) at\n\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\tbytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\tposInFile += bytesRead;\n\t\t\tposInBuffer += bytesRead;\n\t\t\ttotalBytesRead += bytesRead;\n\n\t\t\tif (typeof allowedRemainingBytes === 'number') {\n\t\t\t\tallowedRemainingBytes -= bytesRead;\n\t\t\t}\n\n\t\t\t// when buffer full, create a new one and emit it through stream\n\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\tawait target.write(transformer(buffer));\n\n\t\t\t\tbuffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n\t\t\t\tposInBuffer = 0;\n\t\t\t}\n\t\t} while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));\n\n\t\t// wrap up with last buffer (also respect maxBytes if provided)\n\t\tif (posInBuffer > 0) {\n\t\t\tlet lastChunkLength = posInBuffer;\n\t\t\tif (typeof allowedRemainingBytes === 'number') {\n\t\t\t\tlastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\n\t\t\t}\n\n\t\t\ttarget.write(transformer(buffer.slice(0, lastChunkLength)));\n\t\t}\n\t} catch (error) {\n\t\tthrow ensureFileSystemProviderError(error);\n\t} finally {\n\t\tawait provider.close(handle);\n\t}\n}\n\nfunction throwIfCancelled(token: CancellationToken): boolean {\n\tif (token.isCancellationRequested) {\n\t\tthrow canceled();\n\t}\n\n\treturn true;\n}\n\nfunction throwIfTooLarge(totalBytesRead: number, options: ICreateReadStreamOptions): boolean {\n\n\t// Return early if file is too large to load and we have configured limits\n\tif (options?.limits) {\n\t\tif (typeof options.limits.memory === 'number' && totalBytesRead > options.limits.memory) {\n\t\t\tthrow createFileSystemProviderError(localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart and allow {0} to use more memory\", product.nameShort), FileSystemProviderErrorCode.FileExceedsMemoryLimit);\n\t\t}\n\n\t\tif (typeof options.limits.size === 'number' && totalBytesRead > options.limits.size) {\n\t\t\tthrow createFileSystemProviderError(localize('fileTooLargeError', \"File is too large to open\"), FileSystemProviderErrorCode.FileTooLarge);\n\t\t}\n\t}\n\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { mark } from 'vs/base/common/performance';\nimport { Disposable, IDisposable, toDisposable, dispose, DisposableStore } from 'vs/base/common/lifecycle';\nimport { IFileService, IResolveFileOptions, FileChangesEvent, FileOperationEvent, IFileSystemProviderRegistrationEvent, IFileSystemProvider, IFileStat, IResolveFileResult, ICreateFileOptions, IFileSystemProviderActivationEvent, FileOperationError, FileOperationResult, FileOperation, FileSystemProviderCapabilities, FileType, toFileSystemProviderErrorCode, FileSystemProviderErrorCode, IStat, IFileStatWithMetadata, IResolveMetadataFileOptions, etag, hasReadWriteCapability, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, toFileOperationResult, IFileSystemProviderWithOpenReadWriteCloseCapability, IFileSystemProviderWithFileReadWriteCapability, IResolveFileResultWithMetadata, IWatchOptions, IWriteFileOptions, IReadFileOptions, IFileStreamContent, IFileContent, ETAG_DISABLED, hasFileReadStreamCapability, IFileSystemProviderWithFileReadStreamCapability, ensureFileSystemProviderError, IFileSystemProviderCapabilitiesChangeEvent, IReadFileStreamOptions, FileDeleteOptions } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { Emitter } from 'vs/base/common/event';\nimport { IExtUri, extUri, extUriIgnorePathCase, isAbsolutePath } from 'vs/base/common/resources';\nimport { TernarySearchTree } from 'vs/base/common/map';\nimport { isNonEmptyArray, coalesce } from 'vs/base/common/arrays';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { VSBuffer, VSBufferReadable, readableToBuffer, bufferToReadable, streamToBuffer, VSBufferReadableStream, VSBufferReadableBufferedStream, bufferedStreamToBuffer, newWriteableBufferStream } from 'vs/base/common/buffer';\nimport { isReadableStream, transform, peekReadable, peekStream, isReadableBufferedStream, newWriteableStream, listenStream, consumeStream } from 'vs/base/common/stream';\nimport { Promises, ResourceQueue } from 'vs/base/common/async';\nimport { CancellationTokenSource, CancellationToken } from 'vs/base/common/cancellation';\nimport { Schemas } from 'vs/base/common/network';\nimport { readFileIntoStream } from 'vs/platform/files/common/io';\nimport { Iterable } from 'vs/base/common/iterator';\n\nexport class FileService extends Disposable implements IFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly BUFFER_SIZE = 64 * 1024;\n\n\tconstructor(@ILogService private readonly logService: ILogService) {\n\t\tsuper();\n\t}\n\n\t//#region File System Provider\n\n\tprivate readonly _onDidChangeFileSystemProviderRegistrations = this._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\treadonly onDidChangeFileSystemProviderRegistrations = this._onDidChangeFileSystemProviderRegistrations.event;\n\n\tprivate readonly _onWillActivateFileSystemProvider = this._register(new Emitter<IFileSystemProviderActivationEvent>());\n\treadonly onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities = this._register(new Emitter<IFileSystemProviderCapabilitiesChangeEvent>());\n\treadonly onDidChangeFileSystemProviderCapabilities = this._onDidChangeFileSystemProviderCapabilities.event;\n\n\tprivate readonly provider = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable {\n\t\tif (this.provider.has(scheme)) {\n\t\t\tthrow new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n\t\t}\n\n\t\tmark(`code/registerFilesystem/${scheme}`);\n\n\t\t// Add provider with event\n\t\tthis.provider.set(scheme, provider);\n\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });\n\n\t\t// Forward events from provider\n\t\tconst providerDisposables = new DisposableStore();\n\t\tproviderDisposables.add(provider.onDidChangeFile(changes => this._onDidFilesChange.fire(new FileChangesEvent(changes, !this.isPathCaseSensitive(provider)))));\n\t\tproviderDisposables.add(provider.onDidChangeCapabilities(() => this._onDidChangeFileSystemProviderCapabilities.fire({ provider, scheme })));\n\t\tif (typeof provider.onDidErrorOccur === 'function') {\n\t\t\tproviderDisposables.add(provider.onDidErrorOccur(error => this._onError.fire(new Error(error))));\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });\n\t\t\tthis.provider.delete(scheme);\n\n\t\t\tdispose(providerDisposables);\n\t\t});\n\t}\n\n\tgetProvider(scheme: string): IFileSystemProvider | undefined {\n\t\treturn this.provider.get(scheme);\n\t}\n\n\tasync activateProvider(scheme: string): Promise<void> {\n\n\t\t// Emit an event that we are about to activate a provider with the given scheme.\n\t\t// Listeners can participate in the activation by registering a provider for it.\n\t\tconst joiners: Promise<void>[] = [];\n\t\tthis._onWillActivateFileSystemProvider.fire({\n\t\t\tscheme,\n\t\t\tjoin(promise) {\n\t\t\t\tjoiners.push(promise);\n\t\t\t},\n\t\t});\n\n\t\tif (this.provider.has(scheme)) {\n\t\t\treturn; // provider is already here so we can return directly\n\t\t}\n\n\t\t// If the provider is not yet there, make sure to join on the listeners assuming\n\t\t// that it takes a bit longer to register the file system provider.\n\t\tawait Promises.settled(joiners);\n\t}\n\n\tcanHandleResource(resource: URI): boolean {\n\t\treturn this.provider.has(resource.scheme);\n\t}\n\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n\t\tconst provider = this.provider.get(resource.scheme);\n\n\t\treturn !!(provider && (provider.capabilities & capability));\n\t}\n\n\tlistCapabilities(): Iterable<{ scheme: string, capabilities: FileSystemProviderCapabilities; }> {\n\t\treturn Iterable.map(this.provider, ([scheme, provider]) => ({ scheme, capabilities: provider.capabilities }));\n\t}\n\n\tprotected async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\n\t\t// Assert path is absolute\n\t\tif (!isAbsolutePath(resource)) {\n\t\t\tthrow new FileOperationError(localize('invalidPath', \"Unable to resolve filesystem provider with relative file path '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_INVALID_PATH);\n\t\t}\n\n\t\t// Activate provider\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\t// Assert provider\n\t\tconst provider = this.provider.get(resource.scheme);\n\t\tif (!provider) {\n\t\t\tconst error = new Error();\n\t\t\terror.name = 'ENOPRO';\n\t\t\terror.message = localize('noProviderFound', \"No file system provider found for resource '{0}'\", resource.toString());\n\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate async withReadProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) || hasFileReadStreamCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n\t}\n\n\tprivate async withWriteProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n\t}\n\n\t//#endregion\n\n\tprivate readonly _onDidRunOperation = this._register(new Emitter<FileOperationEvent>());\n\treadonly onDidRunOperation = this._onDidRunOperation.event;\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\treadonly onError = this._onError.event;\n\n\t//#region File Metadata Resolving\n\n\tasync resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\ttry {\n\t\t\treturn await this.doResolveFile(resource, options);\n\t\t} catch (error) {\n\n\t\t\t// Specially handle file not found case as file operation result\n\t\t\tif (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\tthrow new FileOperationError(localize('fileNotFoundError', \"Unable to resolve non-existing file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Bubble up any other error as is\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async doResolveFile(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\tconst resolveTo = options?.resolveTo;\n\t\tconst resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n\t\tconst resolveMetadata = options?.resolveMetadata;\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\tlet trie: TernarySearchTree<URI, boolean> | undefined;\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n\t\t\t// lazy trie to check for recursive resolving\n\t\t\tif (!trie) {\n\t\t\t\ttrie = TernarySearchTree.forUris<true>(() => !isPathCaseSensitive);\n\t\t\t\ttrie.set(resource, true);\n\t\t\t\tif (isNonEmptyArray(resolveTo)) {\n\t\t\t\t\tresolveTo.forEach(uri => trie!.set(uri, true));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check for recursive resolving\n\t\t\tif (Boolean(trie.findSuperstr(stat.resource) || trie.get(stat.resource))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check for resolving single child folders\n\t\t\tif (stat.isDirectory && resolveSingleChildDescendants) {\n\t\t\t\treturn siblings === 1;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType; } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStatWithMetadata>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType; } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat> {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\t// convert to file stat\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource,\n\t\t\tname: providerExtUri.basename(resource),\n\t\t\tisFile: (stat.type & FileType.File) !== 0,\n\t\t\tisDirectory: (stat.type & FileType.Directory) !== 0,\n\t\t\tisSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n\t\t\tmtime: stat.mtime,\n\t\t\tctime: stat.ctime,\n\t\t\tsize: stat.size,\n\t\t\tetag: etag({ mtime: stat.mtime, size: stat.size })\n\t\t};\n\n\t\t// check to recurse for directories\n\t\tif (fileStat.isDirectory && recurse(fileStat, siblings)) {\n\t\t\ttry {\n\t\t\t\tconst entries = await provider.readdir(resource);\n\t\t\t\tconst resolvedEntries = await Promises.settled(entries.map(async ([name, type]) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst childResource = providerExtUri.joinPath(resource, name);\n\t\t\t\t\t\tconst childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n\t\t\t\t\t\treturn await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t\treturn null; // can happen e.g. due to permission errors\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// make sure to get rid of null values that signal a failure to resolve a particular entry\n\t\t\t\tfileStat.children = coalesce(resolvedEntries);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\tfileStat.children = []; // gracefully handle errors, we may not have permissions to read\n\t\t\t}\n\n\t\t\treturn fileStat;\n\t\t}\n\n\t\treturn fileStat;\n\t}\n\n\tasync resolveAll(toResolve: { resource: URI, options?: IResolveFileOptions; }[]): Promise<IResolveFileResult[]>;\n\tasync resolveAll(toResolve: { resource: URI, options: IResolveMetadataFileOptions; }[]): Promise<IResolveFileResultWithMetadata[]>;\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions; }[]): Promise<IResolveFileResult[]> {\n\t\treturn Promises.settled(toResolve.map(async entry => {\n\t\t\ttry {\n\t\t\t\treturn { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\treturn { stat: undefined, success: false };\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync exists(resource: URI): Promise<boolean> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\ttry {\n\t\t\tconst stat = await provider.stat(resource);\n\n\t\t\treturn !!stat;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateCreateFile(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateCreateFile(resource: URI, options?: ICreateFileOptions): Promise<void> {\n\n\t\t// validate overwrite\n\t\tif (!options?.overwrite && await this.exists(resource)) {\n\t\t\tthrow new FileOperationError(localize('fileExists', \"Unable to create file '{0}' that already exists when overwrite flag is not set\", this.resourceForError(resource)), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\t}\n\n\tasync createFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream = VSBuffer.fromString(''), options?: ICreateFileOptions): Promise<IFileStatWithMetadata> {\n\n\t\t// validate\n\t\tawait this.doValidateCreateFile(resource, options);\n\n\t\t// do write into file (this will create it too)\n\t\tconst fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n\t\t// events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\ttry {\n\n\t\t\t// validate write\n\t\t\tconst stat = await this.validateWriteFile(provider, resource, options);\n\n\t\t\t// mkdir recursively as needed\n\t\t\tif (!stat) {\n\t\t\t\tawait this.mkdirp(provider, providerExtUri.dirname(resource));\n\t\t\t}\n\n\t\t\t// optimization: if the provider has unbuffered write capability and the data\n\t\t\t// to write is a Readable, we consume up to 3 chunks and try to write the data\n\t\t\t// unbuffered to reduce the overhead. If the Readable has more data to provide\n\t\t\t// we continue to write buffered.\n\t\t\tlet bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream;\n\t\t\tif (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof VSBuffer)) {\n\t\t\t\tif (isReadableStream(bufferOrReadableOrStream)) {\n\t\t\t\t\tconst bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n\t\t\t\t\tif (bufferedStream.ended) {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = VSBuffer.concat(bufferedStream.buffer);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferedStream;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => VSBuffer.concat(data), 3);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\n\t\t\t}\n\n\t\t\t// write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\n\t\t\tif (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer)) {\n\t\t\t\tawait this.doWriteUnbuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\n\t\t\t// write file: buffered\n\t\t\telse {\n\t\t\t\tawait this.doWriteBuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer ? bufferToReadable(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new FileOperationError(localize('err.write', \"Unable to write file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options);\n\t\t}\n\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\tprivate async validateWriteFile(provider: IFileSystemProvider, resource: URI, options?: IWriteFileOptions): Promise<IStat | undefined> {\n\n\t\t// Validate unlock support\n\t\tconst unlock = !!options?.unlock;\n\t\tif (unlock && !(provider.capabilities & FileSystemProviderCapabilities.FileWriteUnlock)) {\n\t\t\tthrow new Error(localize('writeFailedUnlockUnsupported', \"Unable to unlock file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate via file stat meta data\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined; // file might not exist\n\t\t}\n\n\t\t// File cannot be directory\n\t\tif ((stat.type & FileType.Directory) !== 0) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryWriteError', \"Unable to write file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// Dirty write prevention: if the file on disk has been changed and does not match our expected\n\t\t// mtime and etag, we bail out to prevent dirty writing.\n\t\t//\n\t\t// First, we check for a mtime that is in the future before we do more checks. The assumption is\n\t\t// that only the mtime is an indicator for a file that has changed on disk.\n\t\t//\n\t\t// Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n\t\t// one using the etag() function. Relying only on the mtime check has prooven to produce false\n\t\t// positives due to file system weirdness (especially around remote file systems). As such, the\n\t\t// check for size is a weaker check because it can return a false negative if the file has changed\n\t\t// but to the same length. This is a compromise we take to avoid having to produce checksums of\n\t\t// the file content for comparison which would be much slower to compute.\n\t\tif (\n\t\t\toptions && typeof options.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n\t\t\ttypeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n\t\t\toptions.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size })\n\t\t) {\n\t\t\tthrow new FileOperationError(localize('fileModifiedError', \"File Modified Since\"), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\tasync readFile(resource: URI, options?: IReadFileOptions): Promise<IFileContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\tif (options?.atomic) {\n\t\t\treturn this.doReadFileAtomic(provider, resource, options);\n\t\t}\n\n\t\treturn this.doReadFile(provider, resource, options);\n\t}\n\n\tprivate async doReadFileAtomic(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions): Promise<IFileContent> {\n\t\treturn new Promise<IFileContent>((resolve, reject) => {\n\t\t\tthis.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.doReadFile(provider, resource, options);\n\t\t\t\t\tresolve(content);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doReadFile(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions): Promise<IFileContent> {\n\t\tconst stream = await this.doReadFileStream(provider, resource, {\n\t\t\t...options,\n\t\t\t// optimization: since we know that the caller does not\n\t\t\t// care about buffering, we indicate this to the reader.\n\t\t\t// this reduces all the overhead the buffered reading\n\t\t\t// has (open, read, close) if the provider supports\n\t\t\t// unbuffered reading.\n\t\t\tpreferUnbuffered: true\n\t\t});\n\n\t\treturn {\n\t\t\t...stream,\n\t\t\tvalue: await streamToBuffer(stream.value)\n\t\t};\n\t}\n\n\tasync readFileStream(resource: URI, options?: IReadFileStreamOptions): Promise<IFileStreamContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\treturn this.doReadFileStream(provider, resource, options);\n\t}\n\n\tprivate async doReadFileStream(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileStreamOptions & { preferUnbuffered?: boolean; }): Promise<IFileStreamContent> {\n\n\t\t// install a cancellation token that gets cancelled\n\t\t// when any error occurs. this allows us to resolve\n\t\t// the content of the file while resolving metadata\n\t\t// but still cancel the operation in certain cases.\n\t\tconst cancellableSource = new CancellationTokenSource();\n\n\t\t// validate read operation\n\t\tconst statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\n\t\t\tcancellableSource.cancel();\n\n\t\t\tthrow error;\n\t\t});\n\n\t\tlet fileStream: VSBufferReadableStream | undefined = undefined;\n\t\ttry {\n\n\t\t\t// if the etag is provided, we await the result of the validation\n\t\t\t// due to the likelihood of hitting a NOT_MODIFIED_SINCE result.\n\t\t\t// otherwise, we let it run in parallel to the file reading for\n\t\t\t// optimal startup performance.\n\t\t\tif (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED) {\n\t\t\t\tawait statPromise;\n\t\t\t}\n\n\t\t\t// read unbuffered (only if either preferred, or the provider has no buffered read capability)\n\t\t\tif (!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || (hasReadWriteCapability(provider) && options?.preferUnbuffered)) {\n\t\t\t\tfileStream = this.readFileUnbuffered(provider, resource, options);\n\t\t\t}\n\n\t\t\t// read streamed (always prefer over primitive buffered read)\n\t\t\telse if (hasFileReadStreamCapability(provider)) {\n\t\t\t\tfileStream = this.readFileStreamed(provider, resource, cancellableSource.token, options);\n\t\t\t}\n\n\t\t\t// read buffered\n\t\t\telse {\n\t\t\t\tfileStream = this.readFileBuffered(provider, resource, cancellableSource.token, options);\n\t\t\t}\n\n\t\t\tconst fileStat = await statPromise;\n\n\t\t\treturn {\n\t\t\t\t...fileStat,\n\t\t\t\tvalue: fileStream\n\t\t\t};\n\t\t} catch (error) {\n\n\t\t\t// Await the stream to finish so that we exit this method\n\t\t\t// in a consistent state with file handles closed\n\t\t\t// (https://github.com/microsoft/vscode/issues/114024)\n\t\t\tif (fileStream) {\n\t\t\t\tawait consumeStream(fileStream);\n\t\t\t}\n\n\t\t\tthrow new FileOperationError(localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options);\n\t\t}\n\t}\n\n\tprivate readFileStreamed(provider: IFileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst fileStream = provider.readFileStream(resource, options, token);\n\n\t\treturn transform(fileStream, {\n\t\t\tdata: data => data instanceof VSBuffer ? data : VSBuffer.wrap(data),\n\t\t\terror: error => new FileOperationError(localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options)\n\t\t}, data => VSBuffer.concat(data));\n\t}\n\n\tprivate readFileBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\n\t\treadFileIntoStream(provider, resource, stream, data => data, {\n\t\t\t...options,\n\t\t\tbufferSize: this.BUFFER_SIZE,\n\t\t\terrorTransformer: error => new FileOperationError(localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options)\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tprivate readFileUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options?: IReadFileStreamOptions): VSBufferReadableStream {\n\t\tconst stream = newWriteableStream<VSBuffer>(data => VSBuffer.concat(data));\n\n\t\t// Read the file into the stream async but do not wait for\n\t\t// this to complete because streams work via events\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tlet buffer = await provider.readFile(resource);\n\n\t\t\t\t// respect position option\n\t\t\t\tif (options && typeof options.position === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(options.position);\n\t\t\t\t}\n\n\t\t\t\t// respect length option\n\t\t\t\tif (options && typeof options.length === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(0, options.length);\n\t\t\t\t}\n\n\t\t\t\t// Throw if file is too large to load\n\t\t\t\tthis.validateReadFileLimits(resource, buffer.byteLength, options);\n\n\t\t\t\t// End stream with data\n\t\t\t\tstream.end(VSBuffer.wrap(buffer));\n\t\t\t} catch (err) {\n\t\t\t\tstream.error(err);\n\t\t\t\tstream.end();\n\t\t\t}\n\t\t})();\n\n\t\treturn stream;\n\t}\n\n\tprivate async validateReadFile(resource: URI, options?: IReadFileStreamOptions): Promise<IFileStatWithMetadata> {\n\t\tconst stat = await this.resolve(resource, { resolveMetadata: true });\n\n\t\t// Throw if resource is a directory\n\t\tif (stat.isDirectory) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryReadError', \"Unable to read file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// Throw if file not modified since (unless disabled)\n\t\tif (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n\t\t\tthrow new FileOperationError(localize('fileNotModifiedError', \"File not modified since\"), FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n\t\t}\n\n\t\t// Throw if file is too large to load\n\t\tthis.validateReadFileLimits(resource, stat.size, options);\n\n\t\treturn stat;\n\t}\n\n\tprivate validateReadFileLimits(resource: URI, size: number, options?: IReadFileStreamOptions): void {\n\t\tif (options?.limits) {\n\t\t\tlet tooLargeErrorResult: FileOperationResult | undefined = undefined;\n\n\t\t\tif (typeof options.limits.memory === 'number' && size > options.limits.memory) {\n\t\t\t\ttooLargeErrorResult = FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n\t\t\t}\n\n\t\t\tif (typeof options.limits.size === 'number' && size > options.limits.size) {\n\t\t\t\ttooLargeErrorResult = FileOperationResult.FILE_TOO_LARGE;\n\t\t\t}\n\n\t\t\tif (typeof tooLargeErrorResult === 'number') {\n\t\t\t\tthrow new FileOperationError(localize('fileTooLargeError', \"Unable to read file '{0}' that is too large to open\", this.resourceForError(resource)), tooLargeErrorResult);\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'move', overwrite);\n\t}\n\n\tasync canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'copy', overwrite);\n\t}\n\n\tprivate async doCanMoveCopy(source: URI, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<Error | true> {\n\t\tif (source.toString() !== target.toString()) {\n\t\t\ttry {\n\t\t\t\tconst sourceProvider = mode === 'move' ? this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source) : await this.withReadProvider(source);\n\t\t\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t\t\tawait this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\t\t\t} catch (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// move\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = await this.withReadProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// copy\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async doMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n\t\tif (source.toString() === target.toString()) {\n\t\t\treturn mode; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\t// validation\n\t\tconst { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n\t\t// delete as needed (unless target is same resurce with different path case)\n\t\tif (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n\t\t\tawait this.del(target, { recursive: true });\n\t\t}\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// copy source => target\n\t\tif (mode === 'copy') {\n\n\t\t\t// same provider with fast copy: leverage copy() functionality\n\t\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\t\tawait sourceProvider.copy(source, target, { overwrite });\n\t\t\t}\n\n\t\t\t// when copying via buffer/unbuffered, we have to manually\n\t\t\t// traverse the source if it is a folder and not a file\n\t\t\telse {\n\t\t\t\tconst sourceFile = await this.resolve(source);\n\t\t\t\tif (sourceFile.isDirectory) {\n\t\t\t\t\tawait this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doCopyFile(sourceProvider, source, targetProvider, target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mode;\n\t\t}\n\n\t\t// move source => target\n\t\telse {\n\n\t\t\t// same provider: leverage rename() functionality\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tawait sourceProvider.rename(source, target, { overwrite });\n\n\t\t\t\treturn mode;\n\t\t\t}\n\n\t\t\t// across providers: copy to target & delete at source\n\t\t\telse {\n\t\t\t\tawait this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\t\t\t\tawait this.del(source, { recursive: true });\n\n\t\t\t\treturn 'copy';\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doCopyFile(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI): Promise<void> {\n\n\t\t// copy: source (buffered) => target (buffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (buffered) => target (unbuffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (buffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (unbuffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\t}\n\n\tprivate async doCopyFolder(sourceProvider: IFileSystemProvider, sourceFolder: IFileStat, targetProvider: IFileSystemProvider, targetFolder: URI): Promise<void> {\n\n\t\t// create folder in target\n\t\tawait targetProvider.mkdir(targetFolder);\n\n\t\t// create children in target\n\t\tif (Array.isArray(sourceFolder.children)) {\n\t\t\tawait Promises.settled(sourceFolder.children.map(async sourceChild => {\n\t\t\t\tconst targetChild = this.getExtUri(targetProvider).providerExtUri.joinPath(targetFolder, sourceChild.name);\n\t\t\t\tif (sourceChild.isDirectory) {\n\t\t\t\t\treturn this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async doValidateMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean, isSameResourceWithDifferentPathCase: boolean; }> {\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\n\t\t// Check if source is equal or parent to target (requires providers to be the same)\n\t\tif (sourceProvider === targetProvider) {\n\t\t\tconst { providerExtUri, isPathCaseSensitive } = this.getExtUri(sourceProvider);\n\t\t\tif (!isPathCaseSensitive) {\n\t\t\t\tisSameResourceWithDifferentPathCase = providerExtUri.isEqual(source, target);\n\t\t\t}\n\n\t\t\tif (isSameResourceWithDifferentPathCase && mode === 'copy') {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError1', \"Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\n\t\t\tif (!isSameResourceWithDifferentPathCase && providerExtUri.isEqualOrParent(target, source)) {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError2', \"Unable to move/copy when source '{0}' is parent of target '{1}'.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\t\t}\n\n\t\t// Extra checks if target exists and this is not a rename\n\t\tconst exists = await this.exists(target);\n\t\tif (exists && !isSameResourceWithDifferentPathCase) {\n\n\t\t\t// Bail out if target exists and we are not about to overwrite\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(localize('unableToMoveCopyError3', \"Unable to move/copy '{0}' because target '{1}' already exists at destination.\", this.resourceForError(source), this.resourceForError(target)), FileOperationResult.FILE_MOVE_CONFLICT);\n\t\t\t}\n\n\t\t\t// Special case: if the target is a parent of the source, we cannot delete\n\t\t\t// it as it would delete the source as well. In this case we have to throw\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tconst { providerExtUri } = this.getExtUri(sourceProvider);\n\t\t\t\tif (providerExtUri.isEqualOrParent(source, target)) {\n\t\t\t\t\tthrow new Error(localize('unableToMoveCopyError4', \"Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { exists, isSameResourceWithDifferentPathCase };\n\t}\n\n\tprivate getExtUri(provider: IFileSystemProvider): { providerExtUri: IExtUri, isPathCaseSensitive: boolean; } {\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\treturn {\n\t\t\tproviderExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,\n\t\t\tisPathCaseSensitive\n\t\t};\n\t}\n\n\tprivate isPathCaseSensitive(provider: IFileSystemProvider): boolean {\n\t\treturn !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t}\n\n\tasync createFolder(resource: URI): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// mkdir recursively\n\t\tawait this.mkdirp(provider, resource);\n\n\t\t// events\n\t\tconst fileStat = await this.resolve(resource, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async mkdirp(provider: IFileSystemProvider, directory: URI): Promise<void> {\n\t\tconst directoriesToCreate: string[] = [];\n\n\t\t// mkdir until we reach root\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\t\twhile (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {\n\t\t\ttry {\n\t\t\t\tconst stat = await provider.stat(directory);\n\t\t\t\tif ((stat.type & FileType.Directory) === 0) {\n\t\t\t\t\tthrow new Error(localize('mkdirExistsError', \"Unable to create folder '{0}' that already exists but is not a directory\", this.resourceForError(directory)));\n\t\t\t\t}\n\n\t\t\t\tbreak; // we have hit a directory that exists -> good\n\t\t\t} catch (error) {\n\n\t\t\t\t// Bubble up any other error that is not file not found\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Upon error, remember directories that need to be created\n\t\t\t\tdirectoriesToCreate.push(providerExtUri.basename(directory));\n\n\t\t\t\t// Continue up\n\t\t\t\tdirectory = providerExtUri.dirname(directory);\n\t\t\t}\n\t\t}\n\n\t\t// Create directories as needed\n\t\tfor (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n\t\t\tdirectory = providerExtUri.joinPath(directory, directoriesToCreate[i]);\n\n\t\t\ttry {\n\t\t\t\tawait provider.mkdir(directory);\n\t\t\t} catch (error) {\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n\t\t\t\t\t// For mkdirp() we tolerate that the mkdir() call fails\n\t\t\t\t\t// in case the folder already exists. This follows node.js\n\t\t\t\t\t// own implementation of fs.mkdir({ recursive: true }) and\n\t\t\t\t\t// reduces the chances of race conditions leading to errors\n\t\t\t\t\t// if multiple calls try to create the same folders\n\t\t\t\t\t// As such, we only throw an error here if it is other than\n\t\t\t\t\t// the fact that the file already exists.\n\t\t\t\t\t// (see also https://github.com/microsoft/vscode/issues/89834)\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync canDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateDelete(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<IFileSystemProvider> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// Validate trash support\n\t\tconst useTrash = !!options?.useTrash;\n\t\tif (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n\t\t\tthrow new Error(localize('deleteFailedTrashUnsupported', \"Unable to delete file '{0}' via trash because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate delete\n\t\tconst exists = await this.exists(resource);\n\t\tif (!exists) {\n\t\t\tthrow new FileOperationError(localize('deleteFailedNotFound', \"Unable to delete non-existing file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t}\n\n\t\t// Validate recursive\n\t\tconst recursive = !!options?.recursive;\n\t\tif (!recursive && exists) {\n\t\t\tconst stat = await this.resolve(resource);\n\t\t\tif (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n\t\t\t\tthrow new Error(localize('deleteFailedNonEmptyFolder', \"Unable to delete non-empty folder '{0}'.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tasync del(resource: URI, options?: Partial<FileDeleteOptions>): Promise<void> {\n\t\tconst provider = await this.doValidateDelete(resource, options);\n\n\t\tconst useTrash = !!options?.useTrash;\n\t\tconst recursive = !!options?.recursive;\n\n\t\t// Delete through provider\n\t\tawait provider.delete(resource, { recursive, useTrash });\n\n\t\t// Events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidFilesChange = this._register(new Emitter<FileChangesEvent>());\n\treadonly onDidFilesChange = this._onDidFilesChange.event;\n\n\tprivate readonly activeWatchers = new Map<string, { disposable: IDisposable, count: number; }>();\n\n\twatch(resource: URI, options: IWatchOptions = { recursive: false, excludes: [] }): IDisposable {\n\t\tlet watchDisposed = false;\n\t\tlet disposeWatch = () => { watchDisposed = true; };\n\n\t\t// Watch and wire in disposable which is async but\n\t\t// check if we got disposed meanwhile and forward\n\t\tthis.doWatch(resource, options).then(disposable => {\n\t\t\tif (watchDisposed) {\n\t\t\t\tdispose(disposable);\n\t\t\t} else {\n\t\t\t\tdisposeWatch = () => dispose(disposable);\n\t\t\t}\n\t\t}, error => this.logService.error(error));\n\n\t\treturn toDisposable(() => disposeWatch());\n\t}\n\n\tasync doWatch(resource: URI, options: IWatchOptions): Promise<IDisposable> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst key = this.toWatchKey(provider, resource, options);\n\n\t\t// Only start watching if we are the first for the given key\n\t\tconst watcher = this.activeWatchers.get(key) || { count: 0, disposable: provider.watch(resource, options) };\n\t\tif (!this.activeWatchers.has(key)) {\n\t\t\tthis.activeWatchers.set(key, watcher);\n\t\t}\n\n\t\t// Increment usage counter\n\t\twatcher.count += 1;\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Unref\n\t\t\twatcher.count--;\n\n\t\t\t// Dispose only when last user is reached\n\t\t\tif (watcher.count === 0) {\n\t\t\t\tdispose(watcher.disposable);\n\t\t\t\tthis.activeWatchers.delete(key);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate toWatchKey(provider: IFileSystemProvider, resource: URI, options: IWatchOptions): string {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\treturn [\n\t\t\tproviderExtUri.getComparisonKey(resource), \t// lowercase path if the provider is case insensitive\n\t\t\tString(options.recursive),\t\t\t\t\t// use recursive: true | false as part of the key\n\t\t\toptions.excludes.join()\t\t\t\t\t\t// use excludes as part of the key\n\t\t].join();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.activeWatchers.forEach(watcher => dispose(watcher.disposable));\n\t\tthis.activeWatchers.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate readonly writeQueue = this._register(new ResourceQueue());\n\n\tprivate async doWriteBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options: IWriteFileOptions | undefined, readableOrStreamOrBufferedStream: VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {\n\n\t\t\t// open handle\n\t\t\tconst handle = await provider.open(resource, { create: true, unlock: options?.unlock ?? false });\n\n\t\t\t// write into handle until all bytes from buffer have been written\n\t\t\ttry {\n\t\t\t\tif (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n\t\t\t\t\tawait this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t\t} finally {\n\n\t\t\t\t// close handle always\n\t\t\t\tawait provider.close(handle);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async doWriteStreamBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet posInFile = 0;\n\t\tlet stream: VSBufferReadableStream;\n\n\t\t// Buffered stream: consume the buffer first by writing\n\t\t// it to the target before reading from the stream.\n\t\tif (isReadableBufferedStream(streamOrBufferedStream)) {\n\t\t\tif (streamOrBufferedStream.buffer.length > 0) {\n\t\t\t\tconst chunk = VSBuffer.concat(streamOrBufferedStream.buffer);\n\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\t\tposInFile += chunk.byteLength;\n\t\t\t}\n\n\t\t\t// If the stream has been consumed, return early\n\t\t\tif (streamOrBufferedStream.ended) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstream = streamOrBufferedStream.stream;\n\t\t}\n\n\t\t// Unbuffered stream - just take as is\n\t\telse {\n\t\t\tstream = streamOrBufferedStream;\n\t\t}\n\n\t\treturn new Promise(async (resolve, reject) => {\n\n\t\t\tlistenStream(stream, {\n\t\t\t\tonData: async chunk => {\n\n\t\t\t\t\t// pause stream to perform async write operation\n\t\t\t\t\tstream.pause();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tposInFile += chunk.byteLength;\n\n\t\t\t\t\t// resume stream now that we have successfully written\n\t\t\t\t\t// run this on the next tick to prevent increasing the\n\t\t\t\t\t// execution stack because resume() may call the event\n\t\t\t\t\t// handler again before finishing.\n\t\t\t\t\tsetTimeout(() => stream.resume());\n\t\t\t\t},\n\t\t\t\tonError: error => reject(error),\n\t\t\t\tonEnd: () => resolve()\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doWriteReadableBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: VSBufferReadable): Promise<void> {\n\t\tlet posInFile = 0;\n\n\t\tlet chunk: VSBuffer | null;\n\t\twhile ((chunk = readable.read()) !== null) {\n\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\tposInFile += chunk.byteLength;\n\t\t}\n\t}\n\n\tprivate async doWriteBuffer(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: VSBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n\t\tlet totalBytesWritten = 0;\n\t\twhile (totalBytesWritten < length) {\n\n\t\t\t// Write through the provider\n\t\t\tconst bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n\t\t\ttotalBytesWritten += bytesWritten;\n\t\t}\n\t}\n\n\tprivate async doWriteUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(() => this.doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream));\n\t}\n\n\tprivate async doWriteUnbufferedQueued(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet buffer: VSBuffer;\n\t\tif (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {\n\t\t\tbuffer = bufferOrReadableOrStreamOrBufferedStream;\n\t\t} else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await streamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await bufferedStreamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else {\n\t\t\tbuffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t}\n\n\t\t// Write through the provider\n\t\tawait provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true, unlock: options?.unlock ?? false });\n\t}\n\n\tprivate async doPipeBuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeBufferedQueued(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\tlet sourceHandle: number | undefined = undefined;\n\t\tlet targetHandle: number | undefined = undefined;\n\n\t\ttry {\n\n\t\t\t// Open handles\n\t\t\tsourceHandle = await sourceProvider.open(source, { create: false });\n\t\t\ttargetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t\tconst buffer = VSBuffer.alloc(this.BUFFER_SIZE);\n\n\t\t\tlet posInFile = 0;\n\t\t\tlet posInBuffer = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\t\t// write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) all bytes we read (bytesRead).\n\t\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n\t\t\t\tposInFile += bytesRead;\n\t\t\t\tposInBuffer += bytesRead;\n\n\t\t\t\t// when buffer full, fill it again from the beginning\n\t\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\t\tposInBuffer = 0;\n\t\t\t\t}\n\t\t\t} while (bytesRead > 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait Promises.settled([\n\t\t\t\ttypeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n\t\t\t\ttypeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate async doPipeUnbuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeUnbufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true, unlock: false });\n\t}\n\n\tprivate async doPipeUnbufferedToBuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeUnbufferedToBufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n\t\t// Open handle\n\t\tconst targetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t// Read entire buffer from source and write buffered\n\t\ttry {\n\t\t\tconst buffer = await sourceProvider.readFile(source);\n\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, VSBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait targetProvider.close(targetHandle);\n\t\t}\n\t}\n\n\tprivate async doPipeBufferedToUnbuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n\t\t// Read buffer via stream buffered\n\t\tconst buffer = await streamToBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n\t\t// Write buffer into target at once\n\t\tawait this.doWriteUnbuffered(targetProvider, target, undefined, buffer);\n\t}\n\n\tprotected throwIfFileSystemIsReadonly<T extends IFileSystemProvider>(provider: T, resource: URI): T {\n\t\tif (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify readonly file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate resourceForError(resource: URI): string {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\treturn resource.fsPath;\n\t\t}\n\n\t\treturn resource.toString(true);\n\t}\n\n\t//#endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { open, close, read, write, fdatasync, Stats, promises } from 'fs';\nimport { promisify } from 'util';\nimport { IDisposable, Disposable, toDisposable, dispose, combinedDisposable } from 'vs/base/common/lifecycle';\nimport { FileSystemProviderCapabilities, IFileChange, IWatchOptions, IStat, FileType, FileDeleteOptions, FileOverwriteOptions, FileWriteOptions, FileOpenOptions, FileSystemProviderErrorCode, createFileSystemProviderError, FileSystemProviderError, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, FileReadStreamOptions, IFileSystemProviderWithFileFolderCopyCapability, isFileOpenForWriteOptions } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { SymlinkSupport, move, copy, rimraf, RimRafMode, exists, readdir, IDirent } from 'vs/base/node/pfs';\nimport { normalize, basename, dirname } from 'vs/base/common/path';\nimport { joinPath } from 'vs/base/common/resources';\nimport { isEqual } from 'vs/base/common/extpath';\nimport { retry, ThrottledDelayer } from 'vs/base/common/async';\nimport { ILogService, LogLevel } from 'vs/platform/log/common/log';\nimport { localize } from 'vs/nls';\nimport { IDiskFileChange, toFileChanges, ILogMessage } from 'vs/platform/files/node/watcher/watcher';\nimport { FileWatcher as UnixWatcherService } from 'vs/platform/files/node/watcher/unix/watcherService';\nimport { FileWatcher as WindowsWatcherService } from 'vs/platform/files/node/watcher/win32/watcherService';\nimport { FileWatcher as NsfwWatcherService } from 'vs/platform/files/node/watcher/nsfw/watcherService';\nimport { FileWatcher as NodeJSWatcherService } from 'vs/platform/files/node/watcher/nodejs/watcherService';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { ReadableStreamEvents, newWriteableStream } from 'vs/base/common/stream';\nimport { readFileIntoStream } from 'vs/platform/files/common/io';\nimport { insert } from 'vs/base/common/arrays';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\nexport interface IWatcherOptions {\n\tpollingInterval?: number;\n\tusePolling: boolean | string[];\n}\n\nexport interface IDiskFileSystemProviderOptions {\n\tbufferSize?: number;\n\twatcher?: IWatcherOptions;\n}\n\nexport class DiskFileSystemProvider extends Disposable implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability {\n\n\tprivate readonly BUFFER_SIZE = this.options?.bufferSize || 64 * 1024;\n\n\tconstructor(\n\t\tprivate readonly logService: ILogService,\n\t\tprivate readonly options?: IDiskFileSystemProviderOptions\n\t) {\n\t\tsuper();\n\t}\n\n\t//#region File Capabilities\n\n\tonDidChangeCapabilities: Event<void> = Event.None;\n\n\tprotected _capabilities: FileSystemProviderCapabilities | undefined;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileReadStream |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy |\n\t\t\t\tFileSystemProviderCapabilities.FileWriteUnlock;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(this.toFilePath(resource)); // cannot use fs.stat() here to support links properly\n\n\t\t\treturn {\n\t\t\t\ttype: this.toType(stat, symbolicLink),\n\t\t\t\tctime: stat.birthtime.getTime(), // intentionally not using ctime here, we want the creation time\n\t\t\t\tmtime: stat.mtime.getTime(),\n\t\t\t\tsize: stat.size\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync readdir(resource: URI): Promise<[string, FileType][]> {\n\t\ttry {\n\t\t\tconst children = await readdir(this.toFilePath(resource), { withFileTypes: true });\n\n\t\t\tconst result: [string, FileType][] = [];\n\t\t\tawait Promise.all(children.map(async child => {\n\t\t\t\ttry {\n\t\t\t\t\tlet type: FileType;\n\t\t\t\t\tif (child.isSymbolicLink()) {\n\t\t\t\t\t\ttype = (await this.stat(joinPath(resource, child.name))).type; // always resolve target the link points to if any\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = this.toType(child);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.push([child.name, type]);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error); // ignore errors for individual entries that can arise from permission denied\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate toType(entry: Stats | IDirent, symbolicLink?: { dangling: boolean }): FileType {\n\n\t\t// Signal file type by checking for file / directory, except:\n\t\t// - symbolic links pointing to non-existing files are FileType.Unknown\n\t\t// - files that are neither file nor directory are FileType.Unknown\n\t\tlet type: FileType;\n\t\tif (symbolicLink?.dangling) {\n\t\t\ttype = FileType.Unknown;\n\t\t} else if (entry.isFile()) {\n\t\t\ttype = FileType.File;\n\t\t} else if (entry.isDirectory()) {\n\t\t\ttype = FileType.Directory;\n\t\t} else {\n\t\t\ttype = FileType.Unknown;\n\t\t}\n\n\t\t// Always signal symbolic link as file type additionally\n\t\tif (symbolicLink) {\n\t\t\ttype |= FileType.SymbolicLink;\n\t\t}\n\n\t\treturn type;\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync readFile(resource: URI): Promise<Uint8Array> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\treturn await promises.readFile(filePath);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\treadFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\n\t\treadFileIntoStream(this, resource, stream, data => data.buffer, {\n\t\t\t...opts,\n\t\t\tbufferSize: this.BUFFER_SIZE\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void> {\n\t\tlet handle: number | undefined = undefined;\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\t// Validate target unless { create: true, overwrite: true }\n\t\t\tif (!opts.create || !opts.overwrite) {\n\t\t\t\tconst fileExists = await exists(filePath);\n\t\t\t\tif (fileExists) {\n\t\t\t\t\tif (!opts.overwrite) {\n\t\t\t\t\t\tthrow createFileSystemProviderError(localize('fileExists', \"File already exists\"), FileSystemProviderErrorCode.FileExists);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!opts.create) {\n\t\t\t\t\t\tthrow createFileSystemProviderError(localize('fileNotExists', \"File does not exist\"), FileSystemProviderErrorCode.FileNotFound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Open\n\t\t\thandle = await this.open(resource, { create: true, unlock: opts.unlock });\n\n\t\t\t// Write content at once\n\t\t\tawait this.write(handle, 0, content, 0, content.byteLength);\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(resource, error);\n\t\t} finally {\n\t\t\tif (typeof handle === 'number') {\n\t\t\t\tawait this.close(handle);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly mapHandleToPos: Map<number, number> = new Map();\n\n\tprivate readonly writeHandles = new Map<number, URI>();\n\tprivate canFlush: boolean = true;\n\n\tasync open(resource: URI, opts: FileOpenOptions): Promise<number> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\t// Determine wether to unlock the file (write only)\n\t\t\tif (isFileOpenForWriteOptions(opts) && opts.unlock) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { stat } = await SymlinkSupport.stat(filePath);\n\t\t\t\t\tif (!(stat.mode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\t\tawait promises.chmod(filePath, stat.mode | 0o200);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error); // ignore any errors here and try to just write\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Determine file flags for opening (read vs write)\n\t\t\tlet flags: string | undefined = undefined;\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tif (isWindows) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// On Windows and if the file exists, we use a different strategy of saving the file\n\t\t\t\t\t\t// by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/931) and prevent removing alternate data streams\n\t\t\t\t\t\t// (see https://github.com/microsoft/vscode/issues/6363)\n\t\t\t\t\t\tawait promises.truncate(filePath, 0);\n\n\t\t\t\t\t\t// After a successful truncate() the flag can be set to 'r+' which will not truncate.\n\t\t\t\t\t\tflags = 'r+';\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\t\t\t\tthis.logService.trace(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// we take opts.create as a hint that the file is opened for writing\n\t\t\t\t// as such we use 'w' to truncate an existing or create the\n\t\t\t\t// file otherwise. we do not allow reading.\n\t\t\t\tif (!flags) {\n\t\t\t\t\tflags = 'w';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// otherwise we assume the file is opened for reading\n\t\t\t\t// as such we use 'r' to neither truncate, nor create\n\t\t\t\t// the file.\n\t\t\t\tflags = 'r';\n\t\t\t}\n\n\t\t\tconst handle = await promisify(open)(filePath, flags);\n\n\t\t\t// remember this handle to track file position of the handle\n\t\t\t// we init the position to 0 since the file descriptor was\n\t\t\t// just created and the position was not moved so far (see\n\t\t\t// also http://man7.org/linux/man-pages/man2/open.2.html -\n\t\t\t// \"The file offset is set to the beginning of the file.\")\n\t\t\tthis.mapHandleToPos.set(handle, 0);\n\n\t\t\t// remember that this handle was used for writing\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tthis.writeHandles.set(handle, resource);\n\t\t\t}\n\n\t\t\treturn handle;\n\t\t} catch (error) {\n\t\t\tif (isFileOpenForWriteOptions(opts)) {\n\t\t\t\tthrow await this.toFileSystemProviderWriteError(resource, error);\n\t\t\t} else {\n\t\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync close(fd: number): Promise<void> {\n\t\ttry {\n\n\t\t\t// remove this handle from map of positions\n\t\t\tthis.mapHandleToPos.delete(fd);\n\n\t\t\t// if a handle is closed that was used for writing, ensure\n\t\t\t// to flush the contents to disk if possible.\n\t\t\tif (this.writeHandles.delete(fd) && this.canFlush) {\n\t\t\t\ttry {\n\t\t\t\t\tawait promisify(fdatasync)(fd);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t\t// In that case we disable flushing and log the error to our logger\n\t\t\t\t\tthis.canFlush = false;\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await promisify(close)(fd);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesRead: number | null = null;\n\t\ttry {\n\t\t\tconst result = await promisify(read)(fd, data, offset, length, normalizedPos);\n\n\t\t\tif (typeof result === 'number') {\n\t\t\t\tbytesRead = result; // node.d.ts fail\n\t\t\t} else {\n\t\t\t\tbytesRead = result.bytesRead;\n\t\t\t}\n\n\t\t\treturn bytesRead;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesRead);\n\t\t}\n\t}\n\n\tprivate normalizePos(fd: number, pos: number): number | null {\n\n\t\t// when calling fs.read/write we try to avoid passing in the \"pos\" argument and\n\t\t// rather prefer to pass in \"null\" because this avoids an extra seek(pos)\n\t\t// call that in some cases can even fail (e.g. when opening a file over FTP -\n\t\t// see https://github.com/microsoft/vscode/issues/73884).\n\t\t//\n\t\t// as such, we compare the passed in position argument with our last known\n\t\t// position for the file descriptor and use \"null\" if they match.\n\t\tif (pos === this.mapHandleToPos.get(fd)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\tprivate updatePos(fd: number, pos: number | null, bytesLength: number | null): void {\n\t\tconst lastKnownPos = this.mapHandleToPos.get(fd);\n\t\tif (typeof lastKnownPos === 'number') {\n\n\t\t\t// pos !== null signals that previously a position was used that is\n\t\t\t// not null. node.js documentation explains, that in this case\n\t\t\t// the internal file pointer is not moving and as such we do not move\n\t\t\t// our position pointer.\n\t\t\t//\n\t\t\t// Docs: \"If position is null, data will be read from the current file position,\n\t\t\t// and the file position will be updated. If position is an integer, the file position\n\t\t\t// will remain unchanged.\"\n\t\t\tif (typeof pos === 'number') {\n\t\t\t\t// do not modify the position\n\t\t\t}\n\n\t\t\t// bytesLength = number is a signal that the read/write operation was\n\t\t\t// successful and as such we need to advance the position in the Map\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/read.2.html):\n\t\t\t// \"On files that support seeking, the read operation commences at the\n\t\t\t// file offset, and the file offset is incremented by the number of\n\t\t\t// bytes read.\"\n\t\t\t//\n\t\t\t// Docs (http://man7.org/linux/man-pages/man2/write.2.html):\n\t\t\t// \"For a seekable file (i.e., one to which lseek(2) may be applied, for\n\t\t\t// example, a regular file) writing takes place at the file offset, and\n\t\t\t// the file offset is incremented by the number of bytes actually\n\t\t\t// written.\"\n\t\t\telse if (typeof bytesLength === 'number') {\n\t\t\t\tthis.mapHandleToPos.set(fd, lastKnownPos + bytesLength);\n\t\t\t}\n\n\t\t\t// bytesLength = null signals an error in the read/write operation\n\t\t\t// and as such we drop the handle from the Map because the position\n\t\t\t// is unspecificed at this point.\n\t\t\telse {\n\t\t\t\tthis.mapHandleToPos.delete(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\t// we know at this point that the file to write to is truncated and thus empty\n\t\t// if the write now fails, the file remains empty. as such we really try hard\n\t\t// to ensure the write succeeds by retrying up to three times.\n\t\treturn retry(() => this.doWrite(fd, pos, data, offset, length), 100 /* ms delay */, 3 /* retries */);\n\t}\n\n\tprivate async doWrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst normalizedPos = this.normalizePos(fd, pos);\n\n\t\tlet bytesWritten: number | null = null;\n\t\ttry {\n\t\t\tconst result = await promisify(write)(fd, data, offset, length, normalizedPos);\n\n\t\t\tif (typeof result === 'number') {\n\t\t\t\tbytesWritten = result; // node.d.ts fail\n\t\t\t} else {\n\t\t\t\tbytesWritten = result.bytesWritten;\n\t\t\t}\n\n\t\t\treturn bytesWritten;\n\t\t} catch (error) {\n\t\t\tthrow await this.toFileSystemProviderWriteError(this.writeHandles.get(fd), error);\n\t\t} finally {\n\t\t\tthis.updatePos(fd, normalizedPos, bytesWritten);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync mkdir(resource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait promises.mkdir(this.toFilePath(resource));\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync delete(resource: URI, opts: FileDeleteOptions): Promise<void> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\tawait this.doDelete(filePath, opts);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprotected async doDelete(filePath: string, opts: FileDeleteOptions): Promise<void> {\n\t\tif (opts.recursive) {\n\t\t\tawait rimraf(filePath, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tawait promises.unlink(filePath);\n\t\t}\n\t}\n\n\tasync rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Ensure target does not exist\n\t\t\tawait this.validateTargetDeleted(from, to, 'move', opts.overwrite);\n\n\t\t\t// Move\n\t\t\tawait move(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\n\t\t\t// rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('moveError', \"Unable to move '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tif (fromFilePath === toFilePath) {\n\t\t\treturn; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Ensure target does not exist\n\t\t\tawait this.validateTargetDeleted(from, to, 'copy', opts.overwrite);\n\n\t\t\t// Copy\n\t\t\tawait copy(fromFilePath, toFilePath, { preserveSymlinks: true });\n\t\t} catch (error) {\n\n\t\t\t// rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('copyError', \"Unable to copy '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async validateTargetDeleted(from: URI, to: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\t\tconst isPathCaseSensitive = !!(this.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (!isPathCaseSensitive) {\n\t\t\tisSameResourceWithDifferentPathCase = isEqual(fromFilePath, toFilePath, true /* ignore case */);\n\t\t}\n\n\t\tif (isSameResourceWithDifferentPathCase && mode === 'copy') {\n\t\t\tthrow createFileSystemProviderError(localize('fileCopyErrorPathCase', \"'File cannot be copied to same path with different path case\"), FileSystemProviderErrorCode.FileExists);\n\t\t}\n\n\t\t// handle existing target (unless this is a case change)\n\t\tif (!isSameResourceWithDifferentPathCase && await exists(toFilePath)) {\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow createFileSystemProviderError(localize('fileCopyErrorExists', \"File at target already exists\"), FileSystemProviderErrorCode.FileExists);\n\t\t\t}\n\n\t\t\t// Delete target\n\t\t\tawait this.delete(to, { recursive: true, useTrash: false });\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidWatchErrorOccur = this._register(new Emitter<string>());\n\treadonly onDidErrorOccur = this._onDidWatchErrorOccur.event;\n\n\tprivate readonly _onDidChangeFile = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprivate recursiveWatcher: WindowsWatcherService | UnixWatcherService | NsfwWatcherService | undefined;\n\tprivate readonly recursiveFoldersToWatch: { path: string, excludes: string[] }[] = [];\n\tprivate recursiveWatchRequestDelayer = this._register(new ThrottledDelayer<void>(0));\n\n\tprivate recursiveWatcherLogLevelListener: IDisposable | undefined;\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tif (opts.recursive) {\n\t\t\treturn this.watchRecursive(resource, opts.excludes);\n\t\t}\n\n\t\treturn this.watchNonRecursive(resource); // TODO@bpasero ideally the same watcher can be used in both cases\n\t}\n\n\tprivate watchRecursive(resource: URI, excludes: string[]): IDisposable {\n\n\t\t// Add to list of folders to watch recursively\n\t\tconst folderToWatch = { path: this.toFilePath(resource), excludes };\n\t\tconst remove = insert(this.recursiveFoldersToWatch, folderToWatch);\n\n\t\t// Trigger update\n\t\tthis.refreshRecursiveWatchers();\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Remove from list of folders to watch recursively\n\t\t\tremove();\n\n\t\t\t// Trigger update\n\t\t\tthis.refreshRecursiveWatchers();\n\t\t});\n\t}\n\n\tprivate refreshRecursiveWatchers(): void {\n\n\t\t// Buffer requests for recursive watching to decide on right watcher\n\t\t// that supports potentially watching more than one folder at once\n\t\tthis.recursiveWatchRequestDelayer.trigger(async () => {\n\t\t\tthis.doRefreshRecursiveWatchers();\n\t\t});\n\t}\n\n\tprivate doRefreshRecursiveWatchers(): void {\n\n\t\t// Reuse existing\n\t\tif (this.recursiveWatcher instanceof NsfwWatcherService) {\n\t\t\tthis.recursiveWatcher.setFolders(this.recursiveFoldersToWatch);\n\t\t}\n\n\t\t// Create new\n\t\telse {\n\n\t\t\t// Dispose old\n\t\t\tdispose(this.recursiveWatcher);\n\t\t\tthis.recursiveWatcher = undefined;\n\n\t\t\t// Create new if we actually have folders to watch\n\t\t\tif (this.recursiveFoldersToWatch.length > 0) {\n\t\t\t\tlet watcherImpl: {\n\t\t\t\t\tnew(\n\t\t\t\t\t\tfolders: { path: string, excludes: string[] }[],\n\t\t\t\t\t\tonChange: (changes: IDiskFileChange[]) => void,\n\t\t\t\t\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\t\t\t\t\tverboseLogging: boolean,\n\t\t\t\t\t\twatcherOptions?: IWatcherOptions\n\t\t\t\t\t): WindowsWatcherService | UnixWatcherService | NsfwWatcherService\n\t\t\t\t};\n\n\t\t\t\tlet watcherOptions: IWatcherOptions | undefined = undefined;\n\n\t\t\t\t// requires a polling watcher\n\t\t\t\tif (this.options?.watcher?.usePolling) {\n\t\t\t\t\twatcherImpl = UnixWatcherService;\n\t\t\t\t\twatcherOptions = this.options?.watcher;\n\t\t\t\t}\n\n\t\t\t\t// Single Folder Watcher\n\t\t\t\telse {\n\t\t\t\t\tif (this.recursiveFoldersToWatch.length === 1) {\n\t\t\t\t\t\tif (isWindows) {\n\t\t\t\t\t\t\twatcherImpl = WindowsWatcherService;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twatcherImpl = UnixWatcherService;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Multi Folder Watcher\n\t\t\t\t\telse {\n\t\t\t\t\t\twatcherImpl = NsfwWatcherService;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create and start watching\n\t\t\t\tthis.recursiveWatcher = new watcherImpl(\n\t\t\t\t\tthis.recursiveFoldersToWatch,\n\t\t\t\t\tevent => this._onDidChangeFile.fire(toFileChanges(event)),\n\t\t\t\t\tmsg => {\n\t\t\t\t\t\tif (msg.type === 'error') {\n\t\t\t\t\t\t\tthis._onDidWatchErrorOccur.fire(msg.message);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.logService[msg.type](msg.message);\n\t\t\t\t\t},\n\t\t\t\t\tthis.logService.getLevel() === LogLevel.Trace,\n\t\t\t\t\twatcherOptions\n\t\t\t\t);\n\n\t\t\t\tif (!this.recursiveWatcherLogLevelListener) {\n\t\t\t\t\tthis.recursiveWatcherLogLevelListener = this.logService.onDidChangeLogLevel(() => {\n\t\t\t\t\t\tif (this.recursiveWatcher) {\n\t\t\t\t\t\t\tthis.recursiveWatcher.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate watchNonRecursive(resource: URI): IDisposable {\n\t\tconst watcherService = new NodeJSWatcherService(\n\t\t\tthis.toFilePath(resource),\n\t\t\tchanges => this._onDidChangeFile.fire(toFileChanges(changes)),\n\t\t\tmsg => {\n\t\t\t\tif (msg.type === 'error') {\n\t\t\t\t\tthis._onDidWatchErrorOccur.fire(msg.message);\n\t\t\t\t}\n\n\t\t\t\tthis.logService[msg.type](msg.message);\n\t\t\t},\n\t\t\tthis.logService.getLevel() === LogLevel.Trace\n\t\t);\n\n\t\tconst logLevelListener = this.logService.onDidChangeLogLevel(() => {\n\t\t\twatcherService.setVerboseLogging(this.logService.getLevel() === LogLevel.Trace);\n\t\t});\n\n\t\treturn combinedDisposable(watcherService, logLevelListener);\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprotected toFilePath(resource: URI): string {\n\t\treturn normalize(resource.fsPath);\n\t}\n\n\tprivate toFileSystemProviderError(error: NodeJS.ErrnoException): FileSystemProviderError {\n\t\tif (error instanceof FileSystemProviderError) {\n\t\t\treturn error; // avoid double conversion\n\t\t}\n\n\t\tlet code: FileSystemProviderErrorCode;\n\t\tswitch (error.code) {\n\t\t\tcase 'ENOENT':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotFound;\n\t\t\t\tbreak;\n\t\t\tcase 'EISDIR':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileIsADirectory;\n\t\t\t\tbreak;\n\t\t\tcase 'ENOTDIR':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotADirectory;\n\t\t\t\tbreak;\n\t\t\tcase 'EEXIST':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileExists;\n\t\t\t\tbreak;\n\t\t\tcase 'EPERM':\n\t\t\tcase 'EACCES':\n\t\t\t\tcode = FileSystemProviderErrorCode.NoPermissions;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t}\n\n\t\treturn createFileSystemProviderError(error, code);\n\t}\n\n\tprivate async toFileSystemProviderWriteError(resource: URI | undefined, error: NodeJS.ErrnoException): Promise<FileSystemProviderError> {\n\t\tlet fileSystemProviderWriteError = this.toFileSystemProviderError(error);\n\n\t\t// If the write error signals permission issues, we try\n\t\t// to read the file's mode to see if the file is write\n\t\t// locked.\n\t\tif (resource && fileSystemProviderWriteError.code === FileSystemProviderErrorCode.NoPermissions) {\n\t\t\ttry {\n\t\t\t\tconst { stat } = await SymlinkSupport.stat(this.toFilePath(resource));\n\t\t\t\tif (!(stat.mode & 0o200 /* File mode indicating writable by owner */)) {\n\t\t\t\t\tfileSystemProviderWriteError = createFileSystemProviderError(error, FileSystemProviderErrorCode.FileWriteLocked);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error); // ignore - return original error\n\t\t\t}\n\t\t}\n\n\t\treturn fileSystemProviderWriteError;\n\t}\n\n\t//#endregion\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tdispose(this.recursiveWatcher);\n\t\tthis.recursiveWatcher = undefined;\n\n\t\tdispose(this.recursiveWatcherLogLevelListener);\n\t\tthis.recursiveWatcherLogLevelListener = undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IProductConfiguration } from 'vs/base/common/product';\n\nexport const IProductService = createDecorator<IProductService>('productService');\n\nexport interface IProductService extends Readonly<IProductConfiguration> {\n\n\treadonly _serviceBrand: undefined;\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as Types from 'vs/base/common/types';\nimport * as Assert from 'vs/base/common/assert';\n\nexport interface IRegistry {\n\n\t/**\n\t * Adds the extension functions and properties defined by data to the\n\t * platform. The provided id must be unique.\n\t * @param id a unique identifier\n\t * @param data a contribution\n\t */\n\tadd(id: string, data: any): void;\n\n\t/**\n\t * Returns true iff there is an extension with the provided id.\n\t * @param id an extension identifier\n\t */\n\tknows(id: string): boolean;\n\n\t/**\n\t * Returns the extension functions and properties defined by the specified key or null.\n\t * @param id an extension identifier\n\t */\n\tas<T>(id: string): T;\n}\n\nclass RegistryImpl implements IRegistry {\n\n\tprivate readonly data = new Map<string, any>();\n\n\tpublic add(id: string, data: any): void {\n\t\tAssert.ok(Types.isString(id));\n\t\tAssert.ok(Types.isObject(data));\n\t\tAssert.ok(!this.data.has(id), 'There is already an extension with this id');\n\n\t\tthis.data.set(id, data);\n\t}\n\n\tpublic knows(id: string): boolean {\n\t\treturn this.data.has(id);\n\t}\n\n\tpublic as(id: string): any {\n\t\treturn this.data.get(id) || null;\n\t}\n}\n\nexport const Registry: IRegistry = new RegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\nimport * as platform from 'vs/platform/registry/common/platform';\nimport { Event, Emitter } from 'vs/base/common/event';\n\nexport const Extensions = {\n\tJSONContribution: 'base.contributions.json'\n};\n\nexport interface ISchemaContributions {\n\tschemas: { [id: string]: IJSONSchema };\n}\n\nexport interface IJSONContributionRegistry {\n\n\treadonly onDidChangeSchema: Event<string>;\n\n\t/**\n\t * Register a schema to the registry.\n\t */\n\tregisterSchema(uri: string, unresolvedSchemaContent: IJSONSchema): void;\n\n\n\t/**\n\t * Notifies all listeners that the content of the given schema has changed.\n\t * @param uri The id of the schema\n\t */\n\tnotifySchemaChanged(uri: string): void;\n\n\t/**\n\t * Get all schemas\n\t */\n\tgetSchemaContributions(): ISchemaContributions;\n}\n\n\n\nfunction normalizeId(id: string) {\n\tif (id.length > 0 && id.charAt(id.length - 1) === '#') {\n\t\treturn id.substring(0, id.length - 1);\n\t}\n\treturn id;\n}\n\n\n\nclass JSONContributionRegistry implements IJSONContributionRegistry {\n\n\tprivate schemasById: { [id: string]: IJSONSchema };\n\n\tprivate readonly _onDidChangeSchema = new Emitter<string>();\n\treadonly onDidChangeSchema: Event<string> = this._onDidChangeSchema.event;\n\n\tconstructor() {\n\t\tthis.schemasById = {};\n\t}\n\n\tpublic registerSchema(uri: string, unresolvedSchemaContent: IJSONSchema): void {\n\t\tthis.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n\t\tthis._onDidChangeSchema.fire(uri);\n\t}\n\n\tpublic notifySchemaChanged(uri: string): void {\n\t\tthis._onDidChangeSchema.fire(uri);\n\t}\n\n\tpublic getSchemaContributions(): ISchemaContributions {\n\t\treturn {\n\t\t\tschemas: this.schemasById,\n\t\t};\n\t}\n\n}\n\nconst jsonContributionRegistry = new JSONContributionRegistry();\nplatform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport * as types from 'vs/base/common/types';\nimport { IJSONContributionRegistry, Extensions as JSONExtensions } from 'vs/platform/jsonschemas/common/jsonContributionRegistry';\nimport { IStringDictionary } from 'vs/base/common/collections';\n\nexport const Extensions = {\n\tConfiguration: 'base.contributions.configuration'\n};\n\nexport interface IConfigurationRegistry {\n\n\t/**\n\t * Register a configuration to the registry.\n\t */\n\tregisterConfiguration(configuration: IConfigurationNode): void;\n\n\t/**\n\t * Register multiple configurations to the registry.\n\t */\n\tregisterConfigurations(configurations: IConfigurationNode[], validate?: boolean): void;\n\n\t/**\n\t * Deregister multiple configurations from the registry.\n\t */\n\tderegisterConfigurations(configurations: IConfigurationNode[]): void;\n\n\t/**\n\t * Register multiple default configurations to the registry.\n\t */\n\tregisterDefaultConfigurations(defaultConfigurations: IStringDictionary<any>[]): void;\n\n\t/**\n\t * Deregister multiple default configurations from the registry.\n\t */\n\tderegisterDefaultConfigurations(defaultConfigurations: IStringDictionary<any>[]): void;\n\n\t/**\n\t * Signal that the schema of a configuration setting has changes. It is currently only supported to change enumeration values.\n\t * Property or default value changes are not allowed.\n\t */\n\tnotifyConfigurationSchemaUpdated(...configurations: IConfigurationNode[]): void;\n\n\t/**\n\t * Event that fires whenver a configuration has been\n\t * registered.\n\t */\n\tonDidSchemaChange: Event<void>;\n\n\t/**\n\t * Event that fires whenver a configuration has been\n\t * registered.\n\t */\n\tonDidUpdateConfiguration: Event<string[]>;\n\n\t/**\n\t * Returns all configuration nodes contributed to this registry.\n\t */\n\tgetConfigurations(): IConfigurationNode[];\n\n\t/**\n\t * Returns all configurations settings of all configuration nodes contributed to this registry.\n\t */\n\tgetConfigurationProperties(): { [qualifiedKey: string]: IConfigurationPropertySchema };\n\n\t/**\n\t * Returns all excluded configurations settings of all configuration nodes contributed to this registry.\n\t */\n\tgetExcludedConfigurationProperties(): { [qualifiedKey: string]: IConfigurationPropertySchema };\n\n\t/**\n\t * Register the identifiers for editor configurations\n\t */\n\tregisterOverrideIdentifiers(identifiers: string[]): void;\n}\n\nexport const enum ConfigurationScope {\n\t/**\n\t * Application specific configuration, which can be configured only in local user settings.\n\t */\n\tAPPLICATION = 1,\n\t/**\n\t * Machine specific configuration, which can be configured only in local and remote user settings.\n\t */\n\tMACHINE,\n\t/**\n\t * Window specific configuration, which can be configured in the user or workspace settings.\n\t */\n\tWINDOW,\n\t/**\n\t * Resource specific configuration, which can be configured in the user, workspace or folder settings.\n\t */\n\tRESOURCE,\n\t/**\n\t * Resource specific configuration that can be configured in language specific settings\n\t */\n\tLANGUAGE_OVERRIDABLE,\n\t/**\n\t * Machine specific configuration that can also be configured in workspace or folder settings.\n\t */\n\tMACHINE_OVERRIDABLE,\n}\n\nexport interface IConfigurationPropertySchema extends IJSONSchema {\n\n\tscope?: ConfigurationScope;\n\n\t/**\n\t * When restricted, value of this configuration will be read only from trusted sources.\n\t * For eg., If the workspace is not trusted, then the value of this configuration is not read from workspace settings file.\n\t */\n\trestricted?: boolean;\n\n\tincluded?: boolean;\n\n\ttags?: string[];\n\n\t/**\n\t * When enabled this setting is ignored during sync and user can override this.\n\t */\n\tignoreSync?: boolean;\n\n\t/**\n\t * When enabled this setting is ignored during sync and user cannot override this.\n\t */\n\tdisallowSyncIgnore?: boolean;\n\n\tenumItemLabels?: string[];\n}\n\nexport interface IConfigurationExtensionInfo {\n\tid: string;\n\trestrictedConfigurations?: string[];\n}\n\nexport interface IConfigurationNode {\n\tid?: string;\n\torder?: number;\n\ttype?: string | string[];\n\ttitle?: string;\n\tdescription?: string;\n\tproperties?: { [path: string]: IConfigurationPropertySchema; };\n\tallOf?: IConfigurationNode[];\n\tscope?: ConfigurationScope;\n\textensionInfo?: IConfigurationExtensionInfo;\n}\n\nexport const allSettings: { properties: IStringDictionary<IConfigurationPropertySchema>, patternProperties: IStringDictionary<IConfigurationPropertySchema> } = { properties: {}, patternProperties: {} };\nexport const applicationSettings: { properties: IStringDictionary<IConfigurationPropertySchema>, patternProperties: IStringDictionary<IConfigurationPropertySchema> } = { properties: {}, patternProperties: {} };\nexport const machineSettings: { properties: IStringDictionary<IConfigurationPropertySchema>, patternProperties: IStringDictionary<IConfigurationPropertySchema> } = { properties: {}, patternProperties: {} };\nexport const machineOverridableSettings: { properties: IStringDictionary<IConfigurationPropertySchema>, patternProperties: IStringDictionary<IConfigurationPropertySchema> } = { properties: {}, patternProperties: {} };\nexport const windowSettings: { properties: IStringDictionary<IConfigurationPropertySchema>, patternProperties: IStringDictionary<IConfigurationPropertySchema> } = { properties: {}, patternProperties: {} };\nexport const resourceSettings: { properties: IStringDictionary<IConfigurationPropertySchema>, patternProperties: IStringDictionary<IConfigurationPropertySchema> } = { properties: {}, patternProperties: {} };\n\nexport const resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';\n\nconst contributionRegistry = Registry.as<IJSONContributionRegistry>(JSONExtensions.JSONContribution);\n\nclass ConfigurationRegistry implements IConfigurationRegistry {\n\n\tprivate readonly defaultValues: IStringDictionary<any>;\n\tprivate readonly defaultLanguageConfigurationOverridesNode: IConfigurationNode;\n\tprivate readonly configurationContributors: IConfigurationNode[];\n\tprivate readonly configurationProperties: { [qualifiedKey: string]: IJSONSchema };\n\tprivate readonly excludedConfigurationProperties: { [qualifiedKey: string]: IJSONSchema };\n\tprivate readonly resourceLanguageSettingsSchema: IJSONSchema;\n\tprivate readonly overrideIdentifiers = new Set<string>();\n\n\tprivate readonly _onDidSchemaChange = new Emitter<void>();\n\treadonly onDidSchemaChange: Event<void> = this._onDidSchemaChange.event;\n\n\tprivate readonly _onDidUpdateConfiguration: Emitter<string[]> = new Emitter<string[]>();\n\treadonly onDidUpdateConfiguration: Event<string[]> = this._onDidUpdateConfiguration.event;\n\n\tconstructor() {\n\t\tthis.defaultValues = {};\n\t\tthis.defaultLanguageConfigurationOverridesNode = {\n\t\t\tid: 'defaultOverrides',\n\t\t\ttitle: nls.localize('defaultLanguageConfigurationOverrides.title', \"Default Language Configuration Overrides\"),\n\t\t\tproperties: {}\n\t\t};\n\t\tthis.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];\n\t\tthis.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown editor configuration setting', allowTrailingCommas: true, allowComments: true };\n\t\tthis.configurationProperties = {};\n\t\tthis.excludedConfigurationProperties = {};\n\n\t\tcontributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n\t}\n\n\tpublic registerConfiguration(configuration: IConfigurationNode, validate: boolean = true): void {\n\t\tthis.registerConfigurations([configuration], validate);\n\t}\n\n\tpublic registerConfigurations(configurations: IConfigurationNode[], validate: boolean = true): void {\n\t\tconst properties: string[] = [];\n\t\tconfigurations.forEach(configuration => {\n\t\t\tproperties.push(...this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo)); // fills in defaults\n\t\t\tthis.configurationContributors.push(configuration);\n\t\t\tthis.registerJSONConfiguration(configuration);\n\t\t});\n\n\t\tcontributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n\t\tthis._onDidSchemaChange.fire();\n\t\tthis._onDidUpdateConfiguration.fire(properties);\n\t}\n\n\tpublic deregisterConfigurations(configurations: IConfigurationNode[]): void {\n\t\tconst properties: string[] = [];\n\t\tconst deregisterConfiguration = (configuration: IConfigurationNode) => {\n\t\t\tif (configuration.properties) {\n\t\t\t\tfor (const key in configuration.properties) {\n\t\t\t\t\tproperties.push(key);\n\t\t\t\t\tdelete this.configurationProperties[key];\n\t\t\t\t\tthis.removeFromSchema(key, configuration.properties[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (configuration.allOf) {\n\t\t\t\tconfiguration.allOf.forEach(node => deregisterConfiguration(node));\n\t\t\t}\n\t\t};\n\t\tfor (const configuration of configurations) {\n\t\t\tderegisterConfiguration(configuration);\n\t\t\tconst index = this.configurationContributors.indexOf(configuration);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.configurationContributors.splice(index, 1);\n\t\t\t}\n\t\t}\n\n\t\tcontributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n\t\tthis._onDidSchemaChange.fire();\n\t\tthis._onDidUpdateConfiguration.fire(properties);\n\t}\n\n\tpublic registerDefaultConfigurations(defaultConfigurations: IStringDictionary<any>[]): void {\n\t\tconst properties: string[] = [];\n\t\tconst overrideIdentifiers: string[] = [];\n\n\t\tfor (const defaultConfiguration of defaultConfigurations) {\n\t\t\tfor (const key in defaultConfiguration) {\n\t\t\t\tproperties.push(key);\n\n\t\t\t\tif (OVERRIDE_PROPERTY_PATTERN.test(key)) {\n\t\t\t\t\tthis.defaultValues[key] = { ...(this.defaultValues[key] || {}), ...defaultConfiguration[key] };\n\t\t\t\t\tconst property: IConfigurationPropertySchema = {\n\t\t\t\t\t\ttype: 'object',\n\t\t\t\t\t\tdefault: this.defaultValues[key],\n\t\t\t\t\t\tdescription: nls.localize('defaultLanguageConfiguration.description', \"Configure settings to be overridden for {0} language.\", key),\n\t\t\t\t\t\t$ref: resourceLanguageSettingsSchemaId\n\t\t\t\t\t};\n\t\t\t\t\toverrideIdentifiers.push(overrideIdentifierFromKey(key));\n\t\t\t\t\tthis.configurationProperties[key] = property;\n\t\t\t\t\tthis.defaultLanguageConfigurationOverridesNode.properties![key] = property;\n\t\t\t\t} else {\n\t\t\t\t\tthis.defaultValues[key] = defaultConfiguration[key];\n\t\t\t\t\tconst property = this.configurationProperties[key];\n\t\t\t\t\tif (property) {\n\t\t\t\t\t\tthis.updatePropertyDefaultValue(key, property);\n\t\t\t\t\t\tthis.updateSchema(key, property);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.registerOverrideIdentifiers(overrideIdentifiers);\n\t\tthis._onDidSchemaChange.fire();\n\t\tthis._onDidUpdateConfiguration.fire(properties);\n\t}\n\n\tpublic deregisterDefaultConfigurations(defaultConfigurations: IStringDictionary<any>[]): void {\n\t\tconst properties: string[] = [];\n\t\tfor (const defaultConfiguration of defaultConfigurations) {\n\t\t\tfor (const key in defaultConfiguration) {\n\t\t\t\tproperties.push(key);\n\t\t\t\tdelete this.defaultValues[key];\n\t\t\t\tif (OVERRIDE_PROPERTY_PATTERN.test(key)) {\n\t\t\t\t\tdelete this.configurationProperties[key];\n\t\t\t\t\tdelete this.defaultLanguageConfigurationOverridesNode.properties![key];\n\t\t\t\t} else {\n\t\t\t\t\tconst property = this.configurationProperties[key];\n\t\t\t\t\tif (property) {\n\t\t\t\t\t\tthis.updatePropertyDefaultValue(key, property);\n\t\t\t\t\t\tthis.updateSchema(key, property);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.updateOverridePropertyPatternKey();\n\t\tthis._onDidSchemaChange.fire();\n\t\tthis._onDidUpdateConfiguration.fire(properties);\n\t}\n\n\tpublic notifyConfigurationSchemaUpdated(...configurations: IConfigurationNode[]) {\n\t\tthis._onDidSchemaChange.fire();\n\t}\n\n\tpublic registerOverrideIdentifiers(overrideIdentifiers: string[]): void {\n\t\tfor (const overrideIdentifier of overrideIdentifiers) {\n\t\t\tthis.overrideIdentifiers.add(overrideIdentifier);\n\t\t}\n\t\tthis.updateOverridePropertyPatternKey();\n\t}\n\n\tprivate validateAndRegisterProperties(configuration: IConfigurationNode, validate: boolean = true, extensionInfo?: IConfigurationExtensionInfo, scope: ConfigurationScope = ConfigurationScope.WINDOW): string[] {\n\t\tscope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;\n\t\tlet propertyKeys: string[] = [];\n\t\tlet properties = configuration.properties;\n\t\tif (properties) {\n\t\t\tfor (let key in properties) {\n\t\t\t\tif (validate && validateProperty(key)) {\n\t\t\t\t\tdelete properties[key];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst property = properties[key];\n\n\t\t\t\t// update default value\n\t\t\t\tthis.updatePropertyDefaultValue(key, property);\n\n\t\t\t\t// update scope\n\t\t\t\tif (OVERRIDE_PROPERTY_PATTERN.test(key)) {\n\t\t\t\t\tproperty.scope = undefined; // No scope for overridable properties `[${identifier}]`\n\t\t\t\t} else {\n\t\t\t\t\tproperty.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;\n\t\t\t\t\tproperty.restricted = types.isUndefinedOrNull(property.restricted) ? !!extensionInfo?.restrictedConfigurations?.includes(key) : property.restricted;\n\t\t\t\t}\n\n\t\t\t\t// Add to properties maps\n\t\t\t\t// Property is included by default if 'included' is unspecified\n\t\t\t\tif (properties[key].hasOwnProperty('included') && !properties[key].included) {\n\t\t\t\t\tthis.excludedConfigurationProperties[key] = properties[key];\n\t\t\t\t\tdelete properties[key];\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tthis.configurationProperties[key] = properties[key];\n\t\t\t\t}\n\n\t\t\t\tif (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {\n\t\t\t\t\t// If not set, default deprecationMessage to the markdown source\n\t\t\t\t\tproperties[key].deprecationMessage = properties[key].markdownDeprecationMessage;\n\t\t\t\t}\n\n\t\t\t\tpropertyKeys.push(key);\n\t\t\t}\n\t\t}\n\t\tlet subNodes = configuration.allOf;\n\t\tif (subNodes) {\n\t\t\tfor (let node of subNodes) {\n\t\t\t\tpropertyKeys.push(...this.validateAndRegisterProperties(node, validate, extensionInfo, scope));\n\t\t\t}\n\t\t}\n\t\treturn propertyKeys;\n\t}\n\n\tgetConfigurations(): IConfigurationNode[] {\n\t\treturn this.configurationContributors;\n\t}\n\n\tgetConfigurationProperties(): { [qualifiedKey: string]: IConfigurationPropertySchema } {\n\t\treturn this.configurationProperties;\n\t}\n\n\tgetExcludedConfigurationProperties(): { [qualifiedKey: string]: IConfigurationPropertySchema } {\n\t\treturn this.excludedConfigurationProperties;\n\t}\n\n\tprivate registerJSONConfiguration(configuration: IConfigurationNode) {\n\t\tconst register = (configuration: IConfigurationNode) => {\n\t\t\tlet properties = configuration.properties;\n\t\t\tif (properties) {\n\t\t\t\tfor (const key in properties) {\n\t\t\t\t\tthis.updateSchema(key, properties[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet subNodes = configuration.allOf;\n\t\t\tif (subNodes) {\n\t\t\t\tsubNodes.forEach(register);\n\t\t\t}\n\t\t};\n\t\tregister(configuration);\n\t}\n\n\tprivate updateSchema(key: string, property: IConfigurationPropertySchema): void {\n\t\tallSettings.properties[key] = property;\n\t\tswitch (property.scope) {\n\t\t\tcase ConfigurationScope.APPLICATION:\n\t\t\t\tapplicationSettings.properties[key] = property;\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.MACHINE:\n\t\t\t\tmachineSettings.properties[key] = property;\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.MACHINE_OVERRIDABLE:\n\t\t\t\tmachineOverridableSettings.properties[key] = property;\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.WINDOW:\n\t\t\t\twindowSettings.properties[key] = property;\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.RESOURCE:\n\t\t\t\tresourceSettings.properties[key] = property;\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.LANGUAGE_OVERRIDABLE:\n\t\t\t\tresourceSettings.properties[key] = property;\n\t\t\t\tthis.resourceLanguageSettingsSchema.properties![key] = property;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate removeFromSchema(key: string, property: IConfigurationPropertySchema): void {\n\t\tdelete allSettings.properties[key];\n\t\tswitch (property.scope) {\n\t\t\tcase ConfigurationScope.APPLICATION:\n\t\t\t\tdelete applicationSettings.properties[key];\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.MACHINE:\n\t\t\t\tdelete machineSettings.properties[key];\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.MACHINE_OVERRIDABLE:\n\t\t\t\tdelete machineOverridableSettings.properties[key];\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.WINDOW:\n\t\t\t\tdelete windowSettings.properties[key];\n\t\t\t\tbreak;\n\t\t\tcase ConfigurationScope.RESOURCE:\n\t\t\tcase ConfigurationScope.LANGUAGE_OVERRIDABLE:\n\t\t\t\tdelete resourceSettings.properties[key];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate updateOverridePropertyPatternKey(): void {\n\t\tfor (const overrideIdentifier of this.overrideIdentifiers.values()) {\n\t\t\tconst overrideIdentifierProperty = `[${overrideIdentifier}]`;\n\t\t\tconst resourceLanguagePropertiesSchema: IJSONSchema = {\n\t\t\t\ttype: 'object',\n\t\t\t\tdescription: nls.localize('overrideSettings.defaultDescription', \"Configure editor settings to be overridden for a language.\"),\n\t\t\t\terrorMessage: nls.localize('overrideSettings.errorMessage', \"This setting does not support per-language configuration.\"),\n\t\t\t\t$ref: resourceLanguageSettingsSchemaId,\n\t\t\t};\n\t\t\tthis.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);\n\t\t\tallSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n\t\t\tapplicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n\t\t\tmachineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n\t\t\tmachineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n\t\t\twindowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n\t\t\tresourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n\t\t}\n\t\tthis._onDidSchemaChange.fire();\n\t}\n\n\tprivate updatePropertyDefaultValue(key: string, property: IConfigurationPropertySchema): void {\n\t\tlet defaultValue = this.defaultValues[key];\n\t\tif (types.isUndefined(defaultValue)) {\n\t\t\tdefaultValue = property.default;\n\t\t}\n\t\tif (types.isUndefined(defaultValue)) {\n\t\t\tdefaultValue = getDefaultValue(property.type);\n\t\t}\n\t\tproperty.default = defaultValue;\n\t}\n}\n\nconst OVERRIDE_PROPERTY = '\\\\[.*\\\\]$';\nexport const OVERRIDE_PROPERTY_PATTERN = new RegExp(OVERRIDE_PROPERTY);\n\nexport function overrideIdentifierFromKey(key: string): string {\n\treturn key.substring(1, key.length - 1);\n}\n\nexport function getDefaultValue(type: string | string[] | undefined): any {\n\tconst t = Array.isArray(type) ? (<string[]>type)[0] : <string>type;\n\tswitch (t) {\n\t\tcase 'boolean':\n\t\t\treturn false;\n\t\tcase 'integer':\n\t\tcase 'number':\n\t\t\treturn 0;\n\t\tcase 'string':\n\t\t\treturn '';\n\t\tcase 'array':\n\t\t\treturn [];\n\t\tcase 'object':\n\t\t\treturn {};\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n\nconst configurationRegistry = new ConfigurationRegistry();\nRegistry.add(Extensions.Configuration, configurationRegistry);\n\nexport function validateProperty(property: string): string | null {\n\tif (!property.trim()) {\n\t\treturn nls.localize('config.property.empty', \"Cannot register an empty property\");\n\t}\n\tif (OVERRIDE_PROPERTY_PATTERN.test(property)) {\n\t\treturn nls.localize('config.property.languageDefault', \"Cannot register '{0}'. This matches property pattern '\\\\\\\\[.*\\\\\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.\", property);\n\t}\n\tif (configurationRegistry.getConfigurationProperties()[property] !== undefined) {\n\t\treturn nls.localize('config.property.duplicate', \"Cannot register '{0}'. This property is already registered.\", property);\n\t}\n\treturn null;\n}\n\nexport function getScopes(): [string, ConfigurationScope | undefined][] {\n\tconst scopes: [string, ConfigurationScope | undefined][] = [];\n\tconst configurationProperties = configurationRegistry.getConfigurationProperties();\n\tfor (const key of Object.keys(configurationProperties)) {\n\t\tscopes.push([key, configurationProperties[key].scope]);\n\t}\n\tscopes.push(['launch', ConfigurationScope.RESOURCE]);\n\tscopes.push(['task', ConfigurationScope.RESOURCE]);\n\treturn scopes;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as objects from 'vs/base/common/objects';\nimport * as types from 'vs/base/common/types';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { Event } from 'vs/base/common/event';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IConfigurationRegistry, Extensions, OVERRIDE_PROPERTY_PATTERN, overrideIdentifierFromKey } from 'vs/platform/configuration/common/configurationRegistry';\nimport { IStringDictionary } from 'vs/base/common/collections';\n\nexport const IConfigurationService = createDecorator<IConfigurationService>('configurationService');\n\nexport function isConfigurationOverrides(thing: any): thing is IConfigurationOverrides {\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n\t\t&& (!thing.resource || thing.resource instanceof URI);\n}\n\nexport interface IConfigurationOverrides {\n\toverrideIdentifier?: string | null;\n\tresource?: URI | null;\n}\n\nexport const enum ConfigurationTarget {\n\tUSER = 1,\n\tUSER_LOCAL,\n\tUSER_REMOTE,\n\tWORKSPACE,\n\tWORKSPACE_FOLDER,\n\tDEFAULT,\n\tMEMORY\n}\nexport function ConfigurationTargetToString(configurationTarget: ConfigurationTarget) {\n\tswitch (configurationTarget) {\n\t\tcase ConfigurationTarget.USER: return 'USER';\n\t\tcase ConfigurationTarget.USER_LOCAL: return 'USER_LOCAL';\n\t\tcase ConfigurationTarget.USER_REMOTE: return 'USER_REMOTE';\n\t\tcase ConfigurationTarget.WORKSPACE: return 'WORKSPACE';\n\t\tcase ConfigurationTarget.WORKSPACE_FOLDER: return 'WORKSPACE_FOLDER';\n\t\tcase ConfigurationTarget.DEFAULT: return 'DEFAULT';\n\t\tcase ConfigurationTarget.MEMORY: return 'MEMORY';\n\t}\n}\n\nexport interface IConfigurationChange {\n\tkeys: string[];\n\toverrides: [string, string[]][];\n}\n\nexport interface IConfigurationChangeEvent {\n\n\treadonly source: ConfigurationTarget;\n\treadonly affectedKeys: string[];\n\treadonly change: IConfigurationChange;\n\n\taffectsConfiguration(configuration: string, overrides?: IConfigurationOverrides): boolean;\n\n\t// Following data is used for telemetry\n\treadonly sourceConfig: any;\n}\n\nexport interface IConfigurationValue<T> {\n\n\treadonly defaultValue?: T;\n\treadonly userValue?: T;\n\treadonly userLocalValue?: T;\n\treadonly userRemoteValue?: T;\n\treadonly workspaceValue?: T;\n\treadonly workspaceFolderValue?: T;\n\treadonly memoryValue?: T;\n\treadonly value?: T;\n\n\treadonly default?: { value?: T, override?: T };\n\treadonly user?: { value?: T, override?: T };\n\treadonly userLocal?: { value?: T, override?: T };\n\treadonly userRemote?: { value?: T, override?: T };\n\treadonly workspace?: { value?: T, override?: T };\n\treadonly workspaceFolder?: { value?: T, override?: T };\n\treadonly memory?: { value?: T, override?: T };\n\n\treadonly overrideIdentifiers?: string[];\n}\n\nexport interface IConfigurationService {\n\treadonly _serviceBrand: undefined;\n\n\tonDidChangeConfiguration: Event<IConfigurationChangeEvent>;\n\n\tgetConfigurationData(): IConfigurationData | null;\n\n\t/**\n\t * Fetches the value of the section for the given overrides.\n\t * Value can be of native type or an object keyed off the section name.\n\t *\n\t * @param section - Section of the configuraion. Can be `null` or `undefined`.\n\t * @param overrides - Overrides that has to be applied while fetching\n\t *\n\t */\n\tgetValue<T>(): T;\n\tgetValue<T>(section: string): T;\n\tgetValue<T>(overrides: IConfigurationOverrides): T;\n\tgetValue<T>(section: string, overrides: IConfigurationOverrides): T;\n\n\tupdateValue(key: string, value: any): Promise<void>;\n\tupdateValue(key: string, value: any, overrides: IConfigurationOverrides): Promise<void>;\n\tupdateValue(key: string, value: any, target: ConfigurationTarget): Promise<void>;\n\tupdateValue(key: string, value: any, overrides: IConfigurationOverrides, target: ConfigurationTarget, donotNotifyError?: boolean): Promise<void>;\n\n\tinspect<T>(key: string, overrides?: IConfigurationOverrides): IConfigurationValue<T>;\n\n\treloadConfiguration(target?: ConfigurationTarget | IWorkspaceFolder): Promise<void>;\n\n\tkeys(): {\n\t\tdefault: string[];\n\t\tuser: string[];\n\t\tworkspace: string[];\n\t\tworkspaceFolder: string[];\n\t\tmemory?: string[];\n\t};\n}\n\nexport interface IConfigurationModel {\n\tcontents: any;\n\tkeys: string[];\n\toverrides: IOverrides[];\n}\n\nexport interface IOverrides {\n\tkeys: string[];\n\tcontents: any;\n\tidentifiers: string[];\n}\n\nexport interface IConfigurationData {\n\tdefaults: IConfigurationModel;\n\tuser: IConfigurationModel;\n\tworkspace: IConfigurationModel;\n\tfolders: [UriComponents, IConfigurationModel][];\n}\n\nexport interface IConfigurationCompareResult {\n\tadded: string[];\n\tremoved: string[];\n\tupdated: string[];\n\toverrides: [string, string[]][];\n}\n\nexport function compare(from: IConfigurationModel | undefined, to: IConfigurationModel | undefined): IConfigurationCompareResult {\n\tconst added = to\n\t\t? from ? to.keys.filter(key => from.keys.indexOf(key) === -1) : [...to.keys]\n\t\t: [];\n\tconst removed = from\n\t\t? to ? from.keys.filter(key => to.keys.indexOf(key) === -1) : [...from.keys]\n\t\t: [];\n\tconst updated: string[] = [];\n\n\tif (to && from) {\n\t\tfor (const key of from.keys) {\n\t\t\tif (to.keys.indexOf(key) !== -1) {\n\t\t\t\tconst value1 = getConfigurationValue(from.contents, key);\n\t\t\t\tconst value2 = getConfigurationValue(to.contents, key);\n\t\t\t\tif (!objects.equals(value1, value2)) {\n\t\t\t\t\tupdated.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst overrides: [string, string[]][] = [];\n\tconst byOverrideIdentifier = (overrides: IOverrides[]): IStringDictionary<IOverrides> => {\n\t\tconst result: IStringDictionary<IOverrides> = {};\n\t\tfor (const override of overrides) {\n\t\t\tfor (const identifier of override.identifiers) {\n\t\t\t\tresult[keyFromOverrideIdentifier(identifier)] = override;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tconst toOverridesByIdentifier: IStringDictionary<IOverrides> = to ? byOverrideIdentifier(to.overrides) : {};\n\tconst fromOverridesByIdentifier: IStringDictionary<IOverrides> = from ? byOverrideIdentifier(from.overrides) : {};\n\n\tif (Object.keys(toOverridesByIdentifier).length) {\n\t\tfor (const key of added) {\n\t\t\tconst override = toOverridesByIdentifier[key];\n\t\t\tif (override) {\n\t\t\t\toverrides.push([overrideIdentifierFromKey(key), override.keys]);\n\t\t\t}\n\t\t}\n\t}\n\tif (Object.keys(fromOverridesByIdentifier).length) {\n\t\tfor (const key of removed) {\n\t\t\tconst override = fromOverridesByIdentifier[key];\n\t\t\tif (override) {\n\t\t\t\toverrides.push([overrideIdentifierFromKey(key), override.keys]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (Object.keys(toOverridesByIdentifier).length && Object.keys(fromOverridesByIdentifier).length) {\n\t\tfor (const key of updated) {\n\t\t\tconst fromOverride = fromOverridesByIdentifier[key];\n\t\t\tconst toOverride = toOverridesByIdentifier[key];\n\t\t\tif (fromOverride && toOverride) {\n\t\t\t\tconst result = compare({ contents: fromOverride.contents, keys: fromOverride.keys, overrides: [] }, { contents: toOverride.contents, keys: toOverride.keys, overrides: [] });\n\t\t\t\toverrides.push([overrideIdentifierFromKey(key), [...result.added, ...result.removed, ...result.updated]]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { added, removed, updated, overrides };\n}\n\nexport function toOverrides(raw: any, conflictReporter: (message: string) => void): IOverrides[] {\n\tconst overrides: IOverrides[] = [];\n\tfor (const key of Object.keys(raw)) {\n\t\tif (OVERRIDE_PROPERTY_PATTERN.test(key)) {\n\t\t\tconst overrideRaw: any = {};\n\t\t\tfor (const keyInOverrideRaw in raw[key]) {\n\t\t\t\toverrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];\n\t\t\t}\n\t\t\toverrides.push({\n\t\t\t\tidentifiers: [overrideIdentifierFromKey(key).trim()],\n\t\t\t\tkeys: Object.keys(overrideRaw),\n\t\t\t\tcontents: toValuesTree(overrideRaw, conflictReporter)\n\t\t\t});\n\t\t}\n\t}\n\treturn overrides;\n}\n\nexport function toValuesTree(properties: { [qualifiedKey: string]: any }, conflictReporter: (message: string) => void): any {\n\tconst root = Object.create(null);\n\n\tfor (let key in properties) {\n\t\taddToValueTree(root, key, properties[key], conflictReporter);\n\t}\n\n\treturn root;\n}\n\nexport function addToValueTree(settingsTreeRoot: any, key: string, value: any, conflictReporter: (message: string) => void): void {\n\tconst segments = key.split('.');\n\tconst last = segments.pop()!;\n\n\tlet curr = settingsTreeRoot;\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tlet s = segments[i];\n\t\tlet obj = curr[s];\n\t\tswitch (typeof obj) {\n\t\t\tcase 'undefined':\n\t\t\t\tobj = curr[s] = Object.create(null);\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n\t\t\t\treturn;\n\t\t}\n\t\tcurr = obj;\n\t}\n\n\tif (typeof curr === 'object' && curr !== null) {\n\t\ttry {\n\t\t\tcurr[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606\n\t\t} catch (e) {\n\t\t\tconflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n\t\t}\n\t} else {\n\t\tconflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n\t}\n}\n\nexport function removeFromValueTree(valueTree: any, key: string): void {\n\tconst segments = key.split('.');\n\tdoRemoveFromValueTree(valueTree, segments);\n}\n\nfunction doRemoveFromValueTree(valueTree: any, segments: string[]): void {\n\tconst first = segments.shift()!;\n\tif (segments.length === 0) {\n\t\t// Reached last segment\n\t\tdelete valueTree[first];\n\t\treturn;\n\t}\n\n\tif (Object.keys(valueTree).indexOf(first) !== -1) {\n\t\tconst value = valueTree[first];\n\t\tif (typeof value === 'object' && !Array.isArray(value)) {\n\t\t\tdoRemoveFromValueTree(value, segments);\n\t\t\tif (Object.keys(value).length === 0) {\n\t\t\t\tdelete valueTree[first];\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n */\nexport function getConfigurationValue<T>(config: any, settingPath: string, defaultValue?: T): T {\n\tfunction accessSetting(config: any, path: string[]): any {\n\t\tlet current = config;\n\t\tfor (const component of path) {\n\t\t\tif (typeof current !== 'object' || current === null) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrent = current[component];\n\t\t}\n\t\treturn <T>current;\n\t}\n\n\tconst path = settingPath.split('.');\n\tconst result = accessSetting(config, path);\n\n\treturn typeof result === 'undefined' ? defaultValue : result;\n}\n\nexport function merge(base: any, add: any, overwrite: boolean): void {\n\tObject.keys(add).forEach(key => {\n\t\tif (key !== '__proto__') {\n\t\t\tif (key in base) {\n\t\t\t\tif (types.isObject(base[key]) && types.isObject(add[key])) {\n\t\t\t\t\tmerge(base[key], add[key], overwrite);\n\t\t\t\t} else if (overwrite) {\n\t\t\t\t\tbase[key] = add[key];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbase[key] = add[key];\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function getConfigurationKeys(): string[] {\n\tconst properties = Registry.as<IConfigurationRegistry>(Extensions.Configuration).getConfigurationProperties();\n\treturn Object.keys(properties);\n}\n\nexport function getDefaultValues(): any {\n\tconst valueTreeRoot: any = Object.create(null);\n\tconst properties = Registry.as<IConfigurationRegistry>(Extensions.Configuration).getConfigurationProperties();\n\n\tfor (let key in properties) {\n\t\tlet value = properties[key].default;\n\t\taddToValueTree(valueTreeRoot, key, value, message => console.error(`Conflict in default settings: ${message}`));\n\t}\n\n\treturn valueTreeRoot;\n}\n\nexport function keyFromOverrideIdentifier(overrideIdentifier: string): string {\n\treturn `[${overrideIdentifier}]`;\n}\n\nexport function getMigratedSettingValue<T>(configurationService: IConfigurationService, currentSettingName: string, legacySettingName: string): T {\n\tconst setting = configurationService.inspect<T>(currentSettingName);\n\tconst legacySetting = configurationService.inspect<T>(legacySettingName);\n\n\tif (typeof setting.userValue !== 'undefined' || typeof setting.workspaceValue !== 'undefined' || typeof setting.workspaceFolderValue !== 'undefined') {\n\t\treturn setting.value!;\n\t} else if (typeof legacySetting.userValue !== 'undefined' || typeof legacySetting.workspaceValue !== 'undefined' || typeof legacySetting.workspaceFolderValue !== 'undefined') {\n\t\treturn legacySetting.value!;\n\t} else {\n\t\treturn setting.defaultValue!;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as json from 'vs/base/common/json';\nimport { ResourceMap, getOrSet } from 'vs/base/common/map';\nimport * as arrays from 'vs/base/common/arrays';\nimport * as types from 'vs/base/common/types';\nimport * as objects from 'vs/base/common/objects';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { OVERRIDE_PROPERTY_PATTERN, ConfigurationScope, IConfigurationRegistry, Extensions, IConfigurationPropertySchema, overrideIdentifierFromKey } from 'vs/platform/configuration/common/configurationRegistry';\nimport { IOverrides, addToValueTree, toValuesTree, IConfigurationModel, getConfigurationValue, IConfigurationOverrides, IConfigurationData, getDefaultValues, getConfigurationKeys, removeFromValueTree, toOverrides, IConfigurationValue, ConfigurationTarget, compare, IConfigurationChangeEvent, IConfigurationChange } from 'vs/platform/configuration/common/configuration';\nimport { Workspace } from 'vs/platform/workspace/common/workspace';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { IExtUri } from 'vs/base/common/resources';\n\nexport class ConfigurationModel implements IConfigurationModel {\n\n\tprivate isFrozen: boolean = false;\n\n\tconstructor(\n\t\tprivate _contents: any = {},\n\t\tprivate _keys: string[] = [],\n\t\tprivate _overrides: IOverrides[] = []\n\t) {\n\t}\n\n\tget contents(): any {\n\t\treturn this.checkAndFreeze(this._contents);\n\t}\n\n\tget overrides(): IOverrides[] {\n\t\treturn this.checkAndFreeze(this._overrides);\n\t}\n\n\tget keys(): string[] {\n\t\treturn this.checkAndFreeze(this._keys);\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;\n\t}\n\n\tgetValue<V>(section: string | undefined): V {\n\t\treturn section ? getConfigurationValue<any>(this.contents, section) : this.contents;\n\t}\n\n\tgetOverrideValue<V>(section: string | undefined, overrideIdentifier: string): V | undefined {\n\t\tconst overrideContents = this.getContentsForOverrideIdentifer(overrideIdentifier);\n\t\treturn overrideContents\n\t\t\t? section ? getConfigurationValue<any>(overrideContents, section) : overrideContents\n\t\t\t: undefined;\n\t}\n\n\tgetKeysForOverrideIdentifier(identifier: string): string[] {\n\t\tfor (const override of this.overrides) {\n\t\t\tif (override.identifiers.indexOf(identifier) !== -1) {\n\t\t\t\treturn override.keys;\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n\n\toverride(identifier: string): ConfigurationModel {\n\t\tconst overrideContents = this.getContentsForOverrideIdentifer(identifier);\n\n\t\tif (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {\n\t\t\t// If there are no valid overrides, return self\n\t\t\treturn this;\n\t\t}\n\n\t\tlet contents: any = {};\n\t\tfor (const key of arrays.distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {\n\n\t\t\tlet contentsForKey = this.contents[key];\n\t\t\tlet overrideContentsForKey = overrideContents[key];\n\n\t\t\t// If there are override contents for the key, clone and merge otherwise use base contents\n\t\t\tif (overrideContentsForKey) {\n\t\t\t\t// Clone and merge only if base contents and override contents are of type object otherwise just override\n\t\t\t\tif (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {\n\t\t\t\t\tcontentsForKey = objects.deepClone(contentsForKey);\n\t\t\t\t\tthis.mergeContents(contentsForKey, overrideContentsForKey);\n\t\t\t\t} else {\n\t\t\t\t\tcontentsForKey = overrideContentsForKey;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontents[key] = contentsForKey;\n\t\t}\n\n\t\treturn new ConfigurationModel(contents, this.keys, this.overrides);\n\t}\n\n\tmerge(...others: ConfigurationModel[]): ConfigurationModel {\n\t\tconst contents = objects.deepClone(this.contents);\n\t\tconst overrides = objects.deepClone(this.overrides);\n\t\tconst keys = [...this.keys];\n\n\t\tfor (const other of others) {\n\t\t\tthis.mergeContents(contents, other.contents);\n\n\t\t\tfor (const otherOverride of other.overrides) {\n\t\t\t\tconst [override] = overrides.filter(o => arrays.equals(o.identifiers, otherOverride.identifiers));\n\t\t\t\tif (override) {\n\t\t\t\t\tthis.mergeContents(override.contents, otherOverride.contents);\n\t\t\t\t} else {\n\t\t\t\t\toverrides.push(objects.deepClone(otherOverride));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const key of other.keys) {\n\t\t\t\tif (keys.indexOf(key) === -1) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new ConfigurationModel(contents, keys, overrides);\n\t}\n\n\tfreeze(): ConfigurationModel {\n\t\tthis.isFrozen = true;\n\t\treturn this;\n\t}\n\n\tprivate mergeContents(source: any, target: any): void {\n\t\tfor (const key of Object.keys(target)) {\n\t\t\tif (key in source) {\n\t\t\t\tif (types.isObject(source[key]) && types.isObject(target[key])) {\n\t\t\t\t\tthis.mergeContents(source[key], target[key]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsource[key] = objects.deepClone(target[key]);\n\t\t}\n\t}\n\n\tprivate checkAndFreeze<T>(data: T): T {\n\t\tif (this.isFrozen && !Object.isFrozen(data)) {\n\t\t\treturn objects.deepFreeze(data);\n\t\t}\n\t\treturn data;\n\t}\n\n\tprivate getContentsForOverrideIdentifer(identifier: string): any {\n\t\tfor (const override of this.overrides) {\n\t\t\tif (override.identifiers.indexOf(identifier) !== -1) {\n\t\t\t\treturn override.contents;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\ttoJSON(): IConfigurationModel {\n\t\treturn {\n\t\t\tcontents: this.contents,\n\t\t\toverrides: this.overrides,\n\t\t\tkeys: this.keys\n\t\t};\n\t}\n\n\t// Update methods\n\n\tpublic setValue(key: string, value: any) {\n\t\tthis.addKey(key);\n\t\taddToValueTree(this.contents, key, value, e => { throw new Error(e); });\n\t}\n\n\tpublic removeValue(key: string): void {\n\t\tif (this.removeKey(key)) {\n\t\t\tremoveFromValueTree(this.contents, key);\n\t\t}\n\t}\n\n\tprivate addKey(key: string): void {\n\t\tlet index = this.keys.length;\n\t\tfor (let i = 0; i < index; i++) {\n\t\t\tif (key.indexOf(this.keys[i]) === 0) {\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tthis.keys.splice(index, 1, key);\n\t}\n\n\tprivate removeKey(key: string): boolean {\n\t\tlet index = this.keys.indexOf(key);\n\t\tif (index !== -1) {\n\t\t\tthis.keys.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport class DefaultConfigurationModel extends ConfigurationModel {\n\n\tconstructor() {\n\t\tconst contents = getDefaultValues();\n\t\tconst keys = getConfigurationKeys();\n\t\tconst overrides: IOverrides[] = [];\n\t\tfor (const key of Object.keys(contents)) {\n\t\t\tif (OVERRIDE_PROPERTY_PATTERN.test(key)) {\n\t\t\t\toverrides.push({\n\t\t\t\t\tidentifiers: [overrideIdentifierFromKey(key).trim()],\n\t\t\t\t\tkeys: Object.keys(contents[key]),\n\t\t\t\t\tcontents: toValuesTree(contents[key], message => console.error(`Conflict in default settings file: ${message}`)),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tsuper(contents, keys, overrides);\n\t}\n}\n\nexport interface ConfigurationParseOptions {\n\tscopes: ConfigurationScope[] | undefined;\n\tskipRestricted?: boolean;\n}\n\nexport class ConfigurationModelParser {\n\n\tprivate _raw: any = null;\n\tprivate _configurationModel: ConfigurationModel | null = null;\n\tprivate _restrictedConfigurations: string[] = [];\n\tprivate _parseErrors: any[] = [];\n\n\tconstructor(protected readonly _name: string) { }\n\n\tget configurationModel(): ConfigurationModel {\n\t\treturn this._configurationModel || new ConfigurationModel();\n\t}\n\n\tget restrictedConfigurations(): string[] {\n\t\treturn this._restrictedConfigurations;\n\t}\n\n\tget errors(): any[] {\n\t\treturn this._parseErrors;\n\t}\n\n\tpublic parse(content: string | null | undefined, options?: ConfigurationParseOptions): void {\n\t\tif (!types.isUndefinedOrNull(content)) {\n\t\t\tconst raw = this.doParseContent(content);\n\t\t\tthis.parseRaw(raw, options);\n\t\t}\n\t}\n\n\tpublic reparse(options: ConfigurationParseOptions): void {\n\t\tif (this._raw) {\n\t\t\tthis.parseRaw(this._raw, options);\n\t\t}\n\t}\n\n\tpublic parseRaw(raw: any, options?: ConfigurationParseOptions): void {\n\t\tthis._raw = raw;\n\t\tconst { contents, keys, overrides, restricted } = this.doParseRaw(raw, options);\n\t\tthis._configurationModel = new ConfigurationModel(contents, keys, overrides);\n\t\tthis._restrictedConfigurations = restricted || [];\n\t}\n\n\tprivate doParseContent(content: string): any {\n\t\tlet raw: any = {};\n\t\tlet currentProperty: string | null = null;\n\t\tlet currentParent: any = [];\n\t\tlet previousParents: any[] = [];\n\t\tlet parseErrors: json.ParseError[] = [];\n\n\t\tfunction onValue(value: any) {\n\t\t\tif (Array.isArray(currentParent)) {\n\t\t\t\t(<any[]>currentParent).push(value);\n\t\t\t} else if (currentProperty) {\n\t\t\t\tcurrentParent[currentProperty] = value;\n\t\t\t}\n\t\t}\n\n\t\tlet visitor: json.JSONVisitor = {\n\t\t\tonObjectBegin: () => {\n\t\t\t\tlet object = {};\n\t\t\t\tonValue(object);\n\t\t\t\tpreviousParents.push(currentParent);\n\t\t\t\tcurrentParent = object;\n\t\t\t\tcurrentProperty = null;\n\t\t\t},\n\t\t\tonObjectProperty: (name: string) => {\n\t\t\t\tcurrentProperty = name;\n\t\t\t},\n\t\t\tonObjectEnd: () => {\n\t\t\t\tcurrentParent = previousParents.pop();\n\t\t\t},\n\t\t\tonArrayBegin: () => {\n\t\t\t\tlet array: any[] = [];\n\t\t\t\tonValue(array);\n\t\t\t\tpreviousParents.push(currentParent);\n\t\t\t\tcurrentParent = array;\n\t\t\t\tcurrentProperty = null;\n\t\t\t},\n\t\t\tonArrayEnd: () => {\n\t\t\t\tcurrentParent = previousParents.pop();\n\t\t\t},\n\t\t\tonLiteralValue: onValue,\n\t\t\tonError: (error: json.ParseErrorCode, offset: number, length: number) => {\n\t\t\t\tparseErrors.push({ error, offset, length });\n\t\t\t}\n\t\t};\n\t\tif (content) {\n\t\t\ttry {\n\t\t\t\tjson.visit(content, visitor);\n\t\t\t\traw = currentParent[0] || {};\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(`Error while parsing settings file ${this._name}: ${e}`);\n\t\t\t\tthis._parseErrors = [e];\n\t\t\t}\n\t\t}\n\n\t\treturn raw;\n\t}\n\n\tprotected doParseRaw(raw: any, options?: ConfigurationParseOptions): IConfigurationModel & { restricted?: string[] } {\n\t\tconst configurationProperties = Registry.as<IConfigurationRegistry>(Extensions.Configuration).getConfigurationProperties();\n\t\tconst filtered = this.filter(raw, configurationProperties, true, options);\n\t\traw = filtered.raw;\n\t\tconst contents = toValuesTree(raw, message => console.error(`Conflict in settings file ${this._name}: ${message}`));\n\t\tconst keys = Object.keys(raw);\n\t\tconst overrides: IOverrides[] = toOverrides(raw, message => console.error(`Conflict in settings file ${this._name}: ${message}`));\n\t\treturn { contents, keys, overrides, restricted: filtered.restricted };\n\t}\n\n\tprivate filter(properties: any, configurationProperties: { [qualifiedKey: string]: IConfigurationPropertySchema | undefined }, filterOverriddenProperties: boolean, options?: ConfigurationParseOptions): { raw: {}, restricted: string[] } {\n\t\tif (!options?.scopes && !options?.skipRestricted) {\n\t\t\treturn { raw: properties, restricted: [] };\n\t\t}\n\t\tconst raw: any = {};\n\t\tconst restricted: string[] = [];\n\t\tfor (let key in properties) {\n\t\t\tif (OVERRIDE_PROPERTY_PATTERN.test(key) && filterOverriddenProperties) {\n\t\t\t\tconst result = this.filter(properties[key], configurationProperties, false, options);\n\t\t\t\traw[key] = result.raw;\n\t\t\t\trestricted.push(...result.restricted);\n\t\t\t} else {\n\t\t\t\tconst propertySchema = configurationProperties[key];\n\t\t\t\tconst scope = propertySchema ? typeof propertySchema.scope !== 'undefined' ? propertySchema.scope : ConfigurationScope.WINDOW : undefined;\n\t\t\t\tif (propertySchema?.restricted) {\n\t\t\t\t\trestricted.push(key);\n\t\t\t\t}\n\t\t\t\t// Load unregistered configurations always.\n\t\t\t\tif (scope === undefined || options.scopes === undefined || options.scopes.includes(scope)) {\n\t\t\t\t\tif (!(options.skipRestricted && propertySchema?.restricted)) {\n\t\t\t\t\t\traw[key] = properties[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { raw, restricted };\n\t}\n\n}\n\nexport class UserSettings extends Disposable {\n\n\tprivate readonly parser: ConfigurationModelParser;\n\tprivate readonly parseOptions: ConfigurationParseOptions;\n\tprotected readonly _onDidChange: Emitter<void> = this._register(new Emitter<void>());\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(\n\t\tprivate readonly userSettingsResource: URI,\n\t\tprivate readonly scopes: ConfigurationScope[] | undefined,\n\t\textUri: IExtUri,\n\t\tprivate readonly fileService: IFileService\n\t) {\n\t\tsuper();\n\t\tthis.parser = new ConfigurationModelParser(this.userSettingsResource.toString());\n\t\tthis.parseOptions = { scopes: this.scopes };\n\t\tthis._register(this.fileService.watch(extUri.dirname(this.userSettingsResource)));\n\t\t// Also listen to the resource incase the resource is a symlink - https://github.com/microsoft/vscode/issues/118134\n\t\tthis._register(this.fileService.watch(this.userSettingsResource));\n\t\tthis._register(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.userSettingsResource))(() => this._onDidChange.fire()));\n\t}\n\n\tasync loadConfiguration(): Promise<ConfigurationModel> {\n\t\ttry {\n\t\t\tconst content = await this.fileService.readFile(this.userSettingsResource);\n\t\t\tthis.parser.parse(content.value.toString() || '{}', this.parseOptions);\n\t\t\treturn this.parser.configurationModel;\n\t\t} catch (e) {\n\t\t\treturn new ConfigurationModel();\n\t\t}\n\t}\n\n\treparse(): ConfigurationModel {\n\t\tthis.parser.reparse(this.parseOptions);\n\t\treturn this.parser.configurationModel;\n\t}\n\n\tgetRestrictedSettings(): string[] {\n\t\treturn this.parser.restrictedConfigurations;\n\t}\n}\n\n\nexport class Configuration {\n\n\tprivate _workspaceConsolidatedConfiguration: ConfigurationModel | null = null;\n\tprivate _foldersConsolidatedConfigurations: ResourceMap<ConfigurationModel> = new ResourceMap<ConfigurationModel>();\n\n\tconstructor(\n\t\tprivate _defaultConfiguration: ConfigurationModel,\n\t\tprivate _localUserConfiguration: ConfigurationModel,\n\t\tprivate _remoteUserConfiguration: ConfigurationModel = new ConfigurationModel(),\n\t\tprivate _workspaceConfiguration: ConfigurationModel = new ConfigurationModel(),\n\t\tprivate _folderConfigurations: ResourceMap<ConfigurationModel> = new ResourceMap<ConfigurationModel>(),\n\t\tprivate _memoryConfiguration: ConfigurationModel = new ConfigurationModel(),\n\t\tprivate _memoryConfigurationByResource: ResourceMap<ConfigurationModel> = new ResourceMap<ConfigurationModel>(),\n\t\tprivate _freeze: boolean = true) {\n\t}\n\n\tgetValue(section: string | undefined, overrides: IConfigurationOverrides, workspace: Workspace | undefined): any {\n\t\tconst consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);\n\t\treturn consolidateConfigurationModel.getValue(section);\n\t}\n\n\tupdateValue(key: string, value: any, overrides: IConfigurationOverrides = {}): void {\n\t\tlet memoryConfiguration: ConfigurationModel | undefined;\n\t\tif (overrides.resource) {\n\t\t\tmemoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);\n\t\t\tif (!memoryConfiguration) {\n\t\t\t\tmemoryConfiguration = new ConfigurationModel();\n\t\t\t\tthis._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);\n\t\t\t}\n\t\t} else {\n\t\t\tmemoryConfiguration = this._memoryConfiguration;\n\t\t}\n\n\t\tif (value === undefined) {\n\t\t\tmemoryConfiguration.removeValue(key);\n\t\t} else {\n\t\t\tmemoryConfiguration.setValue(key, value);\n\t\t}\n\n\t\tif (!overrides.resource) {\n\t\t\tthis._workspaceConsolidatedConfiguration = null;\n\t\t}\n\t}\n\n\tinspect<C>(key: string, overrides: IConfigurationOverrides, workspace: Workspace | undefined): IConfigurationValue<C> {\n\t\tconst consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);\n\t\tconst folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);\n\t\tconst memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;\n\n\t\tconst defaultValue = overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue<C>(key) : this._defaultConfiguration.freeze().getValue<C>(key);\n\t\tconst userValue = overrides.overrideIdentifier ? this.userConfiguration.freeze().override(overrides.overrideIdentifier).getValue<C>(key) : this.userConfiguration.freeze().getValue<C>(key);\n\t\tconst userLocalValue = overrides.overrideIdentifier ? this.localUserConfiguration.freeze().override(overrides.overrideIdentifier).getValue<C>(key) : this.localUserConfiguration.freeze().getValue<C>(key);\n\t\tconst userRemoteValue = overrides.overrideIdentifier ? this.remoteUserConfiguration.freeze().override(overrides.overrideIdentifier).getValue<C>(key) : this.remoteUserConfiguration.freeze().getValue<C>(key);\n\t\tconst workspaceValue = workspace ? overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue<C>(key) : this._workspaceConfiguration.freeze().getValue<C>(key) : undefined; //Check on workspace exists or not because _workspaceConfiguration is never null\n\t\tconst workspaceFolderValue = folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue<C>(key) : folderConfigurationModel.freeze().getValue<C>(key) : undefined;\n\t\tconst memoryValue = overrides.overrideIdentifier ? memoryConfigurationModel.override(overrides.overrideIdentifier).getValue<C>(key) : memoryConfigurationModel.getValue<C>(key);\n\t\tconst value = consolidateConfigurationModel.getValue<C>(key);\n\t\tconst overrideIdentifiers: string[] = arrays.distinct(arrays.flatten(consolidateConfigurationModel.overrides.map(override => override.identifiers))).filter(overrideIdentifier => consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== undefined);\n\n\t\treturn {\n\t\t\tdefaultValue: defaultValue,\n\t\t\tuserValue: userValue,\n\t\t\tuserLocalValue: userLocalValue,\n\t\t\tuserRemoteValue: userRemoteValue,\n\t\t\tworkspaceValue: workspaceValue,\n\t\t\tworkspaceFolderValue: workspaceFolderValue,\n\t\t\tmemoryValue: memoryValue,\n\t\t\tvalue,\n\n\t\t\tdefault: defaultValue !== undefined ? { value: this._defaultConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : undefined } : undefined,\n\t\t\tuser: userValue !== undefined ? { value: this.userConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this.userConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : undefined } : undefined,\n\t\t\tuserLocal: userLocalValue !== undefined ? { value: this.localUserConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this.localUserConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : undefined } : undefined,\n\t\t\tuserRemote: userRemoteValue !== undefined ? { value: this.remoteUserConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this.remoteUserConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : undefined } : undefined,\n\t\t\tworkspace: workspaceValue !== undefined ? { value: this._workspaceConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : undefined } : undefined,\n\t\t\tworkspaceFolder: workspaceFolderValue !== undefined ? { value: folderConfigurationModel?.freeze().getValue(key), override: overrides.overrideIdentifier ? folderConfigurationModel?.freeze().getOverrideValue(key, overrides.overrideIdentifier) : undefined } : undefined,\n\t\t\tmemory: memoryValue !== undefined ? { value: memoryConfigurationModel.getValue(key), override: overrides.overrideIdentifier ? memoryConfigurationModel.getOverrideValue(key, overrides.overrideIdentifier) : undefined } : undefined,\n\n\t\t\toverrideIdentifiers: overrideIdentifiers.length ? overrideIdentifiers : undefined\n\t\t};\n\t}\n\n\tkeys(workspace: Workspace | undefined): {\n\t\tdefault: string[];\n\t\tuser: string[];\n\t\tworkspace: string[];\n\t\tworkspaceFolder: string[];\n\t} {\n\t\tconst folderConfigurationModel = this.getFolderConfigurationModelForResource(undefined, workspace);\n\t\treturn {\n\t\t\tdefault: this._defaultConfiguration.freeze().keys,\n\t\t\tuser: this.userConfiguration.freeze().keys,\n\t\t\tworkspace: this._workspaceConfiguration.freeze().keys,\n\t\t\tworkspaceFolder: folderConfigurationModel ? folderConfigurationModel.freeze().keys : []\n\t\t};\n\t}\n\n\tupdateDefaultConfiguration(defaultConfiguration: ConfigurationModel): void {\n\t\tthis._defaultConfiguration = defaultConfiguration;\n\t\tthis._workspaceConsolidatedConfiguration = null;\n\t\tthis._foldersConsolidatedConfigurations.clear();\n\t}\n\n\tupdateLocalUserConfiguration(localUserConfiguration: ConfigurationModel): void {\n\t\tthis._localUserConfiguration = localUserConfiguration;\n\t\tthis._userConfiguration = null;\n\t\tthis._workspaceConsolidatedConfiguration = null;\n\t\tthis._foldersConsolidatedConfigurations.clear();\n\t}\n\n\tupdateRemoteUserConfiguration(remoteUserConfiguration: ConfigurationModel): void {\n\t\tthis._remoteUserConfiguration = remoteUserConfiguration;\n\t\tthis._userConfiguration = null;\n\t\tthis._workspaceConsolidatedConfiguration = null;\n\t\tthis._foldersConsolidatedConfigurations.clear();\n\t}\n\n\tupdateWorkspaceConfiguration(workspaceConfiguration: ConfigurationModel): void {\n\t\tthis._workspaceConfiguration = workspaceConfiguration;\n\t\tthis._workspaceConsolidatedConfiguration = null;\n\t\tthis._foldersConsolidatedConfigurations.clear();\n\t}\n\n\tupdateFolderConfiguration(resource: URI, configuration: ConfigurationModel): void {\n\t\tthis._folderConfigurations.set(resource, configuration);\n\t\tthis._foldersConsolidatedConfigurations.delete(resource);\n\t}\n\n\tdeleteFolderConfiguration(resource: URI): void {\n\t\tthis.folderConfigurations.delete(resource);\n\t\tthis._foldersConsolidatedConfigurations.delete(resource);\n\t}\n\n\tcompareAndUpdateDefaultConfiguration(defaults: ConfigurationModel, keys: string[]): IConfigurationChange {\n\t\tconst overrides: [string, string[]][] = keys\n\t\t\t.filter(key => OVERRIDE_PROPERTY_PATTERN.test(key))\n\t\t\t.map(key => {\n\t\t\t\tconst overrideIdentifier = overrideIdentifierFromKey(key);\n\t\t\t\tconst fromKeys = this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier);\n\t\t\t\tconst toKeys = defaults.getKeysForOverrideIdentifier(overrideIdentifier);\n\t\t\t\tconst keys = [\n\t\t\t\t\t...toKeys.filter(key => fromKeys.indexOf(key) === -1),\n\t\t\t\t\t...fromKeys.filter(key => toKeys.indexOf(key) === -1),\n\t\t\t\t\t...fromKeys.filter(key => !objects.equals(this._defaultConfiguration.override(overrideIdentifier).getValue(key), defaults.override(overrideIdentifier).getValue(key)))\n\t\t\t\t];\n\t\t\t\treturn [overrideIdentifier, keys];\n\t\t\t});\n\t\tthis.updateDefaultConfiguration(defaults);\n\t\treturn { keys, overrides };\n\t}\n\n\tcompareAndUpdateLocalUserConfiguration(user: ConfigurationModel): IConfigurationChange {\n\t\tconst { added, updated, removed, overrides } = compare(this.localUserConfiguration, user);\n\t\tconst keys = [...added, ...updated, ...removed];\n\t\tif (keys.length) {\n\t\t\tthis.updateLocalUserConfiguration(user);\n\t\t}\n\t\treturn { keys, overrides };\n\t}\n\n\tcompareAndUpdateRemoteUserConfiguration(user: ConfigurationModel): IConfigurationChange {\n\t\tconst { added, updated, removed, overrides } = compare(this.remoteUserConfiguration, user);\n\t\tlet keys = [...added, ...updated, ...removed];\n\t\tif (keys.length) {\n\t\t\tthis.updateRemoteUserConfiguration(user);\n\t\t}\n\t\treturn { keys, overrides };\n\t}\n\n\tcompareAndUpdateWorkspaceConfiguration(workspaceConfiguration: ConfigurationModel): IConfigurationChange {\n\t\tconst { added, updated, removed, overrides } = compare(this.workspaceConfiguration, workspaceConfiguration);\n\t\tlet keys = [...added, ...updated, ...removed];\n\t\tif (keys.length) {\n\t\t\tthis.updateWorkspaceConfiguration(workspaceConfiguration);\n\t\t}\n\t\treturn { keys, overrides };\n\t}\n\n\tcompareAndUpdateFolderConfiguration(resource: URI, folderConfiguration: ConfigurationModel): IConfigurationChange {\n\t\tconst currentFolderConfiguration = this.folderConfigurations.get(resource);\n\t\tconst { added, updated, removed, overrides } = compare(currentFolderConfiguration, folderConfiguration);\n\t\tlet keys = [...added, ...updated, ...removed];\n\t\tif (keys.length || !currentFolderConfiguration) {\n\t\t\tthis.updateFolderConfiguration(resource, folderConfiguration);\n\t\t}\n\t\treturn { keys, overrides };\n\t}\n\n\tcompareAndDeleteFolderConfiguration(folder: URI): IConfigurationChange {\n\t\tconst folderConfig = this.folderConfigurations.get(folder);\n\t\tif (!folderConfig) {\n\t\t\tthrow new Error('Unknown folder');\n\t\t}\n\t\tthis.deleteFolderConfiguration(folder);\n\t\tconst { added, updated, removed, overrides } = compare(folderConfig, undefined);\n\t\treturn { keys: [...added, ...updated, ...removed], overrides };\n\t}\n\n\tget defaults(): ConfigurationModel {\n\t\treturn this._defaultConfiguration;\n\t}\n\n\tprivate _userConfiguration: ConfigurationModel | null = null;\n\tget userConfiguration(): ConfigurationModel {\n\t\tif (!this._userConfiguration) {\n\t\t\tthis._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);\n\t\t\tif (this._freeze) {\n\t\t\t\tthis._userConfiguration.freeze();\n\t\t\t}\n\t\t}\n\t\treturn this._userConfiguration;\n\t}\n\n\tget localUserConfiguration(): ConfigurationModel {\n\t\treturn this._localUserConfiguration;\n\t}\n\n\tget remoteUserConfiguration(): ConfigurationModel {\n\t\treturn this._remoteUserConfiguration;\n\t}\n\n\tget workspaceConfiguration(): ConfigurationModel {\n\t\treturn this._workspaceConfiguration;\n\t}\n\n\tprotected get folderConfigurations(): ResourceMap<ConfigurationModel> {\n\t\treturn this._folderConfigurations;\n\t}\n\n\tprivate getConsolidateConfigurationModel(overrides: IConfigurationOverrides, workspace: Workspace | undefined): ConfigurationModel {\n\t\tlet configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);\n\t\treturn overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;\n\t}\n\n\tprivate getConsolidatedConfigurationModelForResource({ resource }: IConfigurationOverrides, workspace: Workspace | undefined): ConfigurationModel {\n\t\tlet consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n\n\t\tif (workspace && resource) {\n\t\t\tconst root = workspace.getFolder(resource);\n\t\t\tif (root) {\n\t\t\t\tconsolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;\n\t\t\t}\n\t\t\tconst memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);\n\t\t\tif (memoryConfigurationForResource) {\n\t\t\t\tconsolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);\n\t\t\t}\n\t\t}\n\n\t\treturn consolidateConfiguration;\n\t}\n\n\tprivate getWorkspaceConsolidatedConfiguration(): ConfigurationModel {\n\t\tif (!this._workspaceConsolidatedConfiguration) {\n\t\t\tthis._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);\n\t\t\tif (this._freeze) {\n\t\t\t\tthis._workspaceConfiguration = this._workspaceConfiguration.freeze();\n\t\t\t}\n\t\t}\n\t\treturn this._workspaceConsolidatedConfiguration;\n\t}\n\n\tprivate getFolderConsolidatedConfiguration(folder: URI): ConfigurationModel {\n\t\tlet folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);\n\t\tif (!folderConsolidatedConfiguration) {\n\t\t\tconst workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n\t\t\tconst folderConfiguration = this._folderConfigurations.get(folder);\n\t\t\tif (folderConfiguration) {\n\t\t\t\tfolderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);\n\t\t\t\tif (this._freeze) {\n\t\t\t\t\tfolderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();\n\t\t\t\t}\n\t\t\t\tthis._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);\n\t\t\t} else {\n\t\t\t\tfolderConsolidatedConfiguration = workspaceConsolidateConfiguration;\n\t\t\t}\n\t\t}\n\t\treturn folderConsolidatedConfiguration;\n\t}\n\n\tprivate getFolderConfigurationModelForResource(resource: URI | null | undefined, workspace: Workspace | undefined): ConfigurationModel | undefined {\n\t\tif (workspace && resource) {\n\t\t\tconst root = workspace.getFolder(resource);\n\t\t\tif (root) {\n\t\t\t\treturn this._folderConfigurations.get(root.uri);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\ttoData(): IConfigurationData {\n\t\treturn {\n\t\t\tdefaults: {\n\t\t\t\tcontents: this._defaultConfiguration.contents,\n\t\t\t\toverrides: this._defaultConfiguration.overrides,\n\t\t\t\tkeys: this._defaultConfiguration.keys\n\t\t\t},\n\t\t\tuser: {\n\t\t\t\tcontents: this.userConfiguration.contents,\n\t\t\t\toverrides: this.userConfiguration.overrides,\n\t\t\t\tkeys: this.userConfiguration.keys\n\t\t\t},\n\t\t\tworkspace: {\n\t\t\t\tcontents: this._workspaceConfiguration.contents,\n\t\t\t\toverrides: this._workspaceConfiguration.overrides,\n\t\t\t\tkeys: this._workspaceConfiguration.keys\n\t\t\t},\n\t\t\tfolders: [...this._folderConfigurations.keys()].reduce<[UriComponents, IConfigurationModel][]>((result, folder) => {\n\t\t\t\tconst { contents, overrides, keys } = this._folderConfigurations.get(folder)!;\n\t\t\t\tresult.push([folder, { contents, overrides, keys }]);\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t};\n\t}\n\n\tallKeys(): string[] {\n\t\tconst keys: Set<string> = new Set<string>();\n\t\tthis._defaultConfiguration.freeze().keys.forEach(key => keys.add(key));\n\t\tthis.userConfiguration.freeze().keys.forEach(key => keys.add(key));\n\t\tthis._workspaceConfiguration.freeze().keys.forEach(key => keys.add(key));\n\t\tthis._folderConfigurations.forEach(folderConfiguraiton => folderConfiguraiton.freeze().keys.forEach(key => keys.add(key)));\n\t\treturn [...keys.values()];\n\t}\n\n\tprotected getAllKeysForOverrideIdentifier(overrideIdentifier: string): string[] {\n\t\tconst keys: Set<string> = new Set<string>();\n\t\tthis._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));\n\t\tthis.userConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));\n\t\tthis._workspaceConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));\n\t\tthis._folderConfigurations.forEach(folderConfiguraiton => folderConfiguraiton.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key)));\n\t\treturn [...keys.values()];\n\t}\n\n\tstatic parse(data: IConfigurationData): Configuration {\n\t\tconst defaultConfiguration = this.parseConfigurationModel(data.defaults);\n\t\tconst userConfiguration = this.parseConfigurationModel(data.user);\n\t\tconst workspaceConfiguration = this.parseConfigurationModel(data.workspace);\n\t\tconst folders: ResourceMap<ConfigurationModel> = data.folders.reduce((result, value) => {\n\t\t\tresult.set(URI.revive(value[0]), this.parseConfigurationModel(value[1]));\n\t\t\treturn result;\n\t\t}, new ResourceMap<ConfigurationModel>());\n\t\treturn new Configuration(defaultConfiguration, userConfiguration, new ConfigurationModel(), workspaceConfiguration, folders, new ConfigurationModel(), new ResourceMap<ConfigurationModel>(), false);\n\t}\n\n\tprivate static parseConfigurationModel(model: IConfigurationModel): ConfigurationModel {\n\t\treturn new ConfigurationModel(model.contents, model.keys, model.overrides).freeze();\n\t}\n\n}\n\nexport function mergeChanges(...changes: IConfigurationChange[]): IConfigurationChange {\n\tif (changes.length === 0) {\n\t\treturn { keys: [], overrides: [] };\n\t}\n\tif (changes.length === 1) {\n\t\treturn changes[0];\n\t}\n\tconst keysSet = new Set<string>();\n\tconst overridesMap = new Map<string, Set<string>>();\n\tfor (const change of changes) {\n\t\tchange.keys.forEach(key => keysSet.add(key));\n\t\tchange.overrides.forEach(([identifier, keys]) => {\n\t\t\tconst result = getOrSet(overridesMap, identifier, new Set<string>());\n\t\t\tkeys.forEach(key => result.add(key));\n\t\t});\n\t}\n\tconst overrides: [string, string[]][] = [];\n\toverridesMap.forEach((keys, identifier) => overrides.push([identifier, [...keys.values()]]));\n\treturn { keys: [...keysSet.values()], overrides };\n}\n\nexport class ConfigurationChangeEvent implements IConfigurationChangeEvent {\n\n\tprivate readonly affectedKeysTree: any;\n\treadonly affectedKeys: string[];\n\tsource!: ConfigurationTarget;\n\tsourceConfig: any;\n\n\tconstructor(readonly change: IConfigurationChange, private readonly previous: { workspace?: Workspace, data: IConfigurationData } | undefined, private readonly currentConfiguraiton: Configuration, private readonly currentWorkspace?: Workspace) {\n\t\tconst keysSet = new Set<string>();\n\t\tchange.keys.forEach(key => keysSet.add(key));\n\t\tchange.overrides.forEach(([, keys]) => keys.forEach(key => keysSet.add(key)));\n\t\tthis.affectedKeys = [...keysSet.values()];\n\n\t\tconst configurationModel = new ConfigurationModel();\n\t\tthis.affectedKeys.forEach(key => configurationModel.setValue(key, {}));\n\t\tthis.affectedKeysTree = configurationModel.contents;\n\t}\n\n\tprivate _previousConfiguration: Configuration | undefined = undefined;\n\tget previousConfiguration(): Configuration | undefined {\n\t\tif (!this._previousConfiguration && this.previous) {\n\t\t\tthis._previousConfiguration = Configuration.parse(this.previous.data);\n\t\t}\n\t\treturn this._previousConfiguration;\n\t}\n\n\taffectsConfiguration(section: string, overrides?: IConfigurationOverrides): boolean {\n\t\tif (this.doesAffectedKeysTreeContains(this.affectedKeysTree, section)) {\n\t\t\tif (overrides) {\n\t\t\t\tconst value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, this.previous?.workspace) : undefined;\n\t\t\t\tconst value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);\n\t\t\t\treturn !objects.equals(value1, value2);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate doesAffectedKeysTreeContains(affectedKeysTree: any, section: string): boolean {\n\t\tlet requestedTree = toValuesTree({ [section]: true }, () => { });\n\n\t\tlet key;\n\t\twhile (typeof requestedTree === 'object' && (key = Object.keys(requestedTree)[0])) { // Only one key should present, since we added only one property\n\t\t\taffectedKeysTree = affectedKeysTree[key];\n\t\t\tif (!affectedKeysTree) {\n\t\t\t\treturn false; // Requested tree is not found\n\t\t\t}\n\t\t\trequestedTree = requestedTree[key];\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class AllKeysConfigurationChangeEvent extends ConfigurationChangeEvent {\n\tconstructor(configuration: Configuration, workspace: Workspace, source: ConfigurationTarget, sourceConfig: any) {\n\t\tsuper({ keys: configuration.allKeys(), overrides: [] }, undefined, configuration, workspace);\n\t\tthis.source = source;\n\t\tthis.sourceConfig = sourceConfig;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { IConfigurationRegistry, Extensions } from 'vs/platform/configuration/common/configurationRegistry';\nimport { IDisposable, Disposable } from 'vs/base/common/lifecycle';\nimport { IConfigurationService, IConfigurationChangeEvent, IConfigurationOverrides, ConfigurationTarget, isConfigurationOverrides, IConfigurationData, IConfigurationValue, IConfigurationChange } from 'vs/platform/configuration/common/configuration';\nimport { DefaultConfigurationModel, Configuration, ConfigurationModel, ConfigurationChangeEvent, UserSettings } from 'vs/platform/configuration/common/configurationModels';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { URI } from 'vs/base/common/uri';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { extUriBiasedIgnorePathCase } from 'vs/base/common/resources';\n\nexport class ConfigurationService extends Disposable implements IConfigurationService, IDisposable {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate configuration: Configuration;\n\tprivate userConfiguration: UserSettings;\n\tprivate readonly reloadConfigurationScheduler: RunOnceScheduler;\n\n\tprivate readonly _onDidChangeConfiguration: Emitter<IConfigurationChangeEvent> = this._register(new Emitter<IConfigurationChangeEvent>());\n\treadonly onDidChangeConfiguration: Event<IConfigurationChangeEvent> = this._onDidChangeConfiguration.event;\n\n\tconstructor(\n\t\tprivate readonly settingsResource: URI,\n\t\tfileService: IFileService\n\t) {\n\t\tsuper();\n\t\tthis.userConfiguration = this._register(new UserSettings(this.settingsResource, undefined, extUriBiasedIgnorePathCase, fileService));\n\t\tthis.configuration = new Configuration(new DefaultConfigurationModel(), new ConfigurationModel());\n\n\t\tthis.reloadConfigurationScheduler = this._register(new RunOnceScheduler(() => this.reloadConfiguration(), 50));\n\t\tthis._register(Registry.as<IConfigurationRegistry>(Extensions.Configuration).onDidUpdateConfiguration(configurationProperties => this.onDidDefaultConfigurationChange(configurationProperties)));\n\t\tthis._register(this.userConfiguration.onDidChange(() => this.reloadConfigurationScheduler.schedule()));\n\t}\n\n\tasync initialize(): Promise<void> {\n\t\tconst userConfiguration = await this.userConfiguration.loadConfiguration();\n\t\tthis.configuration = new Configuration(new DefaultConfigurationModel(), userConfiguration);\n\t}\n\n\tgetConfigurationData(): IConfigurationData {\n\t\treturn this.configuration.toData();\n\t}\n\n\tgetValue<T>(): T;\n\tgetValue<T>(section: string): T;\n\tgetValue<T>(overrides: IConfigurationOverrides): T;\n\tgetValue<T>(section: string, overrides: IConfigurationOverrides): T;\n\tgetValue(arg1?: any, arg2?: any): any {\n\t\tconst section = typeof arg1 === 'string' ? arg1 : undefined;\n\t\tconst overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};\n\t\treturn this.configuration.getValue(section, overrides, undefined);\n\t}\n\n\tupdateValue(key: string, value: any): Promise<void>;\n\tupdateValue(key: string, value: any, overrides: IConfigurationOverrides): Promise<void>;\n\tupdateValue(key: string, value: any, target: ConfigurationTarget): Promise<void>;\n\tupdateValue(key: string, value: any, overrides: IConfigurationOverrides, target: ConfigurationTarget): Promise<void>;\n\tupdateValue(key: string, value: any, arg3?: any, arg4?: any): Promise<void> {\n\t\treturn Promise.reject(new Error('not supported'));\n\t}\n\n\tinspect<T>(key: string): IConfigurationValue<T> {\n\t\treturn this.configuration.inspect<T>(key, {}, undefined);\n\t}\n\n\tkeys(): {\n\t\tdefault: string[];\n\t\tuser: string[];\n\t\tworkspace: string[];\n\t\tworkspaceFolder: string[];\n\t} {\n\t\treturn this.configuration.keys(undefined);\n\t}\n\n\tasync reloadConfiguration(): Promise<void> {\n\t\tconst configurationModel = await this.userConfiguration.loadConfiguration();\n\t\tthis.onDidChangeUserConfiguration(configurationModel);\n\t}\n\n\tprivate onDidChangeUserConfiguration(userConfigurationModel: ConfigurationModel): void {\n\t\tconst previous = this.configuration.toData();\n\t\tconst change = this.configuration.compareAndUpdateLocalUserConfiguration(userConfigurationModel);\n\t\tthis.trigger(change, previous, ConfigurationTarget.USER);\n\t}\n\n\tprivate onDidDefaultConfigurationChange(keys: string[]): void {\n\t\tconst previous = this.configuration.toData();\n\t\tconst change = this.configuration.compareAndUpdateDefaultConfiguration(new DefaultConfigurationModel(), keys);\n\t\tthis.trigger(change, previous, ConfigurationTarget.DEFAULT);\n\t}\n\n\tprivate trigger(configurationChange: IConfigurationChange, previous: IConfigurationData, source: ConfigurationTarget): void {\n\t\tconst event = new ConfigurationChangeEvent(configurationChange, { data: previous }, this.configuration);\n\t\tevent.source = source;\n\t\tevent.sourceConfig = this.getTargetConfiguration(source);\n\t\tthis._onDidChangeConfiguration.fire(event);\n\t}\n\n\tprivate getTargetConfiguration(target: ConfigurationTarget): any {\n\t\tswitch (target) {\n\t\t\tcase ConfigurationTarget.DEFAULT:\n\t\t\t\treturn this.configuration.defaults.contents;\n\t\t\tcase ConfigurationTarget.USER:\n\t\t\t\treturn this.configuration.localUserConfiguration.contents;\n\t\t}\n\t\treturn {};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IConfigurationRegistry, Extensions, ConfigurationScope, IConfigurationNode } from 'vs/platform/configuration/common/configurationRegistry';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { streamToBuffer } from 'vs/base/common/buffer';\nimport { IRequestOptions, IRequestContext } from 'vs/base/parts/request/common/request';\n\nexport const IRequestService = createDecorator<IRequestService>('requestService');\n\nexport interface IRequestService {\n\treadonly _serviceBrand: undefined;\n\n\trequest(options: IRequestOptions, token: CancellationToken): Promise<IRequestContext>;\n\n\tresolveProxy(url: string): Promise<string | undefined>;\n}\n\nexport function isSuccess(context: IRequestContext): boolean {\n\treturn (context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;\n}\n\nfunction hasNoContent(context: IRequestContext): boolean {\n\treturn context.res.statusCode === 204;\n}\n\nexport async function asText(context: IRequestContext): Promise<string | null> {\n\tif (!isSuccess(context)) {\n\t\tthrow new Error('Server returned ' + context.res.statusCode);\n\t}\n\tif (hasNoContent(context)) {\n\t\treturn null;\n\t}\n\tconst buffer = await streamToBuffer(context.stream);\n\treturn buffer.toString();\n}\n\nexport async function asJson<T = {}>(context: IRequestContext): Promise<T | null> {\n\tif (!isSuccess(context)) {\n\t\tthrow new Error('Server returned ' + context.res.statusCode);\n\t}\n\tif (hasNoContent(context)) {\n\t\treturn null;\n\t}\n\tconst buffer = await streamToBuffer(context.stream);\n\tconst str = buffer.toString();\n\ttry {\n\t\treturn JSON.parse(str);\n\t} catch (err) {\n\t\terr.message += ':\\n' + str;\n\t\tthrow err;\n\t}\n}\n\n\nexport interface IHTTPConfiguration {\n\thttp?: {\n\t\tproxy?: string;\n\t\tproxyStrictSSL?: boolean;\n\t\tproxyAuthorization?: string;\n\t};\n}\n\nexport function updateProxyConfigurationsScope(scope: ConfigurationScope): void {\n\tregisterProxyConfigurations(scope);\n}\n\nlet proxyConfiguration: IConfigurationNode | undefined;\nfunction registerProxyConfigurations(scope: ConfigurationScope): void {\n\tconst configurationRegistry = Registry.as<IConfigurationRegistry>(Extensions.Configuration);\n\tif (proxyConfiguration) {\n\t\tconfigurationRegistry.deregisterConfigurations([proxyConfiguration]);\n\t}\n\tproxyConfiguration = {\n\t\tid: 'http',\n\t\torder: 15,\n\t\ttitle: localize('httpConfigurationTitle', \"HTTP\"),\n\t\ttype: 'object',\n\t\tscope,\n\t\tproperties: {\n\t\t\t'http.proxy': {\n\t\t\t\ttype: 'string',\n\t\t\t\tpattern: '^https?://([^:]*(:[^@]*)?@)?([^:]+|\\\\[[:0-9a-fA-F]+\\\\])(:\\\\d+)?/?$|^$',\n\t\t\t\tmarkdownDescription: localize('proxy', \"The proxy setting to use. If not set, will be inherited from the `http_proxy` and `https_proxy` environment variables.\"),\n\t\t\t\trestricted: true\n\t\t\t},\n\t\t\t'http.proxyStrictSSL': {\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: localize('strictSSL', \"Controls whether the proxy server certificate should be verified against the list of supplied CAs.\"),\n\t\t\t\trestricted: true\n\t\t\t},\n\t\t\t'http.proxyAuthorization': {\n\t\t\t\ttype: ['null', 'string'],\n\t\t\t\tdefault: null,\n\t\t\t\tmarkdownDescription: localize('proxyAuthorization', \"The value to send as the `Proxy-Authorization` header for every network request.\"),\n\t\t\t\trestricted: true\n\t\t\t},\n\t\t\t'http.proxySupport': {\n\t\t\t\ttype: 'string',\n\t\t\t\tenum: ['off', 'on', 'fallback', 'override'],\n\t\t\t\tenumDescriptions: [\n\t\t\t\t\tlocalize('proxySupportOff', \"Disable proxy support for extensions.\"),\n\t\t\t\t\tlocalize('proxySupportOn', \"Enable proxy support for extensions.\"),\n\t\t\t\t\tlocalize('proxySupportFallback', \"Enable proxy support for extensions, fall back to request options, when no proxy found.\"),\n\t\t\t\t\tlocalize('proxySupportOverride', \"Enable proxy support for extensions, override request options.\"),\n\t\t\t\t],\n\t\t\t\tdefault: 'override',\n\t\t\t\tdescription: localize('proxySupport', \"Use the proxy support for extensions.\"),\n\t\t\t\trestricted: true\n\t\t\t},\n\t\t\t'http.systemCertificates': {\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: true,\n\t\t\t\tdescription: localize('systemCertificates', \"Controls whether CA certificates should be loaded from the OS. (On Windows and macOS, a reload of the window is required after turning this off.)\"),\n\t\t\t\trestricted: true\n\t\t\t}\n\t\t}\n\t};\n\tconfigurationRegistry.registerConfiguration(proxyConfiguration);\n}\n\nregisterProxyConfigurations(ConfigurationScope.MACHINE);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Url, parse as parseUrl } from 'url';\nimport { isBoolean } from 'vs/base/common/types';\n\nexport type Agent = any;\n\nfunction getSystemProxyURI(requestURL: Url, env: typeof process.env): string | null {\n\tif (requestURL.protocol === 'http:') {\n\t\treturn env.HTTP_PROXY || env.http_proxy || null;\n\t} else if (requestURL.protocol === 'https:') {\n\t\treturn env.HTTPS_PROXY || env.https_proxy || env.HTTP_PROXY || env.http_proxy || null;\n\t}\n\n\treturn null;\n}\n\nexport interface IOptions {\n\tproxyUrl?: string;\n\tstrictSSL?: boolean;\n}\n\nexport async function getProxyAgent(rawRequestURL: string, env: typeof process.env, options: IOptions = {}): Promise<Agent> {\n\tconst requestURL = parseUrl(rawRequestURL);\n\tconst proxyURL = options.proxyUrl || getSystemProxyURI(requestURL, env);\n\n\tif (!proxyURL) {\n\t\treturn null;\n\t}\n\n\tconst proxyEndpoint = parseUrl(proxyURL);\n\n\tif (!/^https?:$/.test(proxyEndpoint.protocol || '')) {\n\t\treturn null;\n\t}\n\n\tconst opts = {\n\t\thost: proxyEndpoint.hostname || '',\n\t\tport: proxyEndpoint.port || (proxyEndpoint.protocol === 'https' ? '443' : '80'),\n\t\tauth: proxyEndpoint.auth,\n\t\trejectUnauthorized: isBoolean(options.strictSSL) ? options.strictSSL : true,\n\t};\n\n\treturn requestURL.protocol === 'http:'\n\t\t? new (await import('http-proxy-agent'))(opts as any as Url)\n\t\t: new (await import('https-proxy-agent'))(opts);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { isUUID, generateUuid } from 'vs/base/common/uuid';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\nexport async function getServiceMachineId(environmentService: IEnvironmentService, fileService: IFileService, storageService: {\n\tget: (key: string, scope: StorageScope, fallbackValue?: string | undefined) => string | undefined,\n\tstore: (key: string, value: string, scope: StorageScope, target: StorageTarget) => void\n} | undefined): Promise<string> {\n\tlet uuid: string | null = storageService ? storageService.get('storage.serviceMachineId', StorageScope.GLOBAL) || null : null;\n\tif (uuid) {\n\t\treturn uuid;\n\t}\n\ttry {\n\t\tconst contents = await fileService.readFile(environmentService.serviceMachineIdResource);\n\t\tconst value = contents.value.toString();\n\t\tuuid = isUUID(value) ? value : null;\n\t} catch (e) {\n\t\tuuid = null;\n\t}\n\n\tif (!uuid) {\n\t\tuuid = generateUuid();\n\t\ttry {\n\t\t\tawait fileService.writeFile(environmentService.serviceMachineIdResource, VSBuffer.fromString(uuid));\n\t\t} catch (error) {\n\t\t\t//noop\n\t\t}\n\t}\n\tif (storageService) {\n\t\tstorageService.store('storage.serviceMachineId', uuid, StorageScope.GLOBAL, StorageTarget.MACHINE);\n\t}\n\treturn uuid;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport const IStateService = createDecorator<IStateService>('stateService');\n\nexport interface IStateService {\n\treadonly _serviceBrand: undefined;\n\n\tgetItem<T>(key: string, defaultValue: T): T;\n\tgetItem<T>(key: string, defaultValue?: T): T | undefined;\n\n\tsetItem(key: string, data?: object | string | number | boolean | undefined | null): void;\n\n\tremoveItem(key: string): void;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { writeFileSync } from 'vs/base/node/pfs';\nimport { isUndefined, isUndefinedOrNull } from 'vs/base/common/types';\nimport { IStateService } from 'vs/platform/state/node/state';\nimport { ILogService } from 'vs/platform/log/common/log';\n\ntype StorageDatabase = { [key: string]: any; };\n\nexport class FileStorage {\n\n\tprivate _database: StorageDatabase | null = null;\n\tprivate lastFlushedSerializedDatabase: string | null = null;\n\n\tconstructor(private dbPath: string, private onError: (error: Error) => void) { }\n\n\tprivate get database(): StorageDatabase {\n\t\tif (!this._database) {\n\t\t\tthis._database = this.loadSync();\n\t\t}\n\n\t\treturn this._database;\n\t}\n\n\tasync init(): Promise<void> {\n\t\tif (this._database) {\n\t\t\treturn; // return if database was already loaded\n\t\t}\n\n\t\tconst database = await this.loadAsync();\n\n\t\tif (this._database) {\n\t\t\treturn; // return if database was already loaded\n\t\t}\n\n\t\tthis._database = database;\n\t}\n\n\tprivate loadSync(): StorageDatabase {\n\t\ttry {\n\t\t\tthis.lastFlushedSerializedDatabase = fs.readFileSync(this.dbPath).toString();\n\n\t\t\treturn JSON.parse(this.lastFlushedSerializedDatabase);\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.onError(error);\n\t\t\t}\n\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tprivate async loadAsync(): Promise<StorageDatabase> {\n\t\ttry {\n\t\t\tthis.lastFlushedSerializedDatabase = (await fs.promises.readFile(this.dbPath)).toString();\n\n\t\t\treturn JSON.parse(this.lastFlushedSerializedDatabase);\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.onError(error);\n\t\t\t}\n\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tgetItem<T>(key: string, defaultValue: T): T;\n\tgetItem<T>(key: string, defaultValue?: T): T | undefined;\n\tgetItem<T>(key: string, defaultValue?: T): T | undefined {\n\t\tconst res = this.database[key];\n\t\tif (isUndefinedOrNull(res)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tsetItem(key: string, data?: object | string | number | boolean | undefined | null): void {\n\n\t\t// Remove an item when it is undefined or null\n\t\tif (isUndefinedOrNull(data)) {\n\t\t\treturn this.removeItem(key);\n\t\t}\n\n\t\t// Shortcut for primitives that did not change\n\t\tif (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {\n\t\t\tif (this.database[key] === data) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.database[key] = data;\n\t\tthis.saveSync();\n\t}\n\n\tremoveItem(key: string): void {\n\n\t\t// Only update if the key is actually present (not undefined)\n\t\tif (!isUndefined(this.database[key])) {\n\t\t\tthis.database[key] = undefined;\n\t\t\tthis.saveSync();\n\t\t}\n\t}\n\n\tprivate saveSync(): void {\n\t\tconst serializedDatabase = JSON.stringify(this.database, null, 4);\n\t\tif (serializedDatabase === this.lastFlushedSerializedDatabase) {\n\t\t\treturn; // return early if the database has not changed\n\t\t}\n\n\t\ttry {\n\t\t\twriteFileSync(this.dbPath, serializedDatabase); // permission issue can happen here\n\t\t\tthis.lastFlushedSerializedDatabase = serializedDatabase;\n\t\t} catch (error) {\n\t\t\tthis.onError(error);\n\t\t}\n\t}\n}\n\nexport class StateService implements IStateService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static readonly STATE_FILE = 'storage.json';\n\n\tprivate fileStorage: FileStorage;\n\n\tconstructor(\n\t\t@INativeEnvironmentService environmentService: INativeEnvironmentService,\n\t\t@ILogService logService: ILogService\n\t) {\n\t\tthis.fileStorage = new FileStorage(path.join(environmentService.userDataPath, StateService.STATE_FILE), error => logService.error(error));\n\t}\n\n\tinit(): Promise<void> {\n\t\treturn this.fileStorage.init();\n\t}\n\n\tgetItem<T>(key: string, defaultValue: T): T;\n\tgetItem<T>(key: string, defaultValue?: T): T | undefined;\n\tgetItem<T>(key: string, defaultValue?: T): T | undefined {\n\t\treturn this.fileStorage.getItem(key, defaultValue);\n\t}\n\n\tsetItem(key: string, data?: object | string | number | boolean | undefined | null): void {\n\t\tthis.fileStorage.setItem(key, data);\n\t}\n\n\tremoveItem(key: string): void {\n\t\tthis.fileStorage.removeItem(key);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event, Emitter, PauseableEmitter } from 'vs/base/common/event';\nimport { Disposable, dispose, MutableDisposable } from 'vs/base/common/lifecycle';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\nimport { IWorkspaceInitializationPayload } from 'vs/platform/workspaces/common/workspaces';\nimport { InMemoryStorageDatabase, IStorage, Storage } from 'vs/base/parts/storage/common/storage';\nimport { Promises, RunOnceScheduler, runWhenIdle } from 'vs/base/common/async';\n\nexport const IS_NEW_KEY = '__$__isNewStorageMarker';\nconst TARGET_KEY = '__$__targetStorageMarker';\n\nexport const IStorageService = createDecorator<IStorageService>('storageService');\n\nexport enum WillSaveStateReason {\n\n\t/**\n\t * No specific reason to save state.\n\t */\n\tNONE,\n\n\t/**\n\t * A hint that the workbench is about to shutdown.\n\t */\n\tSHUTDOWN\n}\n\nexport interface IWillSaveStateEvent {\n\treason: WillSaveStateReason;\n}\n\nexport interface IStorageService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted whenever data is updated or deleted.\n\t */\n\treadonly onDidChangeValue: Event<IStorageValueChangeEvent>;\n\n\t/**\n\t * Emitted whenever target of a storage entry changes.\n\t */\n\treadonly onDidChangeTarget: Event<IStorageTargetChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is about to persist. This is the right time\n\t * to persist data to ensure it is stored before the application shuts\n\t * down.\n\t *\n\t * The will save state event allows to optionally ask for the reason of\n\t * saving the state, e.g. to find out if the state is saved due to a\n\t * shutdown.\n\t *\n\t * Note: this event may be fired many times, not only on shutdown to prevent\n\t * loss of state in situations where the shutdown is not sufficient to\n\t * persist the data properly.\n\t */\n\treadonly onWillSaveState: Event<IWillSaveStateEvent>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t */\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `boolean`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t */\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `number` using `parseInt` with a\n\t * base of `10`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t */\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;\n\n\t/**\n\t * Store a value under the given key to storage. The value will be\n\t * converted to a `string`. Storing either `undefined` or `null` will\n\t * remove the entry under the key.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t *\n\t * @param target allows to define the target of the storage operation\n\t * to either the current machine or user.\n\t */\n\tstore(key: string, value: string | boolean | number | undefined | null, scope: StorageScope, target: StorageTarget): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only or all workspaces.\n\t */\n\tremove(key: string, scope: StorageScope): void;\n\n\t/**\n\t * Returns all the keys used in the storage for the provided `scope`\n\t * and `target`.\n\t *\n\t * Note: this will NOT return all keys stored in the storage layer.\n\t * Some keys may not have an associated `StorageTarget` and thus\n\t * will be excluded from the results.\n\t *\n\t * @param scope allows to define the scope for the keys\n\t * to either the current workspace only or all workspaces.\n\t *\n\t * @param target allows to define the target for the keys\n\t * to either the current machine or user.\n\t */\n\tkeys(scope: StorageScope, target: StorageTarget): string[];\n\n\t/**\n\t * Log the contents of the storage to the console.\n\t */\n\tlogStorage(): void;\n\n\t/**\n\t * Migrate the storage contents to another workspace.\n\t */\n\tmigrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void>;\n\n\t/**\n\t * Whether the storage for the given scope was created during this session or\n\t * existed before.\n\t */\n\tisNew(scope: StorageScope): boolean;\n\n\t/**\n\t * Allows to flush state, e.g. in cases where a shutdown is\n\t * imminent. This will send out the `onWillSaveState` to ask\n\t * everyone for latest state.\n\t *\n\t * @returns a `Promise` that can be awaited on when all updates\n\t * to the underlying storage have been flushed.\n\t */\n\tflush(): Promise<void>;\n}\n\nexport const enum StorageScope {\n\n\t/**\n\t * The stored data will be scoped to all workspaces.\n\t */\n\tGLOBAL,\n\n\t/**\n\t * The stored data will be scoped to the current workspace.\n\t */\n\tWORKSPACE\n}\n\nexport const enum StorageTarget {\n\n\t/**\n\t * The stored data is user specific and applies across machines.\n\t */\n\tUSER,\n\n\t/**\n\t * The stored data is machine specific.\n\t */\n\tMACHINE\n}\n\nexport interface IStorageValueChangeEvent {\n\n\t/**\n\t * The scope for the storage entry that changed\n\t * or was removed.\n\t */\n\treadonly scope: StorageScope;\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * The `target` can be `undefined` if a key is being\n\t * removed.\n\t */\n\treadonly target: StorageTarget | undefined;\n}\n\nexport interface IStorageTargetChangeEvent {\n\n\t/**\n\t * The scope for the target that changed. Listeners\n\t * should use `keys(scope, target)` to get an updated\n\t * list of keys for the given `scope` and `target`.\n\t */\n\treadonly scope: StorageScope;\n}\n\ninterface IKeyTargets {\n\t[key: string]: StorageTarget\n}\n\nexport interface IStorageServiceOptions {\n\tflushInterval: number;\n}\n\nexport abstract class AbstractStorageService extends Disposable implements IStorageService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute\n\n\tprivate readonly _onDidChangeValue = this._register(new PauseableEmitter<IStorageValueChangeEvent>());\n\treadonly onDidChangeValue = this._onDidChangeValue.event;\n\n\tprivate readonly _onDidChangeTarget = this._register(new PauseableEmitter<IStorageTargetChangeEvent>());\n\treadonly onDidChangeTarget = this._onDidChangeTarget.event;\n\n\tprivate readonly _onWillSaveState = this._register(new Emitter<IWillSaveStateEvent>());\n\treadonly onWillSaveState = this._onWillSaveState.event;\n\n\tprivate initializationPromise: Promise<void> | undefined;\n\n\tprivate readonly flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), this.options.flushInterval));\n\tprivate readonly runFlushWhenIdle = this._register(new MutableDisposable());\n\n\tconstructor(private options: IStorageServiceOptions = { flushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {\n\t\tsuper();\n\t}\n\n\tprivate doFlushWhenIdle(): void {\n\t\tthis.runFlushWhenIdle.value = runWhenIdle(() => {\n\t\t\tif (this.shouldFlushWhenIdle()) {\n\t\t\t\tthis.flush();\n\t\t\t}\n\n\t\t\t// repeat\n\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t});\n\t}\n\n\tprotected shouldFlushWhenIdle(): boolean {\n\t\treturn true;\n\t}\n\n\tprotected stopFlushWhenIdle(): void {\n\t\tdispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);\n\t}\n\n\tinitialize(): Promise<void> {\n\t\tif (!this.initializationPromise) {\n\t\t\tthis.initializationPromise = (async () => {\n\n\t\t\t\t// Ask subclasses to initialize storage\n\t\t\t\tawait this.doInitialize();\n\n\t\t\t\t// On some OS we do not get enough time to persist state on shutdown (e.g. when\n\t\t\t\t// Windows restarts after applying updates). In other cases, VSCode might crash,\n\t\t\t\t// so we periodically save state to reduce the chance of loosing any state.\n\t\t\t\t// In the browser we do not have support for long running unload sequences. As such,\n\t\t\t\t// we cannot ask for saving state in that moment, because that would result in a\n\t\t\t\t// long running operation.\n\t\t\t\t// Instead, periodically ask customers to save save. The library will be clever enough\n\t\t\t\t// to only save state that has actually changed.\n\t\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t\t})();\n\t\t}\n\n\t\treturn this.initializationPromise;\n\t}\n\n\tprotected emitDidChangeValue(scope: StorageScope, key: string): void {\n\n\t\t// Specially handle `TARGET_KEY`\n\t\tif (key === TARGET_KEY) {\n\n\t\t\t// Clear our cached version which is now out of date\n\t\t\tif (scope === StorageScope.GLOBAL) {\n\t\t\t\tthis._globalKeyTargets = undefined;\n\t\t\t} else if (scope === StorageScope.WORKSPACE) {\n\t\t\t\tthis._workspaceKeyTargets = undefined;\n\t\t\t}\n\n\t\t\t// Emit as `didChangeTarget` event\n\t\t\tthis._onDidChangeTarget.fire({ scope });\n\t\t}\n\n\t\t// Emit any other key to outside\n\t\telse {\n\t\t\tthis._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key] });\n\t\t}\n\t}\n\n\tprotected emitWillSaveState(reason: WillSaveStateReason): void {\n\t\tthis._onWillSaveState.fire({ reason });\n\t}\n\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope): string | undefined;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined {\n\t\treturn this.getStorage(scope)?.get(key, fallbackValue);\n\t}\n\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope): boolean | undefined;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined {\n\t\treturn this.getStorage(scope)?.getBoolean(key, fallbackValue);\n\t}\n\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope): number | undefined;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined {\n\t\treturn this.getStorage(scope)?.getNumber(key, fallbackValue);\n\t}\n\n\tstore(key: string, value: string | boolean | number | undefined | null, scope: StorageScope, target: StorageTarget): void {\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tthis.remove(key, scope);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, target);\n\n\t\t\t// Store actual value\n\t\t\tthis.getStorage(scope)?.set(key, value);\n\t\t});\n\t}\n\n\tremove(key: string, scope: StorageScope): void {\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, undefined);\n\n\t\t\t// Remove actual key\n\t\t\tthis.getStorage(scope)?.delete(key);\n\t\t});\n\t}\n\n\tprivate withPausedEmitters(fn: Function): void {\n\n\t\t// Pause emitters\n\t\tthis._onDidChangeValue.pause();\n\t\tthis._onDidChangeTarget.pause();\n\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\n\t\t\t// Resume emitters\n\t\t\tthis._onDidChangeValue.resume();\n\t\t\tthis._onDidChangeTarget.resume();\n\t\t}\n\t}\n\n\tkeys(scope: StorageScope, target: StorageTarget): string[] {\n\t\tconst keys: string[] = [];\n\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tfor (const key of Object.keys(keyTargets)) {\n\t\t\tconst keyTarget = keyTargets[key];\n\t\t\tif (keyTarget === target) {\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\tprivate updateKeyTarget(key: string, scope: StorageScope, target: StorageTarget | undefined): void {\n\n\t\t// Add\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tif (typeof target === 'number') {\n\t\t\tif (keyTargets[key] !== target) {\n\t\t\t\tkeyTargets[key] = target;\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets));\n\t\t\t}\n\t\t}\n\n\t\t// Remove\n\t\telse {\n\t\t\tif (typeof keyTargets[key] === 'number') {\n\t\t\t\tdelete keyTargets[key];\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _workspaceKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get workspaceKeyTargets(): IKeyTargets {\n\t\tif (!this._workspaceKeyTargets) {\n\t\t\tthis._workspaceKeyTargets = this.loadKeyTargets(StorageScope.WORKSPACE);\n\t\t}\n\n\t\treturn this._workspaceKeyTargets;\n\t}\n\n\tprivate _globalKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get globalKeyTargets(): IKeyTargets {\n\t\tif (!this._globalKeyTargets) {\n\t\t\tthis._globalKeyTargets = this.loadKeyTargets(StorageScope.GLOBAL);\n\t\t}\n\n\t\treturn this._globalKeyTargets;\n\t}\n\n\tprivate getKeyTargets(scope: StorageScope): IKeyTargets {\n\t\treturn scope === StorageScope.GLOBAL ? this.globalKeyTargets : this.workspaceKeyTargets;\n\t}\n\n\tprivate loadKeyTargets(scope: StorageScope): { [key: string]: StorageTarget } {\n\t\tconst keysRaw = this.get(TARGET_KEY, scope);\n\t\tif (keysRaw) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(keysRaw);\n\t\t\t} catch (error) {\n\t\t\t\t// Fail gracefully\n\t\t\t}\n\t\t}\n\n\t\treturn Object.create(null);\n\t}\n\n\tisNew(scope: StorageScope): boolean {\n\t\treturn this.getBoolean(IS_NEW_KEY, scope) === true;\n\t}\n\n\tasync flush(): Promise<void> {\n\n\t\t// Signal event to collect changes\n\t\tthis._onWillSaveState.fire({ reason: WillSaveStateReason.NONE });\n\n\t\t// Await flush\n\t\tawait Promises.settled([\n\t\t\tthis.getStorage(StorageScope.GLOBAL)?.whenFlushed() ?? Promise.resolve(),\n\t\t\tthis.getStorage(StorageScope.WORKSPACE)?.whenFlushed() ?? Promise.resolve()\n\t\t]);\n\t}\n\n\tasync logStorage(): Promise<void> {\n\t\tconst globalItems = this.getStorage(StorageScope.GLOBAL)?.items ?? new Map<string, string>();\n\t\tconst workspaceItems = this.getStorage(StorageScope.WORKSPACE)?.items ?? new Map<string, string>();\n\n\t\treturn logStorage(\n\t\t\tglobalItems,\n\t\t\tworkspaceItems,\n\t\t\tthis.getLogDetails(StorageScope.GLOBAL) ?? '',\n\t\t\tthis.getLogDetails(StorageScope.WORKSPACE) ?? ''\n\t\t);\n\t}\n\n\t// --- abstract\n\n\tprotected abstract doInitialize(): Promise<void>;\n\n\tprotected abstract getStorage(scope: StorageScope): IStorage | undefined;\n\n\tprotected abstract getLogDetails(scope: StorageScope): string | undefined;\n\n\tabstract migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void>;\n}\n\nexport class InMemoryStorageService extends AbstractStorageService {\n\n\tprivate globalStorage = new Storage(new InMemoryStorageDatabase());\n\tprivate workspaceStorage = new Storage(new InMemoryStorageDatabase());\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(this.workspaceStorage.onDidChangeStorage(key => this.emitDidChangeValue(StorageScope.WORKSPACE, key)));\n\t\tthis._register(this.globalStorage.onDidChangeStorage(key => this.emitDidChangeValue(StorageScope.GLOBAL, key)));\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage {\n\t\treturn scope === StorageScope.GLOBAL ? this.globalStorage : this.workspaceStorage;\n\t}\n\n\tprotected getLogDetails(scope: StorageScope): string | undefined {\n\t\treturn scope === StorageScope.GLOBAL ? 'inMemory (global)' : 'inMemory (workspace)';\n\t}\n\n\tprotected async doInitialize(): Promise<void> { }\n\n\tasync migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void> {\n\t\t// not supported\n\t}\n}\n\nexport async function logStorage(global: Map<string, string>, workspace: Map<string, string>, globalPath: string, workspacePath: string): Promise<void> {\n\tconst safeParse = (value: string) => {\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (error) {\n\t\t\treturn value;\n\t\t}\n\t};\n\n\tconst globalItems = new Map<string, string>();\n\tconst globalItemsParsed = new Map<string, string>();\n\tglobal.forEach((value, key) => {\n\t\tglobalItems.set(key, value);\n\t\tglobalItemsParsed.set(key, safeParse(value));\n\t});\n\n\tconst workspaceItems = new Map<string, string>();\n\tconst workspaceItemsParsed = new Map<string, string>();\n\tworkspace.forEach((value, key) => {\n\t\tworkspaceItems.set(key, value);\n\t\tworkspaceItemsParsed.set(key, safeParse(value));\n\t});\n\n\tconsole.group(`Storage: Global (path: ${globalPath})`);\n\tlet globalValues: { key: string, value: string }[] = [];\n\tglobalItems.forEach((value, key) => {\n\t\tglobalValues.push({ key, value });\n\t});\n\tconsole.table(globalValues);\n\tconsole.groupEnd();\n\n\tconsole.log(globalItemsParsed);\n\n\tconsole.group(`Storage: Workspace (path: ${workspacePath})`);\n\tlet workspaceValues: { key: string, value: string }[] = [];\n\tworkspaceItems.forEach((value, key) => {\n\t\tworkspaceValues.push({ key, value });\n\t});\n\tconsole.table(workspaceValues);\n\tconsole.groupEnd();\n\n\tconsole.log(workspaceItemsParsed);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { isLinuxSnap, PlatformToString, platform, Platform } from 'vs/base/common/platform';\nimport { platform as nodePlatform, env } from 'vs/base/common/process';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { URI } from 'vs/base/common/uri';\n\nfunction getPlatformDetail(hostname: string): string | undefined {\n\tif (platform === Platform.Linux && /^penguin(\\.|$)/i.test(hostname)) {\n\t\treturn 'chromebook';\n\t}\n\n\treturn undefined;\n}\n\nexport async function resolveCommonProperties(\n\tfileService: IFileService,\n\trelease: string,\n\thostname: string,\n\tarch: string,\n\tcommit: string | undefined,\n\tversion: string | undefined,\n\tmachineId: string | undefined,\n\tmsftInternalDomains: string[] | undefined,\n\tinstallSourcePath: string,\n\tproduct?: string\n): Promise<{ [name: string]: string | boolean | undefined; }> {\n\tconst result: { [name: string]: string | boolean | undefined; } = Object.create(null);\n\n\t// __GDPR__COMMON__ \"common.machineId\" : { \"endPoint\": \"MacAddressHash\", \"classification\": \"EndUserPseudonymizedInformation\", \"purpose\": \"FeatureInsight\" }\n\tresult['common.machineId'] = machineId;\n\t// __GDPR__COMMON__ \"sessionID\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\tresult['sessionID'] = generateUuid() + Date.now();\n\t// __GDPR__COMMON__ \"commitHash\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n\tresult['commitHash'] = commit;\n\t// __GDPR__COMMON__ \"version\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\tresult['version'] = version;\n\t// __GDPR__COMMON__ \"common.platformVersion\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\tresult['common.platformVersion'] = (release || '').replace(/^(\\d+)(\\.\\d+)?(\\.\\d+)?(.*)/, '$1$2$3');\n\t// __GDPR__COMMON__ \"common.platform\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\tresult['common.platform'] = PlatformToString(platform);\n\t// __GDPR__COMMON__ \"common.nodePlatform\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n\tresult['common.nodePlatform'] = nodePlatform;\n\t// __GDPR__COMMON__ \"common.nodeArch\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n\tresult['common.nodeArch'] = arch;\n\t// __GDPR__COMMON__ \"common.product\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n\tresult['common.product'] = product || 'desktop';\n\n\tconst msftInternal = verifyMicrosoftInternalDomain(msftInternalDomains || []);\n\tif (msftInternal) {\n\t\t// __GDPR__COMMON__ \"common.msftInternal\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t\tresult['common.msftInternal'] = msftInternal;\n\t}\n\n\t// dynamic properties which value differs on each call\n\tlet seq = 0;\n\tconst startTime = Date.now();\n\tObject.defineProperties(result, {\n\t\t// __GDPR__COMMON__ \"timestamp\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t'timestamp': {\n\t\t\tget: () => new Date(),\n\t\t\tenumerable: true\n\t\t},\n\t\t// __GDPR__COMMON__ \"common.timesincesessionstart\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t\t'common.timesincesessionstart': {\n\t\t\tget: () => Date.now() - startTime,\n\t\t\tenumerable: true\n\t\t},\n\t\t// __GDPR__COMMON__ \"common.sequence\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t\t'common.sequence': {\n\t\t\tget: () => seq++,\n\t\t\tenumerable: true\n\t\t}\n\t});\n\n\tif (isLinuxSnap) {\n\t\t// __GDPR__COMMON__ \"common.snap\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\tresult['common.snap'] = 'true';\n\t}\n\n\tconst platformDetail = getPlatformDetail(hostname);\n\n\tif (platformDetail) {\n\t\t// __GDPR__COMMON__ \"common.platformDetail\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\tresult['common.platformDetail'] = platformDetail;\n\t}\n\n\ttry {\n\t\tconst contents = await fileService.readFile(URI.file(installSourcePath));\n\n\t\t// __GDPR__COMMON__ \"common.source\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\tresult['common.source'] = contents.value.toString().slice(0, 30);\n\t} catch (error) {\n\t\t// ignore error\n\t}\n\n\treturn result;\n}\n\nfunction verifyMicrosoftInternalDomain(domainList: readonly string[]): boolean {\n\tconst userDnsDomain = env['USERDNSDOMAIN'];\n\tif (!userDnsDomain) {\n\t\treturn false;\n\t}\n\n\tconst domain = userDnsDomain.toLowerCase();\n\treturn domainList.some(msftDomain => domain === msftDomain);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ClassifiedEvent, StrictPropertyCheck, GDPRClassification } from 'vs/platform/telemetry/common/gdprTypings';\n\nexport const ITelemetryService = createDecorator<ITelemetryService>('telemetryService');\n\nexport interface ITelemetryInfo {\n\tsessionId: string;\n\tmachineId: string;\n\tinstanceId: string;\n\tfirstSessionDate: string;\n\tmsftInternal?: boolean;\n}\n\nexport interface ITelemetryData {\n\tfrom?: string;\n\ttarget?: string;\n\t[key: string]: any;\n}\n\nexport interface ITelemetryService {\n\n\t/**\n\t * Whether error telemetry will get sent. If false, `publicLogError` will no-op.\n\t */\n\treadonly sendErrorTelemetry: boolean;\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Sends a telemetry event that has been privacy approved.\n\t * Do not call this unless you have been given approval.\n\t */\n\tpublicLog(eventName: string, data?: ITelemetryData, anonymizeFilePaths?: boolean): Promise<void>;\n\n\tpublicLog2<E extends ClassifiedEvent<T> = never, T extends GDPRClassification<T> = never>(eventName: string, data?: StrictPropertyCheck<T, E>, anonymizeFilePaths?: boolean): Promise<void>;\n\n\tpublicLogError(errorEventName: string, data?: ITelemetryData): Promise<void>;\n\n\tpublicLogError2<E extends ClassifiedEvent<T> = never, T extends GDPRClassification<T> = never>(eventName: string, data?: StrictPropertyCheck<T, E>): Promise<void>;\n\n\tsetEnabled(value: boolean): void;\n\n\tgetTelemetryInfo(): Promise<ITelemetryInfo>;\n\n\tsetExperimentProperty(name: string, value: string): void;\n\n\tisOptedIn: boolean;\n}\n\nexport interface ITelemetryEndpoint {\n\tid: string;\n\taiKey: string;\n\tsendErrorTelemetry: boolean;\n}\n\nexport const ICustomEndpointTelemetryService = createDecorator<ICustomEndpointTelemetryService>('customEndpointTelemetryService');\n\nexport interface ICustomEndpointTelemetryService {\n\treadonly _serviceBrand: undefined;\n\n\tpublicLog(endpoint: ITelemetryEndpoint, eventName: string, data?: ITelemetryData): Promise<void>;\n\tpublicLogError(endpoint: ITelemetryEndpoint, errorEventName: string, data?: ITelemetryData): Promise<void>;\n}\n\n// Keys\nexport const instanceStorageKey = 'telemetry.instanceId';\nexport const currentSessionDateStorageKey = 'telemetry.currentSessionDate';\nexport const firstSessionDateStorageKey = 'telemetry.firstSessionDate';\nexport const lastSessionDateStorageKey = 'telemetry.lastSessionDate';\nexport const machineIdKey = 'telemetry.machineId';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getErrorMessage, isPromiseCanceledError, canceled } from 'vs/base/common/errors';\nimport { StatisticType, IGalleryExtension, IExtensionGalleryService, IGalleryExtensionAsset, IQueryOptions, SortBy, SortOrder, IExtensionIdentifier, IReportedExtension, InstallOperation, ITranslation, IGalleryExtensionVersion, IGalleryExtensionAssets, isIExtensionIdentifier, DefaultIconPath } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { getGalleryExtensionId, getGalleryExtensionTelemetryData, adoptToGalleryExtensionId } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { getOrDefault } from 'vs/base/common/objects';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { IPager } from 'vs/base/common/paging';\nimport { IRequestService, asJson, asText, isSuccess } from 'vs/platform/request/common/request';\nimport { IRequestOptions, IRequestContext, IHeaders } from 'vs/base/parts/request/common/request';\nimport { isEngineValid } from 'vs/platform/extensions/common/extensionValidator';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IExtensionManifest } from 'vs/platform/extensions/common/extensions';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { IProductService } from 'vs/platform/product/common/productService';\nimport { IStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';\nimport { getServiceMachineId } from 'vs/platform/serviceMachineId/common/serviceMachineId';\nimport { optional } from 'vs/platform/instantiation/common/instantiation';\nimport { joinPath } from 'vs/base/common/resources';\n\ninterface IRawGalleryExtensionFile {\n\tassetType: string;\n\tsource: string;\n}\n\ninterface IRawGalleryExtensionProperty {\n\tkey: string;\n\tvalue: string;\n}\n\ninterface IRawGalleryExtensionVersion {\n\tversion: string;\n\tlastUpdated: string;\n\tassetUri: string;\n\tfallbackAssetUri: string;\n\tfiles: IRawGalleryExtensionFile[];\n\tproperties?: IRawGalleryExtensionProperty[];\n}\n\ninterface IRawGalleryExtensionStatistics {\n\tstatisticName: string;\n\tvalue: number;\n}\n\ninterface IRawGalleryExtension {\n\textensionId: string;\n\textensionName: string;\n\tdisplayName: string;\n\tshortDescription: string;\n\tpublisher: { displayName: string, publisherId: string, publisherName: string; };\n\tversions: IRawGalleryExtensionVersion[];\n\tstatistics: IRawGalleryExtensionStatistics[];\n\tflags: string;\n}\n\ninterface IRawGalleryQueryResult {\n\tresults: {\n\t\textensions: IRawGalleryExtension[];\n\t\tresultMetadata: {\n\t\t\tmetadataType: string;\n\t\t\tmetadataItems: {\n\t\t\t\tname: string;\n\t\t\t\tcount: number;\n\t\t\t}[];\n\t\t}[]\n\t}[];\n}\n\nenum Flags {\n\tNone = 0x0,\n\tIncludeVersions = 0x1,\n\tIncludeFiles = 0x2,\n\tIncludeCategoryAndTags = 0x4,\n\tIncludeSharedAccounts = 0x8,\n\tIncludeVersionProperties = 0x10,\n\tExcludeNonValidated = 0x20,\n\tIncludeInstallationTargets = 0x40,\n\tIncludeAssetUri = 0x80,\n\tIncludeStatistics = 0x100,\n\tIncludeLatestVersionOnly = 0x200,\n\tUnpublished = 0x1000\n}\n\nfunction flagsToString(...flags: Flags[]): string {\n\treturn String(flags.reduce((r, f) => r | f, 0));\n}\n\nenum FilterType {\n\tTag = 1,\n\tExtensionId = 4,\n\tCategory = 5,\n\tExtensionName = 7,\n\tTarget = 8,\n\tFeatured = 9,\n\tSearchText = 10,\n\tExcludeWithFlags = 12\n}\n\nconst AssetType = {\n\tIcon: 'Microsoft.VisualStudio.Services.Icons.Default',\n\tDetails: 'Microsoft.VisualStudio.Services.Content.Details',\n\tChangelog: 'Microsoft.VisualStudio.Services.Content.Changelog',\n\tManifest: 'Microsoft.VisualStudio.Code.Manifest',\n\tVSIX: 'Microsoft.VisualStudio.Services.VSIXPackage',\n\tLicense: 'Microsoft.VisualStudio.Services.Content.License',\n\tRepository: 'Microsoft.VisualStudio.Services.Links.Source'\n};\n\nconst PropertyType = {\n\tDependency: 'Microsoft.VisualStudio.Code.ExtensionDependencies',\n\tExtensionPack: 'Microsoft.VisualStudio.Code.ExtensionPack',\n\tEngine: 'Microsoft.VisualStudio.Code.Engine',\n\tLocalizedLanguages: 'Microsoft.VisualStudio.Code.LocalizedLanguages',\n\tWebExtension: 'Microsoft.VisualStudio.Code.WebExtension'\n};\n\ninterface ICriterium {\n\tfilterType: FilterType;\n\tvalue?: string;\n}\n\nconst DefaultPageSize = 10;\n\ninterface IQueryState {\n\tpageNumber: number;\n\tpageSize: number;\n\tsortBy: SortBy;\n\tsortOrder: SortOrder;\n\tflags: Flags;\n\tcriteria: ICriterium[];\n\tassetTypes: string[];\n}\n\nconst DefaultQueryState: IQueryState = {\n\tpageNumber: 1,\n\tpageSize: DefaultPageSize,\n\tsortBy: SortBy.NoneOrRelevance,\n\tsortOrder: SortOrder.Default,\n\tflags: Flags.None,\n\tcriteria: [],\n\tassetTypes: []\n};\n\ntype GalleryServiceQueryClassification = {\n\tfilterTypes: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\tsortBy: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\tsortOrder: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\tduration: { classification: 'SystemMetaData', purpose: 'PerformanceAndHealth', 'isMeasurement': true };\n\tsuccess: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\trequestBodySize: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\tresponseBodySize?: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\tstatusCode?: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\terrorCode?: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\tcount?: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n};\n\ntype QueryTelemetryData = {\n\tfilterTypes: string[];\n\tsortBy: string;\n\tsortOrder: string;\n};\n\ntype GalleryServiceQueryEvent = QueryTelemetryData & {\n\tduration: number;\n\tsuccess: boolean;\n\trequestBodySize: string;\n\tresponseBodySize?: string;\n\tstatusCode?: string;\n\terrorCode?: string;\n\tcount?: string;\n};\n\nclass Query {\n\n\tconstructor(private state = DefaultQueryState) { }\n\n\tget pageNumber(): number { return this.state.pageNumber; }\n\tget pageSize(): number { return this.state.pageSize; }\n\tget sortBy(): number { return this.state.sortBy; }\n\tget sortOrder(): number { return this.state.sortOrder; }\n\tget flags(): number { return this.state.flags; }\n\n\twithPage(pageNumber: number, pageSize: number = this.state.pageSize): Query {\n\t\treturn new Query({ ...this.state, pageNumber, pageSize });\n\t}\n\n\twithFilter(filterType: FilterType, ...values: string[]): Query {\n\t\tconst criteria = [\n\t\t\t...this.state.criteria,\n\t\t\t...values.length ? values.map(value => ({ filterType, value })) : [{ filterType }]\n\t\t];\n\n\t\treturn new Query({ ...this.state, criteria });\n\t}\n\n\twithSortBy(sortBy: SortBy): Query {\n\t\treturn new Query({ ...this.state, sortBy });\n\t}\n\n\twithSortOrder(sortOrder: SortOrder): Query {\n\t\treturn new Query({ ...this.state, sortOrder });\n\t}\n\n\twithFlags(...flags: Flags[]): Query {\n\t\treturn new Query({ ...this.state, flags: flags.reduce<number>((r, f) => r | f, 0) });\n\t}\n\n\twithAssetTypes(...assetTypes: string[]): Query {\n\t\treturn new Query({ ...this.state, assetTypes });\n\t}\n\n\tget raw(): any {\n\t\tconst { criteria, pageNumber, pageSize, sortBy, sortOrder, flags, assetTypes } = this.state;\n\t\tconst filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];\n\t\treturn { filters, assetTypes, flags };\n\t}\n\n\tget searchText(): string {\n\t\tconst criterium = this.state.criteria.filter(criterium => criterium.filterType === FilterType.SearchText)[0];\n\t\treturn criterium && criterium.value ? criterium.value : '';\n\t}\n\n\tget telemetryData(): QueryTelemetryData {\n\t\treturn {\n\t\t\tfilterTypes: this.state.criteria.map(criterium => String(criterium.filterType)),\n\t\t\tsortBy: String(this.sortBy),\n\t\t\tsortOrder: String(this.sortOrder)\n\t\t};\n\t}\n}\n\nfunction getStatistic(statistics: IRawGalleryExtensionStatistics[], name: string): number {\n\tconst result = (statistics || []).filter(s => s.statisticName === name)[0];\n\treturn result ? result.value : 0;\n}\n\nfunction getCoreTranslationAssets(version: IRawGalleryExtensionVersion): [string, IGalleryExtensionAsset][] {\n\tconst coreTranslationAssetPrefix = 'Microsoft.VisualStudio.Code.Translation.';\n\tconst result = version.files.filter(f => f.assetType.indexOf(coreTranslationAssetPrefix) === 0);\n\treturn result.reduce<[string, IGalleryExtensionAsset][]>((result, file) => {\n\t\tconst asset = getVersionAsset(version, file.assetType);\n\t\tif (asset) {\n\t\t\tresult.push([file.assetType.substring(coreTranslationAssetPrefix.length), asset]);\n\t\t}\n\t\treturn result;\n\t}, []);\n}\n\nfunction getRepositoryAsset(version: IRawGalleryExtensionVersion): IGalleryExtensionAsset | null {\n\tif (version.properties) {\n\t\tconst results = version.properties.filter(p => p.key === AssetType.Repository);\n\t\tconst gitRegExp = new RegExp('((git|ssh|http(s)?)|(git@[\\w.]+))(:(//)?)([\\w.@\\:/\\-~]+)(.git)(/)?');\n\n\t\tconst uri = results.filter(r => gitRegExp.test(r.value))[0];\n\t\treturn uri ? { uri: uri.value, fallbackUri: uri.value } : null;\n\t}\n\treturn getVersionAsset(version, AssetType.Repository);\n}\n\nfunction getDownloadAsset(version: IRawGalleryExtensionVersion): IGalleryExtensionAsset {\n\treturn {\n\t\turi: `${version.fallbackAssetUri}/${AssetType.VSIX}?redirect=true`,\n\t\tfallbackUri: `${version.fallbackAssetUri}/${AssetType.VSIX}`\n\t};\n}\n\nfunction getIconAsset(version: IRawGalleryExtensionVersion): IGalleryExtensionAsset {\n\tconst asset = getVersionAsset(version, AssetType.Icon);\n\tif (asset) {\n\t\treturn asset;\n\t}\n\tconst uri = DefaultIconPath;\n\treturn { uri, fallbackUri: uri };\n}\n\nfunction getVersionAsset(version: IRawGalleryExtensionVersion, type: string): IGalleryExtensionAsset | null {\n\tconst result = version.files.filter(f => f.assetType === type)[0];\n\treturn result ? { uri: `${version.assetUri}/${type}`, fallbackUri: `${version.fallbackAssetUri}/${type}` } : null;\n}\n\nfunction getExtensions(version: IRawGalleryExtensionVersion, property: string): string[] {\n\tconst values = version.properties ? version.properties.filter(p => p.key === property) : [];\n\tconst value = values.length > 0 && values[0].value;\n\treturn value ? value.split(',').map(v => adoptToGalleryExtensionId(v)) : [];\n}\n\nfunction getEngine(version: IRawGalleryExtensionVersion): string {\n\tconst values = version.properties ? version.properties.filter(p => p.key === PropertyType.Engine) : [];\n\treturn (values.length > 0 && values[0].value) || '';\n}\n\nfunction getLocalizedLanguages(version: IRawGalleryExtensionVersion): string[] {\n\tconst values = version.properties ? version.properties.filter(p => p.key === PropertyType.LocalizedLanguages) : [];\n\tconst value = (values.length > 0 && values[0].value) || '';\n\treturn value ? value.split(',') : [];\n}\n\nfunction getIsPreview(flags: string): boolean {\n\treturn flags.indexOf('preview') !== -1;\n}\n\nfunction getIsWebExtension(version: IRawGalleryExtensionVersion): boolean {\n\tconst webExtensionProperty = version.properties ? version.properties.find(p => p.key === PropertyType.WebExtension) : undefined;\n\treturn !!webExtensionProperty && webExtensionProperty.value === 'true';\n}\n\nfunction getWebResource(version: IRawGalleryExtensionVersion): URI | undefined {\n\treturn version.files.some(f => f.assetType.startsWith('Microsoft.VisualStudio.Code.WebResources'))\n\t\t? joinPath(URI.parse(version.assetUri), 'Microsoft.VisualStudio.Code.WebResources', 'extension')\n\t\t: undefined;\n}\n\nfunction toExtension(galleryExtension: IRawGalleryExtension, version: IRawGalleryExtensionVersion, index: number, query: Query, querySource?: string): IGalleryExtension {\n\tconst assets = <IGalleryExtensionAssets>{\n\t\tmanifest: getVersionAsset(version, AssetType.Manifest),\n\t\treadme: getVersionAsset(version, AssetType.Details),\n\t\tchangelog: getVersionAsset(version, AssetType.Changelog),\n\t\tlicense: getVersionAsset(version, AssetType.License),\n\t\trepository: getRepositoryAsset(version),\n\t\tdownload: getDownloadAsset(version),\n\t\ticon: getIconAsset(version),\n\t\tcoreTranslations: getCoreTranslationAssets(version)\n\t};\n\n\treturn {\n\t\tidentifier: {\n\t\t\tid: getGalleryExtensionId(galleryExtension.publisher.publisherName, galleryExtension.extensionName),\n\t\t\tuuid: galleryExtension.extensionId\n\t\t},\n\t\tname: galleryExtension.extensionName,\n\t\tversion: version.version,\n\t\tdate: version.lastUpdated,\n\t\tdisplayName: galleryExtension.displayName,\n\t\tpublisherId: galleryExtension.publisher.publisherId,\n\t\tpublisher: galleryExtension.publisher.publisherName,\n\t\tpublisherDisplayName: galleryExtension.publisher.displayName,\n\t\tdescription: galleryExtension.shortDescription || '',\n\t\tinstallCount: getStatistic(galleryExtension.statistics, 'install'),\n\t\trating: getStatistic(galleryExtension.statistics, 'averagerating'),\n\t\tratingCount: getStatistic(galleryExtension.statistics, 'ratingcount'),\n\t\tassetUri: URI.parse(version.assetUri),\n\t\twebResource: getWebResource(version),\n\t\tassetTypes: version.files.map(({ assetType }) => assetType),\n\t\tassets,\n\t\tproperties: {\n\t\t\tdependencies: getExtensions(version, PropertyType.Dependency),\n\t\t\textensionPack: getExtensions(version, PropertyType.ExtensionPack),\n\t\t\tengine: getEngine(version),\n\t\t\tlocalizedLanguages: getLocalizedLanguages(version),\n\t\t\twebExtension: getIsWebExtension(version)\n\t\t},\n\t\t/* __GDPR__FRAGMENT__\n\t\t\t\"GalleryExtensionTelemetryData2\" : {\n\t\t\t\t\"index\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\t\t\"searchText\": { \"classification\": \"CustomerContent\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\t\"querySource\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t}\n\t\t*/\n\t\ttelemetryData: {\n\t\t\tindex: ((query.pageNumber - 1) * query.pageSize) + index,\n\t\t\tsearchText: query.searchText,\n\t\t\tquerySource\n\t\t},\n\t\tpreview: getIsPreview(galleryExtension.flags)\n\t};\n}\n\ninterface IRawExtensionsReport {\n\tmalicious: string[];\n\tslow: string[];\n}\n\nexport class ExtensionGalleryService implements IExtensionGalleryService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate extensionsGalleryUrl: string | undefined;\n\tprivate extensionsControlUrl: string | undefined;\n\n\tprivate readonly commonHeadersPromise: Promise<{ [key: string]: string; }>;\n\n\tconstructor(\n\t\t@IRequestService private readonly requestService: IRequestService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@optional(IStorageService) storageService: IStorageService,\n\t) {\n\t\tconst config = productService.extensionsGallery;\n\t\tthis.extensionsGalleryUrl = config && config.serviceUrl;\n\t\tthis.extensionsControlUrl = config && config.controlUrl;\n\t\tthis.commonHeadersPromise = resolveMarketplaceHeaders(productService.version, this.environmentService, this.fileService, storageService);\n\t}\n\n\tprivate api(path = ''): string {\n\t\treturn `${this.extensionsGalleryUrl}${path}`;\n\t}\n\n\tisEnabled(): boolean {\n\t\treturn !!this.extensionsGalleryUrl;\n\t}\n\n\tasync getExtensions(names: string[], token: CancellationToken): Promise<IGalleryExtension[]> {\n\t\tconst result: IGalleryExtension[] = [];\n\t\tlet { total, firstPage: pageResult, getPage } = await this.query({ names, pageSize: names.length }, token);\n\t\tresult.push(...pageResult);\n\t\tfor (let pageIndex = 1; result.length < total; pageIndex++) {\n\t\t\tpageResult = await getPage(pageIndex, token);\n\t\t\tif (pageResult.length) {\n\t\t\t\tresult.push(...pageResult);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tasync getCompatibleExtension(arg1: IExtensionIdentifier | IGalleryExtension, version?: string): Promise<IGalleryExtension | null> {\n\t\tconst extension = await this.getCompatibleExtensionByEngine(arg1, version);\n\n\t\tif (extension?.properties.webExtension) {\n\t\t\treturn extension.webResource ? extension : null;\n\t\t} else {\n\t\t\treturn extension;\n\t\t}\n\t}\n\n\tprivate async getCompatibleExtensionByEngine(arg1: IExtensionIdentifier | IGalleryExtension, version?: string): Promise<IGalleryExtension | null> {\n\t\tconst extension: IGalleryExtension | null = isIExtensionIdentifier(arg1) ? null : arg1;\n\t\tif (extension && extension.properties.engine && isEngineValid(extension.properties.engine, this.productService.version)) {\n\t\t\treturn extension;\n\t\t}\n\t\tconst { id, uuid } = extension ? extension.identifier : <IExtensionIdentifier>arg1;\n\t\tlet query = new Query()\n\t\t\t.withFlags(Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)\n\t\t\t.withPage(1, 1)\n\t\t\t.withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code');\n\n\t\tif (uuid) {\n\t\t\tquery = query.withFilter(FilterType.ExtensionId, uuid);\n\t\t} else {\n\t\t\tquery = query.withFilter(FilterType.ExtensionName, id);\n\t\t}\n\n\t\tconst { galleryExtensions } = await this.queryGallery(query, CancellationToken.None);\n\t\tconst [rawExtension] = galleryExtensions;\n\t\tif (!rawExtension || !rawExtension.versions.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (version) {\n\t\t\tconst versionAsset = rawExtension.versions.filter(v => v.version === version)[0];\n\t\t\tif (versionAsset) {\n\t\t\t\tconst extension = toExtension(rawExtension, versionAsset, 0, query);\n\t\t\t\tif (extension.properties.engine && isEngineValid(extension.properties.engine, this.productService.version)) {\n\t\t\t\t\treturn extension;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst rawVersion = await this.getLastValidExtensionVersion(rawExtension, rawExtension.versions);\n\t\tif (rawVersion) {\n\t\t\treturn toExtension(rawExtension, rawVersion, 0, query);\n\t\t}\n\t\treturn null;\n\t}\n\n\tquery(token: CancellationToken): Promise<IPager<IGalleryExtension>>;\n\tquery(options: IQueryOptions, token: CancellationToken): Promise<IPager<IGalleryExtension>>;\n\tasync query(arg1: any, arg2?: any): Promise<IPager<IGalleryExtension>> {\n\t\tconst options: IQueryOptions = CancellationToken.isCancellationToken(arg1) ? {} : arg1;\n\t\tconst token: CancellationToken = CancellationToken.isCancellationToken(arg1) ? arg1 : arg2;\n\n\t\tif (!this.isEnabled()) {\n\t\t\tthrow new Error('No extension gallery service configured.');\n\t\t}\n\n\t\tlet text = options.text || '';\n\t\tconst pageSize = getOrDefault(options, o => o.pageSize, 50);\n\n\t\tlet query = new Query()\n\t\t\t.withFlags(Flags.IncludeLatestVersionOnly, Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)\n\t\t\t.withPage(1, pageSize)\n\t\t\t.withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code');\n\n\t\tif (text) {\n\t\t\t// Use category filter instead of \"category:themes\"\n\t\t\ttext = text.replace(/\\bcategory:(\"([^\"]*)\"|([^\"]\\S*))(\\s+|\\b|$)/g, (_, quotedCategory, category) => {\n\t\t\t\tquery = query.withFilter(FilterType.Category, category || quotedCategory);\n\t\t\t\treturn '';\n\t\t\t});\n\n\t\t\t// Use tag filter instead of \"tag:debuggers\"\n\t\t\ttext = text.replace(/\\btag:(\"([^\"]*)\"|([^\"]\\S*))(\\s+|\\b|$)/g, (_, quotedTag, tag) => {\n\t\t\t\tquery = query.withFilter(FilterType.Tag, tag || quotedTag);\n\t\t\t\treturn '';\n\t\t\t});\n\n\t\t\t// Use featured filter\n\t\t\ttext = text.replace(/\\bfeatured(\\s+|\\b|$)/g, () => {\n\t\t\t\tquery = query.withFilter(FilterType.Featured);\n\t\t\t\treturn '';\n\t\t\t});\n\n\t\t\ttext = text.trim();\n\n\t\t\tif (text) {\n\t\t\t\ttext = text.length < 200 ? text : text.substring(0, 200);\n\t\t\t\tquery = query.withFilter(FilterType.SearchText, text);\n\t\t\t}\n\n\t\t\tquery = query.withSortBy(SortBy.NoneOrRelevance);\n\t\t} else if (options.ids) {\n\t\t\tquery = query.withFilter(FilterType.ExtensionId, ...options.ids);\n\t\t} else if (options.names) {\n\t\t\tquery = query.withFilter(FilterType.ExtensionName, ...options.names);\n\t\t} else {\n\t\t\tquery = query.withSortBy(SortBy.InstallCount);\n\t\t}\n\n\t\tif (typeof options.sortBy === 'number') {\n\t\t\tquery = query.withSortBy(options.sortBy);\n\t\t}\n\n\t\tif (typeof options.sortOrder === 'number') {\n\t\t\tquery = query.withSortOrder(options.sortOrder);\n\t\t}\n\n\t\tconst { galleryExtensions, total } = await this.queryGallery(query, token);\n\t\tconst extensions = galleryExtensions.map((e, index) => toExtension(e, e.versions[0], index, query, options.source));\n\t\tconst getPage = async (pageIndex: number, ct: CancellationToken) => {\n\t\t\tif (ct.isCancellationRequested) {\n\t\t\t\tthrow canceled();\n\t\t\t}\n\t\t\tconst nextPageQuery = query.withPage(pageIndex + 1);\n\t\t\tconst { galleryExtensions } = await this.queryGallery(nextPageQuery, ct);\n\t\t\treturn galleryExtensions.map((e, index) => toExtension(e, e.versions[0], index, nextPageQuery, options.source));\n\t\t};\n\n\t\treturn { firstPage: extensions, total, pageSize: query.pageSize, getPage } as IPager<IGalleryExtension>;\n\t}\n\n\tprivate async queryGallery(query: Query, token: CancellationToken): Promise<{ galleryExtensions: IRawGalleryExtension[], total: number; }> {\n\t\tif (!this.isEnabled()) {\n\t\t\tthrow new Error('No extension gallery service configured.');\n\t\t}\n\n\t\t// Always exclude non validated and unpublished extensions\n\t\tquery = query\n\t\t\t.withFlags(query.flags, Flags.ExcludeNonValidated)\n\t\t\t.withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished));\n\n\t\tconst commonHeaders = await this.commonHeadersPromise;\n\t\tconst data = JSON.stringify(query.raw);\n\t\tconst headers = {\n\t\t\t...commonHeaders,\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Accept': 'application/json;api-version=3.0-preview.1',\n\t\t\t'Accept-Encoding': 'gzip',\n\t\t\t'Content-Length': String(data.length)\n\t\t};\n\n\t\tconst startTime = new Date().getTime();\n\t\tlet context: IRequestContext | undefined, error: any, total: number = 0;\n\n\t\ttry {\n\t\t\tcontext = await this.requestService.request({\n\t\t\t\ttype: 'POST',\n\t\t\t\turl: this.api('/extensionquery'),\n\t\t\t\tdata,\n\t\t\t\theaders\n\t\t\t}, token);\n\n\t\t\tif (context.res.statusCode && context.res.statusCode >= 400 && context.res.statusCode < 500) {\n\t\t\t\treturn { galleryExtensions: [], total };\n\t\t\t}\n\n\t\t\tconst result = await asJson<IRawGalleryQueryResult>(context);\n\t\t\tif (result) {\n\t\t\t\tconst r = result.results[0];\n\t\t\t\tconst galleryExtensions = r.extensions;\n\t\t\t\tconst resultCount = r.resultMetadata && r.resultMetadata.filter(m => m.metadataType === 'ResultCount')[0];\n\t\t\t\ttotal = resultCount && resultCount.metadataItems.filter(i => i.name === 'TotalCount')[0].count || 0;\n\n\t\t\t\treturn { galleryExtensions, total };\n\t\t\t}\n\t\t\treturn { galleryExtensions: [], total };\n\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tthis.telemetryService.publicLog2<GalleryServiceQueryEvent, GalleryServiceQueryClassification>('galleryService:query', {\n\t\t\t\t...query.telemetryData,\n\t\t\t\trequestBodySize: String(data.length),\n\t\t\t\tduration: new Date().getTime() - startTime,\n\t\t\t\tsuccess: !!context && isSuccess(context),\n\t\t\t\tresponseBodySize: context?.res.headers['Content-Length'],\n\t\t\t\tstatusCode: context ? String(context.res.statusCode) : undefined,\n\t\t\t\terrorCode: error\n\t\t\t\t\t? isPromiseCanceledError(error) ? 'canceled' : getErrorMessage(error).startsWith('XHR timeout') ? 'timeout' : 'failed'\n\t\t\t\t\t: undefined,\n\t\t\t\tcount: String(total)\n\t\t\t});\n\t\t}\n\t}\n\n\tasync reportStatistic(publisher: string, name: string, version: string, type: StatisticType): Promise<void> {\n\t\tif (!this.isEnabled()) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst commonHeaders = await this.commonHeadersPromise;\n\t\tconst headers = { ...commonHeaders, Accept: '*/*;api-version=4.0-preview.1' };\n\t\ttry {\n\t\t\tawait this.requestService.request({\n\t\t\t\ttype: 'POST',\n\t\t\t\turl: this.api(`/publishers/${publisher}/extensions/${name}/${version}/stats?statType=${type}`),\n\t\t\t\theaders\n\t\t\t}, CancellationToken.None);\n\t\t} catch (error) { /* Ignore */ }\n\t}\n\n\tasync download(extension: IGalleryExtension, location: URI, operation: InstallOperation): Promise<void> {\n\t\tthis.logService.trace('ExtensionGalleryService#download', extension.identifier.id);\n\t\tconst data = getGalleryExtensionTelemetryData(extension);\n\t\tconst startTime = new Date().getTime();\n\t\t/* __GDPR__\n\t\t\t\"galleryService:downloadVSIX\" : {\n\t\t\t\t\"duration\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"${include}\": [\n\t\t\t\t\t\"${GalleryExtensionTelemetryData}\"\n\t\t\t\t]\n\t\t\t}\n\t\t*/\n\t\tconst log = (duration: number) => this.telemetryService.publicLog('galleryService:downloadVSIX', { ...data, duration });\n\n\t\tconst operationParam = operation === InstallOperation.Install ? 'install' : operation === InstallOperation.Update ? 'update' : '';\n\t\tconst downloadAsset = operationParam ? {\n\t\t\turi: `${extension.assets.download.uri}&${operationParam}=true`,\n\t\t\tfallbackUri: `${extension.assets.download.fallbackUri}?${operationParam}=true`\n\t\t} : extension.assets.download;\n\n\t\tconst context = await this.getAsset(downloadAsset);\n\t\tawait this.fileService.writeFile(location, context.stream);\n\t\tlog(new Date().getTime() - startTime);\n\t}\n\n\tasync getReadme(extension: IGalleryExtension, token: CancellationToken): Promise<string> {\n\t\tif (extension.assets.readme) {\n\t\t\tconst context = await this.getAsset(extension.assets.readme, {}, token);\n\t\t\tconst content = await asText(context);\n\t\t\treturn content || '';\n\t\t}\n\t\treturn '';\n\t}\n\n\tasync getManifest(extension: IGalleryExtension, token: CancellationToken): Promise<IExtensionManifest | null> {\n\t\tif (extension.assets.manifest) {\n\t\t\tconst context = await this.getAsset(extension.assets.manifest, {}, token);\n\t\t\tconst text = await asText(context);\n\t\t\treturn text ? JSON.parse(text) : null;\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync getCoreTranslation(extension: IGalleryExtension, languageId: string): Promise<ITranslation | null> {\n\t\tconst asset = extension.assets.coreTranslations.filter(t => t[0] === languageId.toUpperCase())[0];\n\t\tif (asset) {\n\t\t\tconst context = await this.getAsset(asset[1]);\n\t\t\tconst text = await asText(context);\n\t\t\treturn text ? JSON.parse(text) : null;\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync getChangelog(extension: IGalleryExtension, token: CancellationToken): Promise<string> {\n\t\tif (extension.assets.changelog) {\n\t\t\tconst context = await this.getAsset(extension.assets.changelog, {}, token);\n\t\t\tconst content = await asText(context);\n\t\t\treturn content || '';\n\t\t}\n\t\treturn '';\n\t}\n\n\tasync getAllVersions(extension: IGalleryExtension, compatible: boolean): Promise<IGalleryExtensionVersion[]> {\n\t\tlet query = new Query()\n\t\t\t.withFlags(Flags.IncludeVersions, Flags.IncludeFiles, Flags.IncludeVersionProperties)\n\t\t\t.withPage(1, 1)\n\t\t\t.withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code');\n\n\t\tif (extension.identifier.uuid) {\n\t\t\tquery = query.withFilter(FilterType.ExtensionId, extension.identifier.uuid);\n\t\t} else {\n\t\t\tquery = query.withFilter(FilterType.ExtensionName, extension.identifier.id);\n\t\t}\n\n\t\tconst result: IGalleryExtensionVersion[] = [];\n\t\tconst { galleryExtensions } = await this.queryGallery(query, CancellationToken.None);\n\t\tif (galleryExtensions.length) {\n\t\t\tif (compatible) {\n\t\t\t\tawait Promise.all(galleryExtensions[0].versions.map(async v => {\n\t\t\t\t\tlet engine: string | undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tengine = await this.getEngine(v);\n\t\t\t\t\t} catch (error) { /* Ignore error and skip version */ }\n\t\t\t\t\tif (engine && isEngineValid(engine, this.productService.version)) {\n\t\t\t\t\t\tresult.push({ version: v!.version, date: v!.lastUpdated });\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tresult.push(...galleryExtensions[0].versions.map(v => ({ version: v.version, date: v.lastUpdated })));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate async getAsset(asset: IGalleryExtensionAsset, options: IRequestOptions = {}, token: CancellationToken = CancellationToken.None): Promise<IRequestContext> {\n\t\tconst commonHeaders = await this.commonHeadersPromise;\n\t\tconst baseOptions = { type: 'GET' };\n\t\tconst headers = { ...commonHeaders, ...(options.headers || {}) };\n\t\toptions = { ...options, ...baseOptions, headers };\n\n\t\tconst url = asset.uri;\n\t\tconst fallbackUrl = asset.fallbackUri;\n\t\tconst firstOptions = { ...options, url };\n\n\t\ttry {\n\t\t\tconst context = await this.requestService.request(firstOptions, token);\n\t\t\tif (context.res.statusCode === 200) {\n\t\t\t\treturn context;\n\t\t\t}\n\t\t\tconst message = await asText(context);\n\t\t\tthrow new Error(`Expected 200, got back ${context.res.statusCode} instead.\\n\\n${message}`);\n\t\t} catch (err) {\n\t\t\tif (isPromiseCanceledError(err)) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tconst message = getErrorMessage(err);\n\t\t\ttype GalleryServiceCDNFallbackClassification = {\n\t\t\t\turl: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\t\t\t\tmessage: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\t\t\t};\n\t\t\ttype GalleryServiceCDNFallbackEvent = {\n\t\t\t\turl: string;\n\t\t\t\tmessage: string;\n\t\t\t};\n\t\t\tthis.telemetryService.publicLog2<GalleryServiceCDNFallbackEvent, GalleryServiceCDNFallbackClassification>('galleryService:cdnFallback', { url, message });\n\n\t\t\tconst fallbackOptions = { ...options, url: fallbackUrl };\n\t\t\treturn this.requestService.request(fallbackOptions, token);\n\t\t}\n\t}\n\n\tprivate async getLastValidExtensionVersion(extension: IRawGalleryExtension, versions: IRawGalleryExtensionVersion[]): Promise<IRawGalleryExtensionVersion | null> {\n\t\tconst version = this.getLastValidExtensionVersionFromProperties(extension, versions);\n\t\tif (version) {\n\t\t\treturn version;\n\t\t}\n\t\treturn this.getLastValidExtensionVersionRecursively(extension, versions);\n\t}\n\n\tprivate getLastValidExtensionVersionFromProperties(extension: IRawGalleryExtension, versions: IRawGalleryExtensionVersion[]): IRawGalleryExtensionVersion | null {\n\t\tfor (const version of versions) {\n\t\t\tconst engine = getEngine(version);\n\t\t\tif (!engine) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (isEngineValid(engine, this.productService.version)) {\n\t\t\t\treturn version;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate async getEngine(version: IRawGalleryExtensionVersion): Promise<string> {\n\t\tconst engine = getEngine(version);\n\t\tif (engine) {\n\t\t\treturn engine;\n\t\t}\n\n\t\tconst manifestAsset = getVersionAsset(version, AssetType.Manifest);\n\t\tif (!manifestAsset) {\n\t\t\tthrow new Error('Manifest was not found');\n\t\t}\n\n\t\tconst headers = { 'Accept-Encoding': 'gzip' };\n\t\tconst context = await this.getAsset(manifestAsset, { headers });\n\t\tconst manifest = await asJson<IExtensionManifest>(context);\n\t\tif (manifest) {\n\t\t\treturn manifest.engines.vscode;\n\t\t}\n\n\t\tthrow new Error('Error while reading manifest');\n\t}\n\n\tprivate async getLastValidExtensionVersionRecursively(extension: IRawGalleryExtension, versions: IRawGalleryExtensionVersion[]): Promise<IRawGalleryExtensionVersion | null> {\n\t\tif (!versions.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst version = versions[0];\n\t\tconst engine = await this.getEngine(version);\n\t\tif (!isEngineValid(engine, this.productService.version)) {\n\t\t\treturn this.getLastValidExtensionVersionRecursively(extension, versions.slice(1));\n\t\t}\n\n\t\tversion.properties = version.properties || [];\n\t\tversion.properties.push({ key: PropertyType.Engine, value: engine });\n\t\treturn version;\n\t}\n\n\tasync getExtensionsReport(): Promise<IReportedExtension[]> {\n\t\tif (!this.isEnabled()) {\n\t\t\tthrow new Error('No extension gallery service configured.');\n\t\t}\n\n\t\tif (!this.extensionsControlUrl) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst context = await this.requestService.request({ type: 'GET', url: this.extensionsControlUrl }, CancellationToken.None);\n\t\tif (context.res.statusCode !== 200) {\n\t\t\tthrow new Error('Could not get extensions report.');\n\t\t}\n\n\t\tconst result = await asJson<IRawExtensionsReport>(context);\n\t\tconst map = new Map<string, IReportedExtension>();\n\n\t\tif (result) {\n\t\t\tfor (const id of result.malicious) {\n\t\t\t\tconst ext = map.get(id) || { id: { id }, malicious: true, slow: false };\n\t\t\t\text.malicious = true;\n\t\t\t\tmap.set(id, ext);\n\t\t\t}\n\t\t}\n\n\t\treturn [...map.values()];\n\t}\n}\n\nexport async function resolveMarketplaceHeaders(version: string, environmentService: IEnvironmentService, fileService: IFileService, storageService: {\n\tget: (key: string, scope: StorageScope) => string | undefined,\n\tstore: (key: string, value: string, scope: StorageScope, target: StorageTarget) => void\n} | undefined): Promise<{ [key: string]: string; }> {\n\tconst headers: IHeaders = {\n\t\t'X-Market-Client-Id': `VSCode ${version}`,\n\t\t'User-Agent': `VSCode ${version}`\n\t};\n\tconst uuid = await getServiceMachineId(environmentService, fileService, storageService);\n\theaders['X-Market-User-Id'] = uuid;\n\treturn headers;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport product from 'vs/platform/product/common/product';\nimport { localize } from 'vs/nls';\nimport { escapeRegExpCharacters } from 'vs/base/common/strings';\nimport { ITelemetryService, ITelemetryInfo, ITelemetryData } from 'vs/platform/telemetry/common/telemetry';\nimport { ITelemetryAppender } from 'vs/platform/telemetry/common/telemetryUtils';\nimport { optional } from 'vs/platform/instantiation/common/instantiation';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IConfigurationRegistry, Extensions, ConfigurationScope } from 'vs/platform/configuration/common/configurationRegistry';\nimport { DisposableStore } from 'vs/base/common/lifecycle';\nimport { cloneAndChange, mixin } from 'vs/base/common/objects';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { ClassifiedEvent, StrictPropertyCheck, GDPRClassification } from 'vs/platform/telemetry/common/gdprTypings';\n\nexport interface ITelemetryServiceConfig {\n\tappender: ITelemetryAppender;\n\tsendErrorTelemetry?: boolean;\n\tcommonProperties?: Promise<{ [name: string]: any }>;\n\tpiiPaths?: string[];\n}\n\nexport class TelemetryService implements ITelemetryService {\n\n\tstatic readonly IDLE_START_EVENT_NAME = 'UserIdleStart';\n\tstatic readonly IDLE_STOP_EVENT_NAME = 'UserIdleStop';\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _appender: ITelemetryAppender;\n\tprivate _commonProperties: Promise<{ [name: string]: any; }>;\n\tprivate _experimentProperties: { [name: string]: string } = {};\n\tprivate _piiPaths: string[];\n\tprivate _userOptIn: boolean;\n\tprivate _enabled: boolean;\n\tpublic readonly sendErrorTelemetry: boolean;\n\n\tprivate readonly _disposables = new DisposableStore();\n\tprivate _cleanupPatterns: RegExp[] = [];\n\n\tconstructor(\n\t\tconfig: ITelemetryServiceConfig,\n\t\t@optional(IConfigurationService) private _configurationService: IConfigurationService\n\t) {\n\t\tthis._appender = config.appender;\n\t\tthis._commonProperties = config.commonProperties || Promise.resolve({});\n\t\tthis._piiPaths = config.piiPaths || [];\n\t\tthis._userOptIn = true;\n\t\tthis._enabled = true;\n\t\tthis.sendErrorTelemetry = !!config.sendErrorTelemetry;\n\n\t\t// static cleanup pattern for: `file:///DANGEROUS/PATH/resources/app/Useful/Information`\n\t\tthis._cleanupPatterns = [/file:\\/\\/\\/.*?\\/resources\\/app\\//gi];\n\n\t\tfor (let piiPath of this._piiPaths) {\n\t\t\tthis._cleanupPatterns.push(new RegExp(escapeRegExpCharacters(piiPath), 'gi'));\n\t\t}\n\n\t\tif (this._configurationService) {\n\t\t\tthis._updateUserOptIn();\n\t\t\tthis._configurationService.onDidChangeConfiguration(this._updateUserOptIn, this, this._disposables);\n\t\t\ttype OptInClassification = {\n\t\t\t\toptIn: { classification: 'SystemMetaData', purpose: 'BusinessInsight', isMeasurement: true };\n\t\t\t};\n\t\t\ttype OptInEvent = {\n\t\t\t\toptIn: boolean;\n\t\t\t};\n\t\t\tthis.publicLog2<OptInEvent, OptInClassification>('optInStatus', { optIn: this._userOptIn });\n\n\t\t\tthis._commonProperties.then(values => {\n\t\t\t\tconst isHashedId = /^[a-f0-9]+$/i.test(values['common.machineId']);\n\n\t\t\t\ttype MachineIdFallbackClassification = {\n\t\t\t\t\tusingFallbackGuid: { classification: 'SystemMetaData', purpose: 'BusinessInsight', isMeasurement: true };\n\t\t\t\t};\n\t\t\t\tthis.publicLog2<{ usingFallbackGuid: boolean }, MachineIdFallbackClassification>('machineIdFallback', { usingFallbackGuid: !isHashedId });\n\t\t\t});\n\t\t}\n\t}\n\n\tsetExperimentProperty(name: string, value: string): void {\n\t\tthis._experimentProperties[name] = value;\n\t}\n\n\tsetEnabled(value: boolean): void {\n\t\tthis._enabled = value;\n\t}\n\n\tprivate _updateUserOptIn(): void {\n\t\tconst config = this._configurationService?.getValue<any>(TELEMETRY_SECTION_ID);\n\t\tthis._userOptIn = config ? config.enableTelemetry : this._userOptIn;\n\t}\n\n\tget isOptedIn(): boolean {\n\t\treturn this._userOptIn && this._enabled;\n\t}\n\n\tasync getTelemetryInfo(): Promise<ITelemetryInfo> {\n\t\tconst values = await this._commonProperties;\n\n\t\t// well known properties\n\t\tlet sessionId = values['sessionID'];\n\t\tlet instanceId = values['common.instanceId'];\n\t\tlet machineId = values['common.machineId'];\n\t\tlet firstSessionDate = values['common.firstSessionDate'];\n\t\tlet msftInternal = values['common.msftInternal'];\n\n\t\treturn { sessionId, instanceId, machineId, firstSessionDate, msftInternal };\n\t}\n\n\tdispose(): void {\n\t\tthis._disposables.dispose();\n\t}\n\n\tpublicLog(eventName: string, data?: ITelemetryData, anonymizeFilePaths?: boolean): Promise<any> {\n\t\t// don't send events when the user is optout\n\t\tif (!this.isOptedIn) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\treturn this._commonProperties.then(values => {\n\n\t\t\t// (first) add common properties\n\t\t\tdata = mixin(data, values);\n\n\t\t\t// (next) add experiment properties\n\t\t\tdata = mixin(data, this._experimentProperties);\n\n\t\t\t// (last) remove all PII from data\n\t\t\tdata = cloneAndChange(data, value => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\treturn this._cleanupInfo(value, anonymizeFilePaths);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\n\t\t\tthis._appender.log(eventName, data);\n\n\t\t}, err => {\n\t\t\t// unsure what to do now...\n\t\t\tconsole.error(err);\n\t\t});\n\t}\n\n\tpublicLog2<E extends ClassifiedEvent<T> = never, T extends GDPRClassification<T> = never>(eventName: string, data?: StrictPropertyCheck<T, E>, anonymizeFilePaths?: boolean): Promise<any> {\n\t\treturn this.publicLog(eventName, data as ITelemetryData, anonymizeFilePaths);\n\t}\n\n\tpublicLogError(errorEventName: string, data?: ITelemetryData): Promise<any> {\n\t\tif (!this.sendErrorTelemetry) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\t// Send error event and anonymize paths\n\t\treturn this.publicLog(errorEventName, data, true);\n\t}\n\n\tpublicLogError2<E extends ClassifiedEvent<T> = never, T extends GDPRClassification<T> = never>(eventName: string, data?: StrictPropertyCheck<T, E>): Promise<any> {\n\t\treturn this.publicLogError(eventName, data as ITelemetryData);\n\t}\n\n\tprivate _cleanupInfo(stack: string, anonymizeFilePaths?: boolean): string {\n\t\tlet updatedStack = stack;\n\n\t\tif (anonymizeFilePaths) {\n\t\t\tconst cleanUpIndexes: [number, number][] = [];\n\t\t\tfor (let regexp of this._cleanupPatterns) {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst result = regexp.exec(stack);\n\t\t\t\t\tif (!result) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcleanUpIndexes.push([result.index, regexp.lastIndex]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst nodeModulesRegex = /^[\\\\\\/]?(node_modules|node_modules\\.asar)[\\\\\\/]/;\n\t\t\tconst fileRegex = /(file:\\/\\/)?([a-zA-Z]:(\\\\\\\\|\\\\|\\/)|(\\\\\\\\|\\\\|\\/))?([\\w-\\._]+(\\\\\\\\|\\\\|\\/))+[\\w-\\._]*/g;\n\t\t\tlet lastIndex = 0;\n\t\t\tupdatedStack = '';\n\n\t\t\twhile (true) {\n\t\t\t\tconst result = fileRegex.exec(stack);\n\t\t\t\tif (!result) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Anoynimize user file paths that do not need to be retained or cleaned up.\n\t\t\t\tif (!nodeModulesRegex.test(result[0]) && cleanUpIndexes.every(([x, y]) => result.index < x || result.index >= y)) {\n\t\t\t\t\tupdatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';\n\t\t\t\t\tlastIndex = fileRegex.lastIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastIndex < stack.length) {\n\t\t\t\tupdatedStack += stack.substr(lastIndex);\n\t\t\t}\n\t\t}\n\n\t\t// sanitize with configured cleanup patterns\n\t\tfor (let regexp of this._cleanupPatterns) {\n\t\t\tupdatedStack = updatedStack.replace(regexp, '');\n\t\t}\n\t\treturn updatedStack;\n\t}\n}\n\n\nconst TELEMETRY_SECTION_ID = 'telemetry';\n\n\nRegistry.as<IConfigurationRegistry>(Extensions.Configuration).registerConfiguration({\n\t'id': TELEMETRY_SECTION_ID,\n\t'order': 110,\n\t'type': 'object',\n\t'title': localize('telemetryConfigurationTitle', \"Telemetry\"),\n\t'properties': {\n\t\t'telemetry.enableTelemetry': {\n\t\t\t'type': 'boolean',\n\t\t\t'markdownDescription':\n\t\t\t\t!product.privacyStatementUrl ?\n\t\t\t\t\tlocalize('telemetry.enableTelemetry', \"Enable usage data and errors to be sent to a Microsoft online service.\") :\n\t\t\t\t\tlocalize('telemetry.enableTelemetryMd', \"Enable usage data and errors to be sent to a Microsoft online service. Read our privacy statement [here]({0}).\", product.privacyStatementUrl),\n\t\t\t'default': false,\n\t\t\t'restricted': true,\n\t\t\t'scope': ConfigurationScope.APPLICATION,\n\t\t\t'tags': ['usesOnlineServices']\n\t\t}\n\t}\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { IConfigurationService, ConfigurationTarget, ConfigurationTargetToString } from 'vs/platform/configuration/common/configuration';\nimport { ITelemetryService, ITelemetryInfo, ITelemetryData, ICustomEndpointTelemetryService, ITelemetryEndpoint } from 'vs/platform/telemetry/common/telemetry';\nimport { ClassifiedEvent, StrictPropertyCheck, GDPRClassification } from 'vs/platform/telemetry/common/gdprTypings';\nimport { safeStringify } from 'vs/base/common/objects';\nimport { isObject } from 'vs/base/common/types';\nimport { Promises } from 'vs/base/common/async';\n\nexport const NullTelemetryService = new class implements ITelemetryService {\n\tdeclare readonly _serviceBrand: undefined;\n\treadonly sendErrorTelemetry = false;\n\n\tpublicLog(eventName: string, data?: ITelemetryData) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tpublicLog2<E extends ClassifiedEvent<T> = never, T extends GDPRClassification<T> = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLog(eventName, data as ITelemetryData);\n\t}\n\tpublicLogError(eventName: string, data?: ITelemetryData) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\tpublicLogError2<E extends ClassifiedEvent<T> = never, T extends GDPRClassification<T> = never>(eventName: string, data?: StrictPropertyCheck<T, E>) {\n\t\treturn this.publicLogError(eventName, data as ITelemetryData);\n\t}\n\n\tsetExperimentProperty() { }\n\tsetEnabled() { }\n\tisOptedIn = true;\n\tgetTelemetryInfo(): Promise<ITelemetryInfo> {\n\t\treturn Promise.resolve({\n\t\t\tinstanceId: 'someValue.instanceId',\n\t\t\tsessionId: 'someValue.sessionId',\n\t\t\tmachineId: 'someValue.machineId',\n\t\t\tfirstSessionDate: 'someValue.firstSessionDate'\n\t\t});\n\t}\n};\n\nexport class NullEndpointTelemetryService implements ICustomEndpointTelemetryService {\n\t_serviceBrand: undefined;\n\n\tasync publicLog(_endpoint: ITelemetryEndpoint, _eventName: string, _data?: ITelemetryData): Promise<void> {\n\t\t// noop\n\t}\n\n\tasync publicLogError(_endpoint: ITelemetryEndpoint, _errorEventName: string, _data?: ITelemetryData): Promise<void> {\n\t\t// noop\n\t}\n}\n\nexport interface ITelemetryAppender {\n\tlog(eventName: string, data: any): void;\n\tflush(): Promise<any>;\n}\n\nexport function combinedAppender(...appenders: ITelemetryAppender[]): ITelemetryAppender {\n\treturn {\n\t\tlog: (e, d) => appenders.forEach(a => a.log(e, d)),\n\t\tflush: () => Promises.settled(appenders.map(a => a.flush()))\n\t};\n}\n\nexport const NullAppender: ITelemetryAppender = { log: () => null, flush: () => Promise.resolve(null) };\n\n\n/* __GDPR__FRAGMENT__\n\t\"URIDescriptor\" : {\n\t\t\"mimeType\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"scheme\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"ext\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"path\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t}\n*/\nexport interface URIDescriptor {\n\tmimeType?: string;\n\tscheme?: string;\n\text?: string;\n\tpath?: string;\n}\n\nexport function configurationTelemetry(telemetryService: ITelemetryService, configurationService: IConfigurationService): IDisposable {\n\treturn configurationService.onDidChangeConfiguration(event => {\n\t\tif (event.source !== ConfigurationTarget.DEFAULT) {\n\t\t\ttype UpdateConfigurationClassification = {\n\t\t\t\tconfigurationSource: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\t\t\t\tconfigurationKeys: { classification: 'SystemMetaData', purpose: 'FeatureInsight' };\n\t\t\t};\n\t\t\ttype UpdateConfigurationEvent = {\n\t\t\t\tconfigurationSource: string;\n\t\t\t\tconfigurationKeys: string[];\n\t\t\t};\n\t\t\ttelemetryService.publicLog2<UpdateConfigurationEvent, UpdateConfigurationClassification>('updateConfiguration', {\n\t\t\t\tconfigurationSource: ConfigurationTargetToString(event.source),\n\t\t\t\tconfigurationKeys: flattenKeys(event.sourceConfig)\n\t\t\t});\n\t\t}\n\t});\n}\n\nexport interface Properties {\n\t[key: string]: string;\n}\n\nexport interface Measurements {\n\t[key: string]: number;\n}\n\nexport function validateTelemetryData(data?: any): { properties: Properties, measurements: Measurements } {\n\n\tconst properties: Properties = Object.create(null);\n\tconst measurements: Measurements = Object.create(null);\n\n\tconst flat = Object.create(null);\n\tflatten(data, flat);\n\n\tfor (let prop in flat) {\n\t\t// enforce property names less than 150 char, take the last 150 char\n\t\tprop = prop.length > 150 ? prop.substr(prop.length - 149) : prop;\n\t\tconst value = flat[prop];\n\n\t\tif (typeof value === 'number') {\n\t\t\tmeasurements[prop] = value;\n\n\t\t} else if (typeof value === 'boolean') {\n\t\t\tmeasurements[prop] = value ? 1 : 0;\n\n\t\t} else if (typeof value === 'string') {\n\t\t\t//enforce property value to be less than 1024 char, take the first 1024 char\n\t\t\tproperties[prop] = value.substring(0, 1023);\n\n\t\t} else if (typeof value !== 'undefined' && value !== null) {\n\t\t\tproperties[prop] = value;\n\t\t}\n\t}\n\n\treturn {\n\t\tproperties,\n\t\tmeasurements\n\t};\n}\n\nexport function cleanRemoteAuthority(remoteAuthority?: string): string {\n\tif (!remoteAuthority) {\n\t\treturn 'none';\n\t}\n\n\tlet ret = 'other';\n\tconst allowedAuthorities = ['ssh-remote', 'dev-container', 'attached-container', 'wsl'];\n\tallowedAuthorities.forEach((res: string) => {\n\t\tif (remoteAuthority!.indexOf(`${res}+`) === 0) {\n\t\t\tret = res;\n\t\t}\n\t});\n\n\treturn ret;\n}\n\nfunction flatten(obj: any, result: { [key: string]: any }, order: number = 0, prefix?: string): void {\n\tif (!obj) {\n\t\treturn;\n\t}\n\n\tfor (let item of Object.getOwnPropertyNames(obj)) {\n\t\tconst value = obj[item];\n\t\tconst index = prefix ? prefix + item : item;\n\n\t\tif (Array.isArray(value)) {\n\t\t\tresult[index] = safeStringify(value);\n\n\t\t} else if (value instanceof Date) {\n\t\t\t// TODO unsure why this is here and not in _getData\n\t\t\tresult[index] = value.toISOString();\n\n\t\t} else if (isObject(value)) {\n\t\t\tif (order < 2) {\n\t\t\t\tflatten(value, result, order + 1, index + '.');\n\t\t\t} else {\n\t\t\t\tresult[index] = safeStringify(value);\n\t\t\t}\n\t\t} else {\n\t\t\tresult[index] = value;\n\t\t}\n\t}\n}\n\nfunction flattenKeys(value: Object | undefined): string[] {\n\tif (!value) {\n\t\treturn [];\n\t}\n\tconst result: string[] = [];\n\tflatKeys(result, '', value);\n\treturn result;\n}\n\nfunction flatKeys(result: string[], prefix: string, value: { [key: string]: any } | undefined): void {\n\tif (value && typeof value === 'object' && !Array.isArray(value)) {\n\t\tObject.keys(value)\n\t\t\t.forEach(key => flatKeys(result, prefix ? `${prefix}.${key}` : key, value[key]));\n\t} else {\n\t\tresult.push(prefix);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as appInsights from 'applicationinsights';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { mixin } from 'vs/base/common/objects';\nimport { ITelemetryAppender, validateTelemetryData } from 'vs/platform/telemetry/common/telemetryUtils';\n\nasync function getClient(aiKey: string): Promise<appInsights.TelemetryClient> {\n\tconst appInsights = await import('applicationinsights');\n\tlet client: appInsights.TelemetryClient;\n\tif (appInsights.defaultClient) {\n\t\tclient = new appInsights.TelemetryClient(aiKey);\n\t\tclient.channel.setUseDiskRetryCaching(true);\n\t} else {\n\t\tappInsights.setup(aiKey)\n\t\t\t.setAutoCollectRequests(false)\n\t\t\t.setAutoCollectPerformance(false)\n\t\t\t.setAutoCollectExceptions(false)\n\t\t\t.setAutoCollectDependencies(false)\n\t\t\t.setAutoDependencyCorrelation(false)\n\t\t\t.setAutoCollectConsole(false)\n\t\t\t.setInternalLogging(false, false)\n\t\t\t.setUseDiskRetryCaching(true)\n\t\t\t.start();\n\t\tclient = appInsights.defaultClient;\n\t}\n\n\tif (aiKey.indexOf('AIF-') === 0) {\n\t\tclient.config.endpointUrl = 'https://vortex.data.microsoft.com/collect/v1';\n\t}\n\treturn client;\n}\n\n\nexport class AppInsightsAppender implements ITelemetryAppender {\n\n\tprivate _aiClient: string | appInsights.TelemetryClient | undefined;\n\tprivate _asyncAIClient: Promise<appInsights.TelemetryClient> | null;\n\n\tconstructor(\n\t\tprivate _eventPrefix: string,\n\t\tprivate _defaultData: { [key: string]: any } | null,\n\t\taiKeyOrClientFactory: string | (() => appInsights.TelemetryClient), // allow factory function for testing\n\t) {\n\t\tif (!this._defaultData) {\n\t\t\tthis._defaultData = Object.create(null);\n\t\t}\n\n\t\tif (typeof aiKeyOrClientFactory === 'function') {\n\t\t\tthis._aiClient = aiKeyOrClientFactory();\n\t\t} else {\n\t\t\tthis._aiClient = aiKeyOrClientFactory;\n\t\t}\n\t\tthis._asyncAIClient = null;\n\t}\n\n\tprivate _withAIClient(callback: (aiClient: appInsights.TelemetryClient) => void): void {\n\t\tif (!this._aiClient) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof this._aiClient !== 'string') {\n\t\t\tcallback(this._aiClient);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncAIClient) {\n\t\t\tthis._asyncAIClient = getClient(this._aiClient);\n\t\t}\n\n\t\tthis._asyncAIClient.then(\n\t\t\t(aiClient) => {\n\t\t\t\tcallback(aiClient);\n\t\t\t},\n\t\t\t(err) => {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t);\n\t}\n\n\tlog(eventName: string, data?: any): void {\n\t\tif (!this._aiClient) {\n\t\t\treturn;\n\t\t}\n\t\tdata = mixin(data, this._defaultData);\n\t\tdata = validateTelemetryData(data);\n\n\t\tthis._withAIClient((aiClient) => aiClient.trackEvent({\n\t\t\tname: this._eventPrefix + '/' + eventName,\n\t\t\tproperties: data.properties,\n\t\t\tmeasurements: data.measurements\n\t\t}));\n\t}\n\n\tflush(): Promise<any> {\n\t\tif (this._aiClient) {\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis._withAIClient((aiClient) => {\n\t\t\t\t\taiClient.flush({\n\t\t\t\t\t\tcallback: () => {\n\t\t\t\t\t\t\t// all data flushed\n\t\t\t\t\t\t\tthis._aiClient = undefined;\n\t\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn Promise.resolve(undefined);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { readdirSync } from 'vs/base/node/pfs';\nimport { statSync, readFileSync } from 'fs';\nimport { join } from 'vs/base/common/path';\n\nexport function buildTelemetryMessage(appRoot: string, extensionsPath?: string): string {\n\tconst mergedTelemetry = Object.create(null);\n\t// Simple function to merge the telemetry into one json object\n\tconst mergeTelemetry = (contents: string, dirName: string) => {\n\t\tconst telemetryData = JSON.parse(contents);\n\t\tmergedTelemetry[dirName] = telemetryData;\n\t};\n\tif (extensionsPath) {\n\t\t// Gets all the directories inside the extension directory\n\t\tconst dirs = readdirSync(extensionsPath).filter(files => {\n\t\t\t// This handles case where broken symbolic links can cause statSync to throw and error\n\t\t\ttry {\n\t\t\t\treturn statSync(join(extensionsPath, files)).isDirectory();\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tconst telemetryJsonFolders: string[] = [];\n\t\tdirs.forEach((dir) => {\n\t\t\tconst files = readdirSync(join(extensionsPath, dir)).filter(file => file === 'telemetry.json');\n\t\t\t// We know it contains a telemetry.json file so we add it to the list of folders which have one\n\t\t\tif (files.length === 1) {\n\t\t\t\ttelemetryJsonFolders.push(dir);\n\t\t\t}\n\t\t});\n\t\ttelemetryJsonFolders.forEach((folder) => {\n\t\t\tconst contents = readFileSync(join(extensionsPath, folder, 'telemetry.json')).toString();\n\t\t\tmergeTelemetry(contents, folder);\n\t\t});\n\t}\n\tlet contents = readFileSync(join(appRoot, 'telemetry-core.json')).toString();\n\tmergeTelemetry(contents, 'vscode-core');\n\tcontents = readFileSync(join(appRoot, 'telemetry-extensions.json')).toString();\n\tmergeTelemetry(contents, 'vscode-extensions');\n\treturn JSON.stringify(mergedTelemetry, null, 4);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport * as path from 'vs/base/common/path';\nimport { promises, createWriteStream, WriteStream } from 'fs';\nimport { Readable } from 'stream';\nimport { Sequencer, createCancelablePromise } from 'vs/base/common/async';\nimport { rimraf } from 'vs/base/node/pfs';\nimport { open as _openZip, Entry, ZipFile } from 'yauzl';\nimport * as yazl from 'yazl';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { assertIsDefined } from 'vs/base/common/types';\n\nexport interface IExtractOptions {\n\toverwrite?: boolean;\n\n\t/**\n\t * Source path within the ZIP archive. Only the files contained in this\n\t * path will be extracted.\n\t */\n\tsourcePath?: string;\n}\n\ninterface IOptions {\n\tsourcePathRegex: RegExp;\n}\n\nexport type ExtractErrorType = 'CorruptZip' | 'Incomplete';\n\nexport class ExtractError extends Error {\n\n\treadonly type?: ExtractErrorType;\n\treadonly cause: Error;\n\n\tconstructor(type: ExtractErrorType | undefined, cause: Error) {\n\t\tlet message = cause.message;\n\n\t\tswitch (type) {\n\t\t\tcase 'CorruptZip': message = `Corrupt ZIP: ${message}`; break;\n\t\t}\n\n\t\tsuper(message);\n\t\tthis.type = type;\n\t\tthis.cause = cause;\n\t}\n}\n\nfunction modeFromEntry(entry: Entry) {\n\tconst attr = entry.externalFileAttributes >> 16 || 33188;\n\n\treturn [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n\t\t.map(mask => attr & mask)\n\t\t.reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);\n}\n\nfunction toExtractError(err: Error): ExtractError {\n\tif (err instanceof ExtractError) {\n\t\treturn err;\n\t}\n\n\tlet type: ExtractErrorType | undefined = undefined;\n\n\tif (/end of central directory record signature not found/.test(err.message)) {\n\t\ttype = 'CorruptZip';\n\t}\n\n\treturn new ExtractError(type, err);\n}\n\nfunction extractEntry(stream: Readable, fileName: string, mode: number, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tconst dirName = path.dirname(fileName);\n\tconst targetDirName = path.join(targetPath, dirName);\n\tif (!targetDirName.startsWith(targetPath)) {\n\t\treturn Promise.reject(new Error(nls.localize('invalid file', \"Error extracting {0}. Invalid file.\", fileName)));\n\t}\n\tconst targetFileName = path.join(targetPath, fileName);\n\n\tlet istream: WriteStream;\n\n\ttoken.onCancellationRequested(() => {\n\t\tif (istream) {\n\t\t\tistream.destroy();\n\t\t}\n\t});\n\n\treturn Promise.resolve(promises.mkdir(targetDirName, { recursive: true })).then(() => new Promise<void>((c, e) => {\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tistream = createWriteStream(targetFileName, { mode });\n\t\t\tistream.once('close', () => c());\n\t\t\tistream.once('error', e);\n\t\t\tstream.once('error', e);\n\t\t\tstream.pipe(istream);\n\t\t} catch (error) {\n\t\t\te(error);\n\t\t}\n\t}));\n}\n\nfunction extractZip(zipfile: ZipFile, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tlet last = createCancelablePromise<void>(() => Promise.resolve());\n\tlet extractedEntriesCount = 0;\n\n\ttoken.onCancellationRequested(() => {\n\t\tlast.cancel();\n\t\tzipfile.close();\n\t});\n\n\treturn new Promise((c, e) => {\n\t\tconst throttler = new Sequencer();\n\n\t\tconst readNextEntry = (token: CancellationToken) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\textractedEntriesCount++;\n\t\t\tzipfile.readEntry();\n\t\t};\n\n\t\tzipfile.once('error', e);\n\t\tzipfile.once('close', () => last.then(() => {\n\t\t\tif (token.isCancellationRequested || zipfile.entryCount === extractedEntriesCount) {\n\t\t\t\tc();\n\t\t\t} else {\n\t\t\t\te(new ExtractError('Incomplete', new Error(nls.localize('incompleteExtract', \"Incomplete. Found {0} of {1} entries\", extractedEntriesCount, zipfile.entryCount))));\n\t\t\t}\n\t\t}, e));\n\t\tzipfile.readEntry();\n\t\tzipfile.on('entry', (entry: Entry) => {\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!options.sourcePathRegex.test(entry.fileName)) {\n\t\t\t\treadNextEntry(token);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fileName = entry.fileName.replace(options.sourcePathRegex, '');\n\n\t\t\t// directory file names end with '/'\n\t\t\tif (/\\/$/.test(fileName)) {\n\t\t\t\tconst targetFileName = path.join(targetPath, fileName);\n\t\t\t\tlast = createCancelablePromise(token => promises.mkdir(targetFileName, { recursive: true }).then(() => readNextEntry(token)).then(undefined, e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stream = openZipStream(zipfile, entry);\n\t\t\tconst mode = modeFromEntry(entry);\n\n\t\t\tlast = createCancelablePromise(token => throttler.queue(() => stream.then(stream => extractEntry(stream, fileName, mode, targetPath, options, token).then(() => readNextEntry(token)))).then(null, e));\n\t\t});\n\t});\n}\n\nfunction openZip(zipFile: string, lazy: boolean = false): Promise<ZipFile> {\n\treturn new Promise<ZipFile>((resolve, reject) => {\n\t\t_openZip(zipFile, lazy ? { lazyEntries: true } : undefined!, (error?: Error, zipfile?: ZipFile) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertIsDefined(zipfile));\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction openZipStream(zipFile: ZipFile, entry: Entry): Promise<Readable> {\n\treturn new Promise<Readable>((resolve, reject) => {\n\t\tzipFile.openReadStream(entry, (error?: Error, stream?: Readable) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertIsDefined(stream));\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IFile {\n\tpath: string;\n\tcontents?: Buffer | string;\n\tlocalPath?: string;\n}\n\nexport function zip(zipPath: string, files: IFile[]): Promise<string> {\n\treturn new Promise<string>((c, e) => {\n\t\tconst zip = new yazl.ZipFile();\n\t\tfiles.forEach(f => {\n\t\t\tif (f.contents) {\n\t\t\t\tzip.addBuffer(typeof f.contents === 'string' ? Buffer.from(f.contents, 'utf8') : f.contents, f.path);\n\t\t\t} else if (f.localPath) {\n\t\t\t\tzip.addFile(f.localPath, f.path);\n\t\t\t}\n\t\t});\n\t\tzip.end();\n\n\t\tconst zipStream = createWriteStream(zipPath);\n\t\tzip.outputStream.pipe(zipStream);\n\n\t\tzip.outputStream.once('error', e);\n\t\tzipStream.once('error', e);\n\t\tzipStream.once('finish', () => c(zipPath));\n\t});\n}\n\nexport function extract(zipPath: string, targetPath: string, options: IExtractOptions = {}, token: CancellationToken): Promise<void> {\n\tconst sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : '');\n\n\tlet promise = openZip(zipPath, true);\n\n\tif (options.overwrite) {\n\t\tpromise = promise.then(zipfile => rimraf(targetPath).then(() => zipfile));\n\t}\n\n\treturn promise.then(zipfile => extractZip(zipfile, targetPath, { sourcePathRegex }, token));\n}\n\nfunction read(zipPath: string, filePath: string): Promise<Readable> {\n\treturn openZip(zipPath).then(zipfile => {\n\t\treturn new Promise<Readable>((c, e) => {\n\t\t\tzipfile.on('entry', (entry: Entry) => {\n\t\t\t\tif (entry.fileName === filePath) {\n\t\t\t\t\topenZipStream(zipfile, entry).then(stream => c(stream), err => e(err));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tzipfile.once('close', () => e(new Error(nls.localize('notFound', \"{0} not found inside zip.\", filePath))));\n\t\t});\n\t});\n}\n\nexport function buffer(zipPath: string, filePath: string): Promise<Buffer> {\n\treturn read(zipPath, filePath).then(stream => {\n\t\treturn new Promise<Buffer>((c, e) => {\n\t\t\tconst buffers: Buffer[] = [];\n\t\t\tstream.once('error', e);\n\t\t\tstream.on('data', (b: Buffer) => buffers.push(b));\n\t\t\tstream.on('end', () => c(Buffer.concat(buffers)));\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { buffer } from 'vs/base/node/zip';\nimport { localize } from 'vs/nls';\nimport { IExtensionManifest } from 'vs/platform/extensions/common/extensions';\n\nexport function getManifest(vsix: string): Promise<IExtensionManifest> {\n\treturn buffer(vsix, 'extension/package.json')\n\t\t.then(buffer => {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString('utf8'));\n\t\t\t} catch (err) {\n\t\t\t\tthrow new Error(localize('invalidManifest', \"VSIX invalid: package.json is not a JSON file.\"));\n\t\t\t}\n\t\t});\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as semver from 'vs/base/common/semver/semver';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport * as pfs from 'vs/base/node/pfs';\nimport * as path from 'vs/base/common/path';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { ILocalExtension, IGalleryMetadata, ExtensionManagementError } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { ExtensionType, IExtensionManifest, IExtensionIdentifier } from 'vs/platform/extensions/common/extensions';\nimport { areSameExtensions, ExtensionIdentifierWithVersion, groupByExtension, getGalleryExtensionId } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { Limiter, Promises, Queue } from 'vs/base/common/async';\nimport { URI } from 'vs/base/common/uri';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { localizeManifest } from 'vs/platform/extensionManagement/common/extensionNls';\nimport { localize } from 'vs/nls';\nimport { IProductService } from 'vs/platform/product/common/productService';\nimport { CancellationToken } from 'vscode';\nimport { extract, ExtractError } from 'vs/base/node/zip';\nimport { isWindows } from 'vs/base/common/platform';\nimport { flatten } from 'vs/base/common/arrays';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport { FileAccess } from 'vs/base/common/network';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { basename } from 'vs/base/common/resources';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { getErrorMessage } from 'vs/base/common/errors';\n\nconst ERROR_SCANNING_SYS_EXTENSIONS = 'scanningSystem';\nconst ERROR_SCANNING_USER_EXTENSIONS = 'scanningUser';\nconst INSTALL_ERROR_EXTRACTING = 'extracting';\nconst INSTALL_ERROR_DELETING = 'deleting';\nconst INSTALL_ERROR_RENAMING = 'renaming';\n\nexport type IMetadata = Partial<IGalleryMetadata & { isMachineScoped: boolean; isBuiltin: boolean; }>;\ntype IStoredMetadata = IMetadata & { installedTimestamp: number | undefined };\nexport type ILocalExtensionManifest = IExtensionManifest & { __metadata?: IMetadata };\ntype IRelaxedLocalExtension = Omit<ILocalExtension, 'isBuiltin'> & { isBuiltin: boolean };\n\nexport class ExtensionsScanner extends Disposable {\n\n\tprivate readonly systemExtensionsPath: string;\n\tprivate readonly extensionsPath: string;\n\tprivate readonly uninstalledPath: string;\n\tprivate readonly uninstalledFileLimiter: Queue<any>;\n\n\tconstructor(\n\t\tprivate readonly beforeRemovingExtension: (e: ILocalExtension) => Promise<void>,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@INativeEnvironmentService private readonly environmentService: INativeEnvironmentService,\n\t\t@IProductService private readonly productService: IProductService,\n\t) {\n\t\tsuper();\n\t\tthis.systemExtensionsPath = environmentService.builtinExtensionsPath;\n\t\tthis.extensionsPath = environmentService.extensionsPath;\n\t\tthis.uninstalledPath = path.join(this.extensionsPath, '.obsolete');\n\t\tthis.uninstalledFileLimiter = new Queue();\n\t}\n\n\tasync cleanUp(): Promise<void> {\n\t\tawait this.removeUninstalledExtensions();\n\t\tawait this.removeOutdatedExtensions();\n\t}\n\n\tasync scanExtensions(type: ExtensionType | null): Promise<ILocalExtension[]> {\n\t\tconst promises: Promise<ILocalExtension[]>[] = [];\n\n\t\tif (type === null || type === ExtensionType.System) {\n\t\t\tpromises.push(this.scanSystemExtensions().then(null, e => Promise.reject(new ExtensionManagementError(this.joinErrors(e).message, ERROR_SCANNING_SYS_EXTENSIONS))));\n\t\t}\n\n\t\tif (type === null || type === ExtensionType.User) {\n\t\t\tpromises.push(this.scanUserExtensions(true).then(null, e => Promise.reject(new ExtensionManagementError(this.joinErrors(e).message, ERROR_SCANNING_USER_EXTENSIONS))));\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = await Promise.all(promises);\n\t\t\treturn flatten(result);\n\t\t} catch (error) {\n\t\t\tthrow this.joinErrors(error);\n\t\t}\n\t}\n\n\tasync scanUserExtensions(excludeOutdated: boolean): Promise<ILocalExtension[]> {\n\t\tthis.logService.trace('Started scanning user extensions');\n\t\tlet [uninstalled, extensions] = await Promise.all([this.getUninstalledExtensions(), this.scanAllUserExtensions()]);\n\t\textensions = extensions.filter(e => !uninstalled[new ExtensionIdentifierWithVersion(e.identifier, e.manifest.version).key()]);\n\t\tif (excludeOutdated) {\n\t\t\tconst byExtension: ILocalExtension[][] = groupByExtension(extensions, e => e.identifier);\n\t\t\textensions = byExtension.map(p => p.sort((a, b) => semver.rcompare(a.manifest.version, b.manifest.version))[0]);\n\t\t}\n\t\tthis.logService.trace('Scanned user extensions:', extensions.length);\n\t\treturn extensions;\n\t}\n\n\tasync scanAllUserExtensions(): Promise<ILocalExtension[]> {\n\t\treturn this.scanExtensionsInDir(this.extensionsPath, ExtensionType.User);\n\t}\n\n\tasync extractUserExtension(identifierWithVersion: ExtensionIdentifierWithVersion, zipPath: string, token: CancellationToken): Promise<ILocalExtension> {\n\t\tconst folderName = identifierWithVersion.key();\n\t\tconst tempPath = path.join(this.extensionsPath, `.${generateUuid()}`);\n\t\tconst extensionPath = path.join(this.extensionsPath, folderName);\n\n\t\ttry {\n\t\t\tawait pfs.rimraf(extensionPath);\n\t\t} catch (error) {\n\t\t\ttry {\n\t\t\t\tawait pfs.rimraf(extensionPath);\n\t\t\t} catch (e) { /* ignore */ }\n\t\t\tthrow new ExtensionManagementError(localize('errorDeleting', \"Unable to delete the existing folder '{0}' while installing the extension '{1}'. Please delete the folder manually and try again\", extensionPath, identifierWithVersion.id), INSTALL_ERROR_DELETING);\n\t\t}\n\n\t\tawait this.extractAtLocation(identifierWithVersion, zipPath, tempPath, token);\n\t\tlet local = await this.scanExtension(URI.file(tempPath), ExtensionType.User);\n\t\tif (!local) {\n\t\t\tthrow new Error(localize('cannot read', \"Cannot read the extension from {0}\", tempPath));\n\t\t}\n\t\tawait this.storeMetadata(local, { installedTimestamp: Date.now() });\n\n\t\ttry {\n\t\t\tawait this.rename(identifierWithVersion, tempPath, extensionPath, Date.now() + (2 * 60 * 1000) /* Retry for 2 minutes */);\n\t\t\tthis.logService.info('Renamed to', extensionPath);\n\t\t} catch (error) {\n\t\t\ttry {\n\t\t\t\tawait pfs.rimraf(tempPath);\n\t\t\t} catch (e) { /* ignore */ }\n\t\t\tif (error.code === 'ENOTEMPTY') {\n\t\t\t\tthis.logService.info(`Rename failed because extension was installed by another source. So ignoring renaming.`, identifierWithVersion.id);\n\t\t\t} else {\n\t\t\t\tthis.logService.info(`Rename failed because of ${getErrorMessage(error)}. Deleted from extracted location`, tempPath);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tlocal = await this.scanExtension(URI.file(extensionPath), ExtensionType.User);\n\t\t} catch (e) { /*ignore */ }\n\n\t\tif (local) {\n\t\t\treturn local;\n\t\t}\n\t\tthrow new Error(localize('cannot read', \"Cannot read the extension from {0}\", this.extensionsPath));\n\t}\n\n\tasync saveMetadataForLocalExtension(local: ILocalExtension, metadata: IMetadata): Promise<ILocalExtension> {\n\t\tthis.setMetadata(local, metadata);\n\t\tawait this.storeMetadata(local, { ...metadata, installedTimestamp: local.installedTimestamp });\n\t\treturn local;\n\t}\n\n\tprivate async storeMetadata(local: ILocalExtension, storedMetadata: IStoredMetadata): Promise<ILocalExtension> {\n\t\t// unset if false\n\t\tstoredMetadata.isMachineScoped = storedMetadata.isMachineScoped || undefined;\n\t\tstoredMetadata.isBuiltin = storedMetadata.isBuiltin || undefined;\n\t\tstoredMetadata.installedTimestamp = storedMetadata.installedTimestamp || undefined;\n\t\tconst manifestPath = path.join(local.location.fsPath, 'package.json');\n\t\tconst raw = await fs.promises.readFile(manifestPath, 'utf8');\n\t\tconst { manifest } = await this.parseManifest(raw);\n\t\t(manifest as ILocalExtensionManifest).__metadata = storedMetadata;\n\t\tawait pfs.writeFile(manifestPath, JSON.stringify(manifest, null, '\\t'));\n\t\treturn local;\n\t}\n\n\tgetUninstalledExtensions(): Promise<IStringDictionary<boolean>> {\n\t\treturn this.withUninstalledExtensions();\n\t}\n\n\tasync setUninstalled(...extensions: ILocalExtension[]): Promise<void> {\n\t\tconst ids: ExtensionIdentifierWithVersion[] = extensions.map(e => new ExtensionIdentifierWithVersion(e.identifier, e.manifest.version));\n\t\tawait this.withUninstalledExtensions(uninstalled => {\n\t\t\tids.forEach(id => uninstalled[id.key()] = true);\n\t\t});\n\t}\n\n\tasync setInstalled(identifierWithVersion: ExtensionIdentifierWithVersion): Promise<ILocalExtension | null> {\n\t\tawait this.withUninstalledExtensions(uninstalled => delete uninstalled[identifierWithVersion.key()]);\n\t\tconst installed = await this.scanExtensions(ExtensionType.User);\n\t\tconst localExtension = installed.find(i => new ExtensionIdentifierWithVersion(i.identifier, i.manifest.version).equals(identifierWithVersion)) || null;\n\t\tif (!localExtension) {\n\t\t\treturn null;\n\t\t}\n\t\tawait this.storeMetadata(localExtension, { installedTimestamp: Date.now() });\n\t\treturn this.scanExtension(localExtension.location, ExtensionType.User);\n\t}\n\n\tprivate async withUninstalledExtensions(updateFn?: (uninstalled: IStringDictionary<boolean>) => void): Promise<IStringDictionary<boolean>> {\n\t\treturn this.uninstalledFileLimiter.queue(async () => {\n\t\t\tlet raw: string | undefined;\n\t\t\ttry {\n\t\t\t\traw = await fs.promises.readFile(this.uninstalledPath, 'utf8');\n\t\t\t} catch (err) {\n\t\t\t\tif (err.code !== 'ENOENT') {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet uninstalled = {};\n\t\t\tif (raw) {\n\t\t\t\ttry {\n\t\t\t\t\tuninstalled = JSON.parse(raw);\n\t\t\t\t} catch (e) { /* ignore */ }\n\t\t\t}\n\n\t\t\tif (updateFn) {\n\t\t\t\tupdateFn(uninstalled);\n\t\t\t\tif (Object.keys(uninstalled).length) {\n\t\t\t\t\tawait pfs.writeFile(this.uninstalledPath, JSON.stringify(uninstalled));\n\t\t\t\t} else {\n\t\t\t\t\tawait pfs.rimraf(this.uninstalledPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uninstalled;\n\t\t});\n\t}\n\n\tasync removeExtension(extension: ILocalExtension, type: string): Promise<void> {\n\t\tthis.logService.trace(`Deleting ${type} extension from disk`, extension.identifier.id, extension.location.fsPath);\n\t\tawait pfs.rimraf(extension.location.fsPath);\n\t\tthis.logService.info('Deleted from disk', extension.identifier.id, extension.location.fsPath);\n\t}\n\n\tasync removeUninstalledExtension(extension: ILocalExtension): Promise<void> {\n\t\tawait this.removeExtension(extension, 'uninstalled');\n\t\tawait this.withUninstalledExtensions(uninstalled => delete uninstalled[new ExtensionIdentifierWithVersion(extension.identifier, extension.manifest.version).key()]);\n\t}\n\n\tprivate async extractAtLocation(identifier: IExtensionIdentifier, zipPath: string, location: string, token: CancellationToken): Promise<void> {\n\t\tthis.logService.trace(`Started extracting the extension from ${zipPath} to ${location}`);\n\n\t\t// Clean the location\n\t\ttry {\n\t\t\tawait pfs.rimraf(location);\n\t\t} catch (e) {\n\t\t\tthrow new ExtensionManagementError(this.joinErrors(e).message, INSTALL_ERROR_DELETING);\n\t\t}\n\n\t\ttry {\n\t\t\tawait extract(zipPath, location, { sourcePath: 'extension', overwrite: true }, token);\n\t\t\tthis.logService.info(`Extracted extension to ${location}:`, identifier.id);\n\t\t} catch (e) {\n\t\t\ttry { await pfs.rimraf(location); } catch (e) { /* Ignore */ }\n\t\t\tthrow new ExtensionManagementError(e.message, e instanceof ExtractError && e.type ? e.type : INSTALL_ERROR_EXTRACTING);\n\t\t}\n\t}\n\n\tprivate async rename(identifier: IExtensionIdentifier, extractPath: string, renamePath: string, retryUntil: number): Promise<void> {\n\t\ttry {\n\t\t\tawait fs.promises.rename(extractPath, renamePath);\n\t\t} catch (error) {\n\t\t\tif (isWindows && error && error.code === 'EPERM' && Date.now() < retryUntil) {\n\t\t\t\tthis.logService.info(`Failed renaming ${extractPath} to ${renamePath} with 'EPERM' error. Trying again...`, identifier.id);\n\t\t\t\treturn this.rename(identifier, extractPath, renamePath, retryUntil);\n\t\t\t}\n\t\t\tthrow new ExtensionManagementError(error.message || localize('renameError', \"Unknown error while renaming {0} to {1}\", extractPath, renamePath), error.code || INSTALL_ERROR_RENAMING);\n\t\t}\n\t}\n\n\tprivate async scanSystemExtensions(): Promise<ILocalExtension[]> {\n\t\tthis.logService.trace('Started scanning system extensions');\n\t\tconst systemExtensionsPromise = this.scanDefaultSystemExtensions();\n\t\tif (this.environmentService.isBuilt) {\n\t\t\treturn systemExtensionsPromise;\n\t\t}\n\n\t\t// Scan other system extensions during development\n\t\tconst devSystemExtensionsPromise = this.scanDevSystemExtensions();\n\t\tconst [systemExtensions, devSystemExtensions] = await Promise.all([systemExtensionsPromise, devSystemExtensionsPromise]);\n\t\treturn [...systemExtensions, ...devSystemExtensions];\n\t}\n\n\tprivate async scanExtensionsInDir(dir: string, type: ExtensionType): Promise<ILocalExtension[]> {\n\t\tconst limiter = new Limiter<any>(10);\n\t\tconst stat = await this.fileService.resolve(URI.file(dir));\n\t\tif (stat.children) {\n\t\t\tconst extensions = await Promise.all<ILocalExtension>(stat.children.filter(c => c.isDirectory)\n\t\t\t\t.map(c => limiter.queue(async () => {\n\t\t\t\t\tif (type === ExtensionType.User && basename(c.resource).indexOf('.') === 0) { // Do not consider user extension folder starting with `.`\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn this.scanExtension(c.resource, type);\n\t\t\t\t})));\n\t\t\treturn extensions.filter(e => e && e.identifier);\n\t\t}\n\t\treturn [];\n\t}\n\n\tprivate async scanExtension(extensionLocation: URI, type: ExtensionType): Promise<ILocalExtension | null> {\n\t\ttry {\n\t\t\tconst stat = await this.fileService.resolve(extensionLocation);\n\t\t\tif (stat.children) {\n\t\t\t\tconst { manifest, metadata } = await this.readManifest(extensionLocation.fsPath);\n\t\t\t\tconst readmeUrl = stat.children.find(({ name }) => /^readme(\\.txt|\\.md|)$/i.test(name))?.resource;\n\t\t\t\tconst changelogUrl = stat.children.find(({ name }) => /^changelog(\\.txt|\\.md|)$/i.test(name))?.resource;\n\t\t\t\tconst identifier = { id: getGalleryExtensionId(manifest.publisher, manifest.name) };\n\t\t\t\tconst local = <ILocalExtension>{ type, identifier, manifest, location: extensionLocation, readmeUrl, changelogUrl, publisherDisplayName: null, publisherId: null, isMachineScoped: false, isBuiltin: type === ExtensionType.System };\n\t\t\t\tif (metadata) {\n\t\t\t\t\tthis.setMetadata(local, metadata);\n\t\t\t\t\tlocal.installedTimestamp = metadata.installedTimestamp;\n\t\t\t\t}\n\t\t\t\treturn local;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (type !== ExtensionType.System) {\n\t\t\t\tthis.logService.trace(e);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate async scanDefaultSystemExtensions(): Promise<ILocalExtension[]> {\n\t\tconst result = await this.scanExtensionsInDir(this.systemExtensionsPath, ExtensionType.System);\n\t\tthis.logService.trace('Scanned system extensions:', result.length);\n\t\treturn result;\n\t}\n\n\tprivate async scanDevSystemExtensions(): Promise<ILocalExtension[]> {\n\t\tconst devSystemExtensionsList = this.getDevSystemExtensionsList();\n\t\tif (devSystemExtensionsList.length) {\n\t\t\tconst result = await this.scanExtensionsInDir(this.devSystemExtensionsPath, ExtensionType.System);\n\t\t\tthis.logService.trace('Scanned dev system extensions:', result.length);\n\t\t\treturn result.filter(r => devSystemExtensionsList.some(id => areSameExtensions(r.identifier, { id })));\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate setMetadata(local: IRelaxedLocalExtension, metadata: IMetadata): void {\n\t\tlocal.publisherDisplayName = metadata.publisherDisplayName || null;\n\t\tlocal.publisherId = metadata.publisherId || null;\n\t\tlocal.identifier.uuid = metadata.id;\n\t\tlocal.isMachineScoped = !!metadata.isMachineScoped;\n\t\tlocal.isBuiltin = local.type === ExtensionType.System || !!metadata.isBuiltin;\n\t}\n\n\tprivate async removeUninstalledExtensions(): Promise<void> {\n\t\tconst uninstalled = await this.getUninstalledExtensions();\n\t\tconst extensions = await this.scanAllUserExtensions(); // All user extensions\n\t\tconst installed: Set<string> = new Set<string>();\n\t\tfor (const e of extensions) {\n\t\t\tif (!uninstalled[new ExtensionIdentifierWithVersion(e.identifier, e.manifest.version).key()]) {\n\t\t\t\tinstalled.add(e.identifier.id.toLowerCase());\n\t\t\t}\n\t\t}\n\t\tconst byExtension: ILocalExtension[][] = groupByExtension(extensions, e => e.identifier);\n\t\tawait Promises.settled(byExtension.map(async e => {\n\t\t\tconst latest = e.sort((a, b) => semver.rcompare(a.manifest.version, b.manifest.version))[0];\n\t\t\tif (!installed.has(latest.identifier.id.toLowerCase())) {\n\t\t\t\tawait this.beforeRemovingExtension(latest);\n\t\t\t}\n\t\t}));\n\t\tconst toRemove: ILocalExtension[] = extensions.filter(e => uninstalled[new ExtensionIdentifierWithVersion(e.identifier, e.manifest.version).key()]);\n\t\tawait Promises.settled(toRemove.map(e => this.removeUninstalledExtension(e)));\n\t}\n\n\tprivate async removeOutdatedExtensions(): Promise<void> {\n\t\tconst extensions = await this.scanAllUserExtensions();\n\t\tconst toRemove: ILocalExtension[] = [];\n\n\t\t// Outdated extensions\n\t\tconst byExtension: ILocalExtension[][] = groupByExtension(extensions, e => e.identifier);\n\t\ttoRemove.push(...flatten(byExtension.map(p => p.sort((a, b) => semver.rcompare(a.manifest.version, b.manifest.version)).slice(1))));\n\n\t\tawait Promises.settled(toRemove.map(extension => this.removeExtension(extension, 'outdated')));\n\t}\n\n\tprivate getDevSystemExtensionsList(): string[] {\n\t\treturn (this.productService.builtInExtensions || []).map(e => e.name);\n\t}\n\n\tprivate joinErrors(errorOrErrors: (Error | string) | (Array<Error | string>)): Error {\n\t\tconst errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];\n\t\tif (errors.length === 1) {\n\t\t\treturn errors[0] instanceof Error ? <Error>errors[0] : new Error(<string>errors[0]);\n\t\t}\n\t\treturn errors.reduce<Error>((previousValue: Error, currentValue: Error | string) => {\n\t\t\treturn new Error(`${previousValue.message}${previousValue.message ? ',' : ''}${currentValue instanceof Error ? currentValue.message : currentValue}`);\n\t\t}, new Error(''));\n\t}\n\n\tprivate _devSystemExtensionsPath: string | null = null;\n\tprivate get devSystemExtensionsPath(): string {\n\t\tif (!this._devSystemExtensionsPath) {\n\t\t\tthis._devSystemExtensionsPath = path.normalize(path.join(FileAccess.asFileUri('', require).fsPath, '..', '.build', 'builtInExtensions'));\n\t\t}\n\t\treturn this._devSystemExtensionsPath;\n\t}\n\n\tprivate async readManifest(extensionPath: string): Promise<{ manifest: IExtensionManifest; metadata: IStoredMetadata | null; }> {\n\t\tconst promises = [\n\t\t\tfs.promises.readFile(path.join(extensionPath, 'package.json'), 'utf8')\n\t\t\t\t.then(raw => this.parseManifest(raw)),\n\t\t\tfs.promises.readFile(path.join(extensionPath, 'package.nls.json'), 'utf8')\n\t\t\t\t.then(undefined, err => err.code !== 'ENOENT' ? Promise.reject<string>(err) : '{}')\n\t\t\t\t.then(raw => JSON.parse(raw))\n\t\t];\n\n\t\tconst [{ manifest, metadata }, translations] = await Promise.all(promises);\n\t\treturn {\n\t\t\tmanifest: localizeManifest(manifest, translations),\n\t\t\tmetadata\n\t\t};\n\t}\n\n\tprivate parseManifest(raw: string): Promise<{ manifest: IExtensionManifest; metadata: IMetadata | null; }> {\n\t\treturn new Promise((c, e) => {\n\t\t\ttry {\n\t\t\t\tconst manifest = JSON.parse(raw);\n\t\t\t\tconst metadata = manifest.__metadata || null;\n\t\t\t\tc({ manifest, metadata });\n\t\t\t} catch (err) {\n\t\t\t\te(new Error(localize('invalidManifest', \"Extension invalid: package.json is not a JSON file.\")));\n\t\t\t}\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as nls from 'vs/nls';\nimport * as path from 'vs/base/common/path';\nimport * as pfs from 'vs/base/node/pfs';\nimport { toDisposable, Disposable } from 'vs/base/common/lifecycle';\nimport { isNonEmptyArray } from 'vs/base/common/arrays';\nimport { zip, IFile } from 'vs/base/node/zip';\nimport {\n\tIExtensionManagementService, IExtensionGalleryService, ILocalExtension,\n\tIGalleryExtension, IGalleryMetadata,\n\tInstallExtensionEvent, DidInstallExtensionEvent, DidUninstallExtensionEvent,\n\tStatisticType,\n\tIExtensionIdentifier,\n\tIReportedExtension,\n\tInstallOperation,\n\tINSTALL_ERROR_MALICIOUS,\n\tINSTALL_ERROR_INCOMPATIBLE,\n\tExtensionManagementError,\n\tInstallOptions,\n\tUninstallOptions\n} from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { areSameExtensions, getGalleryExtensionId, getMaliciousExtensionsSet, getGalleryExtensionTelemetryData, getLocalExtensionTelemetryData, ExtensionIdentifierWithVersion } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { createCancelablePromise, CancelablePromise, Promises } from 'vs/base/common/async';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport * as semver from 'vs/base/common/semver/semver';\nimport { URI } from 'vs/base/common/uri';\nimport product from 'vs/platform/product/common/product';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { ExtensionsManifestCache } from 'vs/platform/extensionManagement/node/extensionsManifestCache';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { isEngineValid } from 'vs/platform/extensions/common/extensionValidator';\nimport { joinPath } from 'vs/base/common/resources';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { IDownloadService } from 'vs/platform/download/common/download';\nimport { optional, IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { Schemas } from 'vs/base/common/network';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { getManifest } from 'vs/platform/extensionManagement/node/extensionManagementUtil';\nimport { IExtensionManifest, ExtensionType } from 'vs/platform/extensions/common/extensions';\nimport { ExtensionsDownloader } from 'vs/platform/extensionManagement/node/extensionDownloader';\nimport { ExtensionsScanner, ILocalExtensionManifest, IMetadata } from 'vs/platform/extensionManagement/node/extensionsScanner';\nimport { ExtensionsLifecycle } from 'vs/platform/extensionManagement/node/extensionLifecycle';\nimport { ExtensionsWatcher } from 'vs/platform/extensionManagement/node/extensionsWatcher';\nimport { IFileService } from 'vs/platform/files/common/files';\n\nconst INSTALL_ERROR_UNSET_UNINSTALLED = 'unsetUninstalled';\nconst INSTALL_ERROR_DOWNLOADING = 'downloading';\nconst INSTALL_ERROR_VALIDATING = 'validating';\nconst INSTALL_ERROR_LOCAL = 'local';\nconst ERROR_UNKNOWN = 'unknown';\n\ninterface InstallableExtension {\n\tzipPath: string;\n\tidentifierWithVersion: ExtensionIdentifierWithVersion;\n\tmetadata?: IMetadata;\n}\n\nexport class ExtensionManagementService extends Disposable implements IExtensionManagementService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly extensionsScanner: ExtensionsScanner;\n\tprivate reportedExtensions: Promise<IReportedExtension[]> | undefined;\n\tprivate lastReportTimestamp = 0;\n\tprivate readonly installingExtensions = new Map<string, CancelablePromise<ILocalExtension>>();\n\tprivate readonly uninstallingExtensions: Map<string, CancelablePromise<void>> = new Map<string, CancelablePromise<void>>();\n\tprivate readonly manifestCache: ExtensionsManifestCache;\n\tprivate readonly extensionsDownloader: ExtensionsDownloader;\n\n\tprivate readonly _onInstallExtension = this._register(new Emitter<InstallExtensionEvent>());\n\treadonly onInstallExtension: Event<InstallExtensionEvent> = this._onInstallExtension.event;\n\n\tprivate readonly _onDidInstallExtension = this._register(new Emitter<DidInstallExtensionEvent>());\n\treadonly onDidInstallExtension: Event<DidInstallExtensionEvent> = this._onDidInstallExtension.event;\n\n\tprivate readonly _onUninstallExtension = this._register(new Emitter<IExtensionIdentifier>());\n\treadonly onUninstallExtension: Event<IExtensionIdentifier> = this._onUninstallExtension.event;\n\n\tprivate _onDidUninstallExtension = this._register(new Emitter<DidUninstallExtensionEvent>());\n\tonDidUninstallExtension: Event<DidUninstallExtensionEvent> = this._onDidUninstallExtension.event;\n\n\tconstructor(\n\t\t@INativeEnvironmentService private readonly environmentService: INativeEnvironmentService,\n\t\t@IExtensionGalleryService private readonly galleryService: IExtensionGalleryService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@optional(IDownloadService) private downloadService: IDownloadService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@IFileService fileService: IFileService,\n\t) {\n\t\tsuper();\n\t\tconst extensionLifecycle = this._register(instantiationService.createInstance(ExtensionsLifecycle));\n\t\tthis.extensionsScanner = this._register(instantiationService.createInstance(ExtensionsScanner, extension => extensionLifecycle.postUninstall(extension)));\n\t\tthis.manifestCache = this._register(new ExtensionsManifestCache(environmentService, this));\n\t\tthis.extensionsDownloader = this._register(instantiationService.createInstance(ExtensionsDownloader));\n\t\tconst extensionsWatcher = this._register(new ExtensionsWatcher(this, fileService, environmentService, logService));\n\n\t\tthis._register(extensionsWatcher.onDidChangeExtensionsByAnotherSource(({ added, removed }) => {\n\t\t\tadded.forEach(extension => this._onDidInstallExtension.fire({ identifier: extension.identifier, operation: InstallOperation.None, local: extension }));\n\t\t\tremoved.forEach(extension => this._onDidUninstallExtension.fire({ identifier: extension }));\n\t\t}));\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis.installingExtensions.forEach(promise => promise.cancel());\n\t\t\tthis.uninstallingExtensions.forEach(promise => promise.cancel());\n\t\t\tthis.installingExtensions.clear();\n\t\t\tthis.uninstallingExtensions.clear();\n\t\t}));\n\t}\n\n\tasync zip(extension: ILocalExtension): Promise<URI> {\n\t\tthis.logService.trace('ExtensionManagementService#zip', extension.identifier.id);\n\t\tconst files = await this.collectFiles(extension);\n\t\tconst location = await zip(joinPath(this.environmentService.tmpDir, generateUuid()).fsPath, files);\n\t\treturn URI.file(location);\n\t}\n\n\tasync unzip(zipLocation: URI): Promise<IExtensionIdentifier> {\n\t\tthis.logService.trace('ExtensionManagementService#unzip', zipLocation.toString());\n\t\tconst local = await this.install(zipLocation);\n\t\treturn local.identifier;\n\t}\n\n\tasync getManifest(vsix: URI): Promise<IExtensionManifest> {\n\t\tconst downloadLocation = await this.downloadVsix(vsix);\n\t\tconst zipPath = path.resolve(downloadLocation.fsPath);\n\t\treturn getManifest(zipPath);\n\t}\n\n\tprivate async collectFiles(extension: ILocalExtension): Promise<IFile[]> {\n\n\t\tconst collectFilesFromDirectory = async (dir: string): Promise<string[]> => {\n\t\t\tlet entries = await pfs.readdir(dir);\n\t\t\tentries = entries.map(e => path.join(dir, e));\n\t\t\tconst stats = await Promise.all(entries.map(e => fs.promises.stat(e)));\n\t\t\tlet promise: Promise<string[]> = Promise.resolve([]);\n\t\t\tstats.forEach((stat, index) => {\n\t\t\t\tconst entry = entries[index];\n\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\tpromise = promise.then(result => ([...result, entry]));\n\t\t\t\t}\n\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\tpromise = promise\n\t\t\t\t\t\t.then(result => collectFilesFromDirectory(entry)\n\t\t\t\t\t\t\t.then(files => ([...result, ...files])));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn promise;\n\t\t};\n\n\t\tconst files = await collectFilesFromDirectory(extension.location.fsPath);\n\t\treturn files.map(f => (<IFile>{ path: `extension/${path.relative(extension.location.fsPath, f)}`, localPath: f }));\n\t}\n\n\tasync install(vsix: URI, options: InstallOptions = {}): Promise<ILocalExtension> {\n\t\tthis.logService.trace('ExtensionManagementService#install', vsix.toString());\n\t\treturn createCancelablePromise(async token => {\n\n\t\t\tconst downloadLocation = await this.downloadVsix(vsix);\n\t\t\tconst zipPath = path.resolve(downloadLocation.fsPath);\n\n\t\t\tconst manifest = await getManifest(zipPath);\n\t\t\tconst identifier = { id: getGalleryExtensionId(manifest.publisher, manifest.name) };\n\t\t\tlet operation: InstallOperation = InstallOperation.Install;\n\t\t\tif (manifest.engines && manifest.engines.vscode && !isEngineValid(manifest.engines.vscode, product.version)) {\n\t\t\t\tthrow new Error(nls.localize('incompatible', \"Unable to install extension '{0}' as it is not compatible with VS Code '{1}'.\", identifier.id, product.version));\n\t\t\t}\n\n\t\t\tconst identifierWithVersion = new ExtensionIdentifierWithVersion(identifier, manifest.version);\n\t\t\tconst installedExtensions = await this.getInstalled(ExtensionType.User);\n\t\t\tconst existing = installedExtensions.find(i => areSameExtensions(identifier, i.identifier));\n\t\t\tif (existing) {\n\t\t\t\toptions.isMachineScoped = options.isMachineScoped || existing.isMachineScoped;\n\t\t\t\toptions.isBuiltin = options.isBuiltin || existing.isBuiltin;\n\t\t\t\toperation = InstallOperation.Update;\n\t\t\t\tif (identifierWithVersion.equals(new ExtensionIdentifierWithVersion(existing.identifier, existing.manifest.version))) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.extensionsScanner.removeExtension(existing, 'existing');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(nls.localize('restartCode', \"Please restart VS Code before reinstalling {0}.\", manifest.displayName || manifest.name));\n\t\t\t\t\t}\n\t\t\t\t} else if (semver.gt(existing.manifest.version, manifest.version)) {\n\t\t\t\t\tawait this.uninstallExtension(existing);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Remove the extension with same version if it is already uninstalled.\n\t\t\t\t// Installing a VSIX extension shall replace the existing extension always.\n\t\t\t\tconst existing = await this.unsetUninstalledAndGetLocal(identifierWithVersion);\n\t\t\t\tif (existing) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.extensionsScanner.removeExtension(existing, 'existing');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(nls.localize('restartCode', \"Please restart VS Code before reinstalling {0}.\", manifest.displayName || manifest.name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.logService.info('Installing the extension:', identifier.id);\n\t\t\tthis._onInstallExtension.fire({ identifier, zipPath });\n\n\t\t\tlet metadata: IGalleryMetadata | undefined;\n\t\t\ttry {\n\t\t\t\tmetadata = await this.getGalleryMetadata(getGalleryExtensionId(manifest.publisher, manifest.name));\n\t\t\t} catch (e) { /* Ignore */ }\n\n\t\t\ttry {\n\t\t\t\tconst local = await this.installFromZipPath(identifierWithVersion, zipPath, { ...(metadata || {}), ...options }, options, operation, token);\n\t\t\t\tthis.logService.info('Successfully installed the extension:', identifier.id);\n\t\t\t\treturn local;\n\t\t\t} catch (e) {\n\t\t\t\tthis.logService.error('Failed to install the extension:', identifier.id, e.message);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async downloadVsix(vsix: URI): Promise<URI> {\n\t\tif (vsix.scheme === Schemas.file) {\n\t\t\treturn vsix;\n\t\t}\n\t\tif (!this.downloadService) {\n\t\t\tthrow new Error('Download service is not available');\n\t\t}\n\n\t\tconst downloadedLocation = joinPath(this.environmentService.tmpDir, generateUuid());\n\t\tawait this.downloadService.download(vsix, downloadedLocation);\n\t\treturn downloadedLocation;\n\t}\n\n\tprivate async installFromZipPath(identifierWithVersion: ExtensionIdentifierWithVersion, zipPath: string, metadata: IMetadata | undefined, options: InstallOptions, operation: InstallOperation, token: CancellationToken): Promise<ILocalExtension> {\n\t\ttry {\n\t\t\tconst local = await this.installExtension({ zipPath, identifierWithVersion, metadata }, token);\n\t\t\ttry {\n\t\t\t\tawait this.installDependenciesAndPackExtensions(local, undefined, options);\n\t\t\t} catch (error) {\n\t\t\t\tif (isNonEmptyArray(local.manifest.extensionDependencies)) {\n\t\t\t\t\tthis.logService.warn(`Cannot install dependencies of extension:`, local.identifier.id, error.message);\n\t\t\t\t}\n\t\t\t\tif (isNonEmptyArray(local.manifest.extensionPack)) {\n\t\t\t\t\tthis.logService.warn(`Cannot install packed extensions of extension:`, local.identifier.id, error.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._onDidInstallExtension.fire({ identifier: identifierWithVersion, zipPath, local, operation });\n\t\t\treturn local;\n\t\t} catch (error) {\n\t\t\tthis._onDidInstallExtension.fire({ identifier: identifierWithVersion, zipPath, operation, error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync canInstall(extension: IGalleryExtension): Promise<boolean> {\n\t\treturn true;\n\t}\n\n\tasync installFromGallery(extension: IGalleryExtension, options: InstallOptions = {}): Promise<ILocalExtension> {\n\t\tif (!this.galleryService.isEnabled()) {\n\t\t\tthrow new Error(nls.localize('MarketPlaceDisabled', \"Marketplace is not enabled\"));\n\t\t}\n\n\t\ttry {\n\t\t\textension = await this.checkAndGetCompatibleVersion(extension);\n\t\t} catch (error) {\n\t\t\tconst errorCode = error && (<ExtensionManagementError>error).code ? (<ExtensionManagementError>error).code : ERROR_UNKNOWN;\n\t\t\tthis.logService.error(`Failed to install extension:`, extension.identifier.id, error ? error.message : errorCode);\n\t\t\tthis.reportTelemetry(this.getTelemetryEvent(InstallOperation.Install), getGalleryExtensionTelemetryData(extension), undefined, error);\n\t\t\tif (error instanceof Error) {\n\t\t\t\terror.name = errorCode;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst key = new ExtensionIdentifierWithVersion(extension.identifier, extension.version).key();\n\t\tlet cancellablePromise = this.installingExtensions.get(key);\n\t\tif (!cancellablePromise) {\n\t\t\tcancellablePromise = createCancelablePromise(token => this.doInstallFromGallery(extension, options, token));\n\t\t\tthis.installingExtensions.set(key, cancellablePromise);\n\t\t\tcancellablePromise.finally(() => this.installingExtensions.delete(key));\n\t\t}\n\n\t\treturn cancellablePromise;\n\t}\n\n\tprivate async doInstallFromGallery(extension: IGalleryExtension, options: InstallOptions, token: CancellationToken): Promise<ILocalExtension> {\n\t\tconst startTime = new Date().getTime();\n\t\tlet operation: InstallOperation = InstallOperation.Install;\n\t\tthis.logService.info('Installing extension:', extension.identifier.id);\n\t\tthis._onInstallExtension.fire({ identifier: extension.identifier, gallery: extension });\n\n\t\ttry {\n\t\t\tconst installed = await this.getInstalled(ExtensionType.User);\n\t\t\tconst existingExtension = installed.find(i => areSameExtensions(i.identifier, extension.identifier));\n\t\t\tif (existingExtension) {\n\t\t\t\toperation = InstallOperation.Update;\n\t\t\t}\n\n\t\t\tconst installableExtension = await this.downloadInstallableExtension(extension, operation);\n\t\t\tinstallableExtension.metadata.isMachineScoped = options.isMachineScoped || existingExtension?.isMachineScoped;\n\t\t\tinstallableExtension.metadata.isBuiltin = options.isBuiltin || existingExtension?.isBuiltin;\n\t\t\tconst local = await this.installExtension(installableExtension, token);\n\n\t\t\ttry { await this.extensionsDownloader.delete(URI.file(installableExtension.zipPath)); } catch (error) { /* Ignore */ }\n\n\t\t\tif (!options.donotIncludePackAndDependencies) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.installDependenciesAndPackExtensions(local, existingExtension, options);\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttry { await this.uninstall(local); } catch (error) { /* Ignore */ }\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingExtension && semver.neq(existingExtension.manifest.version, extension.version)) {\n\t\t\t\tawait this.extensionsScanner.setUninstalled(existingExtension);\n\t\t\t}\n\n\t\t\tthis.logService.info(`Extensions installed successfully:`, extension.identifier.id);\n\t\t\tthis._onDidInstallExtension.fire({ identifier: extension.identifier, gallery: extension, local, operation });\n\t\t\tthis.reportTelemetry(this.getTelemetryEvent(operation), getGalleryExtensionTelemetryData(extension), new Date().getTime() - startTime, undefined);\n\t\t\treturn local;\n\n\t\t} catch (error) {\n\t\t\tconst errorCode = error && (<ExtensionManagementError>error).code ? (<ExtensionManagementError>error).code : ERROR_UNKNOWN;\n\t\t\tthis.logService.error(`Failed to install extension:`, extension.identifier.id, error ? error.message : errorCode);\n\t\t\tthis._onDidInstallExtension.fire({ identifier: extension.identifier, gallery: extension, operation, error: errorCode });\n\t\t\tthis.reportTelemetry(this.getTelemetryEvent(operation), getGalleryExtensionTelemetryData(extension), new Date().getTime() - startTime, error);\n\t\t\tif (error instanceof Error) {\n\t\t\t\terror.name = errorCode;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async checkAndGetCompatibleVersion(extension: IGalleryExtension): Promise<IGalleryExtension> {\n\t\tif (await this.isMalicious(extension)) {\n\t\t\tthrow new ExtensionManagementError(nls.localize('malicious extension', \"Can't install extension since it was reported to be problematic.\"), INSTALL_ERROR_MALICIOUS);\n\t\t}\n\n\t\tconst compatibleExtension = await this.galleryService.getCompatibleExtension(extension);\n\t\tif (!compatibleExtension) {\n\t\t\tthrow new ExtensionManagementError(nls.localize('notFoundCompatibleDependency', \"Unable to install '{0}' extension because it is not compatible with the current version of VS Code (version {1}).\", extension.identifier.id, product.version), INSTALL_ERROR_INCOMPATIBLE);\n\t\t}\n\n\t\treturn compatibleExtension;\n\t}\n\n\tasync reinstallFromGallery(extension: ILocalExtension): Promise<void> {\n\t\tthis.logService.trace('ExtensionManagementService#reinstallFromGallery', extension.identifier.id);\n\t\tif (!this.galleryService.isEnabled()) {\n\t\t\tthrow new Error(nls.localize('MarketPlaceDisabled', \"Marketplace is not enabled\"));\n\t\t}\n\n\t\tconst galleryExtension = await this.findGalleryExtension(extension);\n\t\tif (!galleryExtension) {\n\t\t\tthrow new Error(nls.localize('Not a Marketplace extension', \"Only Marketplace Extensions can be reinstalled\"));\n\t\t}\n\n\t\tawait this.extensionsScanner.setUninstalled(extension);\n\t\ttry {\n\t\t\tawait this.extensionsScanner.removeUninstalledExtension(extension);\n\t\t} catch (e) {\n\t\t\tthrow new Error(nls.localize('removeError', \"Error while removing the extension: {0}. Please Quit and Start VS Code before trying again.\", toErrorMessage(e)));\n\t\t}\n\n\t\tawait this.installFromGallery(galleryExtension);\n\t}\n\n\tprivate getTelemetryEvent(operation: InstallOperation): string {\n\t\treturn operation === InstallOperation.Update ? 'extensionGallery:update' : 'extensionGallery:install';\n\t}\n\n\tprivate async isMalicious(extension: IGalleryExtension): Promise<boolean> {\n\t\tconst report = await this.getExtensionsReport();\n\t\treturn getMaliciousExtensionsSet(report).has(extension.identifier.id);\n\t}\n\n\tprivate async downloadInstallableExtension(extension: IGalleryExtension, operation: InstallOperation): Promise<Required<InstallableExtension>> {\n\t\tconst metadata = <IGalleryMetadata>{\n\t\t\tid: extension.identifier.uuid,\n\t\t\tpublisherId: extension.publisherId,\n\t\t\tpublisherDisplayName: extension.publisherDisplayName,\n\t\t};\n\n\t\tlet zipPath: string | undefined;\n\t\ttry {\n\t\t\tthis.logService.trace('Started downloading extension:', extension.identifier.id);\n\t\t\tzipPath = (await this.extensionsDownloader.downloadExtension(extension, operation)).fsPath;\n\t\t\tthis.logService.info('Downloaded extension:', extension.identifier.id, zipPath);\n\t\t} catch (error) {\n\t\t\tthrow new ExtensionManagementError(this.joinErrors(error).message, INSTALL_ERROR_DOWNLOADING);\n\t\t}\n\n\t\ttry {\n\t\t\tconst manifest = await getManifest(zipPath);\n\t\t\treturn (<Required<InstallableExtension>>{ zipPath, identifierWithVersion: new ExtensionIdentifierWithVersion(extension.identifier, manifest.version), metadata });\n\t\t} catch (error) {\n\t\t\tthrow new ExtensionManagementError(this.joinErrors(error).message, INSTALL_ERROR_VALIDATING);\n\t\t}\n\t}\n\n\tprivate async installExtension(installableExtension: InstallableExtension, token: CancellationToken): Promise<ILocalExtension> {\n\t\ttry {\n\t\t\tconst local = await this.unsetUninstalledAndGetLocal(installableExtension.identifierWithVersion);\n\t\t\tif (local) {\n\t\t\t\treturn installableExtension.metadata ? this.extensionsScanner.saveMetadataForLocalExtension(local, installableExtension.metadata) : local;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (isMacintosh) {\n\t\t\t\tthrow new ExtensionManagementError(nls.localize('quitCode', \"Unable to install the extension. Please Quit and Start VS Code before reinstalling.\"), INSTALL_ERROR_UNSET_UNINSTALLED);\n\t\t\t} else {\n\t\t\t\tthrow new ExtensionManagementError(nls.localize('exitCode', \"Unable to install the extension. Please Exit and Start VS Code before reinstalling.\"), INSTALL_ERROR_UNSET_UNINSTALLED);\n\t\t\t}\n\t\t}\n\t\treturn this.extractAndInstall(installableExtension, token);\n\t}\n\n\tprivate async unsetUninstalledAndGetLocal(identifierWithVersion: ExtensionIdentifierWithVersion): Promise<ILocalExtension | null> {\n\t\tconst isUninstalled = await this.isUninstalled(identifierWithVersion);\n\t\tif (!isUninstalled) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.logService.trace('Removing the extension from uninstalled list:', identifierWithVersion.id);\n\t\t// If the same version of extension is marked as uninstalled, remove it from there and return the local.\n\t\tconst local = await this.extensionsScanner.setInstalled(identifierWithVersion);\n\t\tthis.logService.info('Removed the extension from uninstalled list:', identifierWithVersion.id);\n\n\t\treturn local;\n\t}\n\n\tprivate async extractAndInstall({ zipPath, identifierWithVersion, metadata }: InstallableExtension, token: CancellationToken): Promise<ILocalExtension> {\n\t\tlet local = await this.extensionsScanner.extractUserExtension(identifierWithVersion, zipPath, token);\n\t\tthis.logService.info('Installation completed.', identifierWithVersion.id);\n\t\tif (metadata) {\n\t\t\tlocal = await this.extensionsScanner.saveMetadataForLocalExtension(local, metadata);\n\t\t}\n\t\treturn local;\n\t}\n\n\tprivate async installDependenciesAndPackExtensions(installed: ILocalExtension, existing: ILocalExtension | undefined, options: InstallOptions): Promise<void> {\n\t\tif (!this.galleryService.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\t\tconst dependenciesAndPackExtensions: string[] = installed.manifest.extensionDependencies || [];\n\t\tif (installed.manifest.extensionPack) {\n\t\t\tfor (const extension of installed.manifest.extensionPack) {\n\t\t\t\t// add only those extensions which are new in currently installed extension\n\t\t\t\tif (!(existing && existing.manifest.extensionPack && existing.manifest.extensionPack.some(old => areSameExtensions({ id: old }, { id: extension })))) {\n\t\t\t\t\tif (dependenciesAndPackExtensions.every(e => !areSameExtensions({ id: e }, { id: extension }))) {\n\t\t\t\t\t\tdependenciesAndPackExtensions.push(extension);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dependenciesAndPackExtensions.length) {\n\t\t\tconst installed = await this.getInstalled();\n\t\t\t// filter out installed extensions\n\t\t\tconst names = dependenciesAndPackExtensions.filter(id => installed.every(({ identifier: galleryIdentifier }) => !areSameExtensions(galleryIdentifier, { id })));\n\t\t\tif (names.length) {\n\t\t\t\tconst galleryResult = await this.galleryService.query({ names, pageSize: dependenciesAndPackExtensions.length }, CancellationToken.None);\n\t\t\t\tconst extensionsToInstall = galleryResult.firstPage;\n\t\t\t\ttry {\n\t\t\t\t\tawait Promises.settled(extensionsToInstall.map(e => this.installFromGallery(e, options)));\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttry { await this.rollback(extensionsToInstall); } catch (e) { /* ignore */ }\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async rollback(extensions: IGalleryExtension[]): Promise<void> {\n\t\tconst installed = await this.getInstalled(ExtensionType.User);\n\t\tconst extensionsToUninstall = installed.filter(local => extensions.some(galleryExtension => new ExtensionIdentifierWithVersion(local.identifier, local.manifest.version).equals(new ExtensionIdentifierWithVersion(galleryExtension.identifier, galleryExtension.version)))); // Check with version because we want to rollback the exact version\n\t\tawait Promises.settled(extensionsToUninstall.map(local => this.uninstall(local)));\n\t}\n\n\tasync uninstall(extension: ILocalExtension, options: UninstallOptions = {}): Promise<void> {\n\t\tthis.logService.trace('ExtensionManagementService#uninstall', extension.identifier.id);\n\t\tconst installed = await this.getInstalled(ExtensionType.User);\n\t\tconst extensionToUninstall = installed.find(e => areSameExtensions(e.identifier, extension.identifier));\n\t\tif (!extensionToUninstall) {\n\t\t\tthrow new Error(nls.localize('notInstalled', \"Extension '{0}' is not installed.\", extension.manifest.displayName || extension.manifest.name));\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.checkForDependenciesAndUninstall(extensionToUninstall, installed, options);\n\t\t} catch (error) {\n\t\t\tthrow this.joinErrors(error);\n\t\t}\n\t}\n\n\tasync updateMetadata(local: ILocalExtension, metadata: IGalleryMetadata): Promise<ILocalExtension> {\n\t\tthis.logService.trace('ExtensionManagementService#updateMetadata', local.identifier.id);\n\t\tlocal = await this.extensionsScanner.saveMetadataForLocalExtension(local, { ...((<ILocalExtensionManifest>local.manifest).__metadata || {}), ...metadata });\n\t\tthis.manifestCache.invalidate();\n\t\treturn local;\n\t}\n\n\tasync updateExtensionScope(local: ILocalExtension, isMachineScoped: boolean): Promise<ILocalExtension> {\n\t\tthis.logService.trace('ExtensionManagementService#updateExtensionScope', local.identifier.id);\n\t\tlocal = await this.extensionsScanner.saveMetadataForLocalExtension(local, { ...((<ILocalExtensionManifest>local.manifest).__metadata || {}), isMachineScoped });\n\t\tthis.manifestCache.invalidate();\n\t\treturn local;\n\t}\n\n\tprivate async getGalleryMetadata(extensionName: string): Promise<IGalleryMetadata | undefined> {\n\t\tconst galleryExtension = await this.findGalleryExtensionByName(extensionName);\n\t\treturn galleryExtension ? <IGalleryMetadata>{ id: galleryExtension.identifier.uuid, publisherDisplayName: galleryExtension.publisherDisplayName, publisherId: galleryExtension.publisherId } : undefined;\n\t}\n\n\tprivate async findGalleryExtension(local: ILocalExtension): Promise<IGalleryExtension> {\n\t\tif (local.identifier.uuid) {\n\t\t\tconst galleryExtension = await this.findGalleryExtensionById(local.identifier.uuid);\n\t\t\treturn galleryExtension ? galleryExtension : this.findGalleryExtensionByName(local.identifier.id);\n\t\t}\n\t\treturn this.findGalleryExtensionByName(local.identifier.id);\n\t}\n\n\tprivate async findGalleryExtensionById(uuid: string): Promise<IGalleryExtension> {\n\t\tconst galleryResult = await this.galleryService.query({ ids: [uuid], pageSize: 1 }, CancellationToken.None);\n\t\treturn galleryResult.firstPage[0];\n\t}\n\n\tprivate async findGalleryExtensionByName(name: string): Promise<IGalleryExtension> {\n\t\tconst galleryResult = await this.galleryService.query({ names: [name], pageSize: 1 }, CancellationToken.None);\n\t\treturn galleryResult.firstPage[0];\n\t}\n\n\tprivate joinErrors(errorOrErrors: (Error | string) | (Array<Error | string>)): Error {\n\t\tconst errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];\n\t\tif (errors.length === 1) {\n\t\t\treturn errors[0] instanceof Error ? <Error>errors[0] : new Error(<string>errors[0]);\n\t\t}\n\t\treturn errors.reduce<Error>((previousValue: Error, currentValue: Error | string) => {\n\t\t\treturn new Error(`${previousValue.message}${previousValue.message ? ',' : ''}${currentValue instanceof Error ? currentValue.message : currentValue}`);\n\t\t}, new Error(''));\n\t}\n\n\tprivate async checkForDependenciesAndUninstall(extension: ILocalExtension, installed: ILocalExtension[], options: UninstallOptions): Promise<void> {\n\t\ttry {\n\t\t\tawait this.preUninstallExtension(extension);\n\t\t\tconst packedExtensions = options.donotIncludePack ? [] : this.getAllPackExtensionsToUninstall(extension, installed);\n\t\t\tawait this.uninstallExtensions(extension, packedExtensions, installed, options);\n\t\t} catch (error) {\n\t\t\tawait this.postUninstallExtension(extension, new ExtensionManagementError(error instanceof Error ? error.message : error, INSTALL_ERROR_LOCAL));\n\t\t\tthrow error;\n\t\t}\n\t\tawait this.postUninstallExtension(extension);\n\t}\n\n\tprivate async uninstallExtensions(extension: ILocalExtension, otherExtensionsToUninstall: ILocalExtension[], installed: ILocalExtension[], options: UninstallOptions): Promise<void> {\n\t\tconst extensionsToUninstall = [extension, ...otherExtensionsToUninstall];\n\t\tif (!options.donotCheckDependents) {\n\t\t\tfor (const e of extensionsToUninstall) {\n\t\t\t\tthis.checkForDependents(e, extensionsToUninstall, installed, extension);\n\t\t\t}\n\t\t}\n\t\tawait Promises.settled([this.uninstallExtension(extension), ...otherExtensionsToUninstall.map(d => this.doUninstall(d))]);\n\t}\n\n\tprivate checkForDependents(extension: ILocalExtension, extensionsToUninstall: ILocalExtension[], installed: ILocalExtension[], extensionToUninstall: ILocalExtension): void {\n\t\tconst dependents = this.getDependents(extension, installed);\n\t\tif (dependents.length) {\n\t\t\tconst remainingDependents = dependents.filter(dependent => extensionsToUninstall.indexOf(dependent) === -1);\n\t\t\tif (remainingDependents.length) {\n\t\t\t\tthrow new Error(this.getDependentsErrorMessage(extension, remainingDependents, extensionToUninstall));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getDependentsErrorMessage(dependingExtension: ILocalExtension, dependents: ILocalExtension[], extensionToUninstall: ILocalExtension): string {\n\t\tif (extensionToUninstall === dependingExtension) {\n\t\t\tif (dependents.length === 1) {\n\t\t\t\treturn nls.localize('singleDependentError', \"Cannot uninstall '{0}' extension. '{1}' extension depends on this.\",\n\t\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name);\n\t\t\t}\n\t\t\tif (dependents.length === 2) {\n\t\t\t\treturn nls.localize('twoDependentsError', \"Cannot uninstall '{0}' extension. '{1}' and '{2}' extensions depend on this.\",\n\t\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\t\t\t}\n\t\t\treturn nls.localize('multipleDependentsError', \"Cannot uninstall '{0}' extension. '{1}', '{2}' and other extension depend on this.\",\n\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\t\t}\n\t\tif (dependents.length === 1) {\n\t\t\treturn nls.localize('singleIndirectDependentError', \"Cannot uninstall '{0}' extension . It includes uninstalling '{1}' extension and '{2}' extension depends on this.\",\n\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependingExtension.manifest.displayName\n\t\t\t|| dependingExtension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name);\n\t\t}\n\t\tif (dependents.length === 2) {\n\t\t\treturn nls.localize('twoIndirectDependentsError', \"Cannot uninstall '{0}' extension. It includes uninstalling '{1}' extension and '{2}' and '{3}' extensions depend on this.\",\n\t\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependingExtension.manifest.displayName\n\t\t\t|| dependingExtension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\t\t}\n\t\treturn nls.localize('multipleIndirectDependentsError', \"Cannot uninstall '{0}' extension. It includes uninstalling '{1}' extension and '{2}', '{3}' and other extensions depend on this.\",\n\t\t\textensionToUninstall.manifest.displayName || extensionToUninstall.manifest.name, dependingExtension.manifest.displayName\n\t\t|| dependingExtension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n\n\t}\n\n\tprivate getAllPackExtensionsToUninstall(extension: ILocalExtension, installed: ILocalExtension[], checked: ILocalExtension[] = []): ILocalExtension[] {\n\t\tif (checked.indexOf(extension) !== -1) {\n\t\t\treturn [];\n\t\t}\n\t\tchecked.push(extension);\n\t\tconst extensionsPack = extension.manifest.extensionPack ? extension.manifest.extensionPack : [];\n\t\tif (extensionsPack.length) {\n\t\t\tconst packedExtensions = installed.filter(i => !i.isBuiltin && extensionsPack.some(id => areSameExtensions({ id }, i.identifier)));\n\t\t\tconst packOfPackedExtensions: ILocalExtension[] = [];\n\t\t\tfor (const packedExtension of packedExtensions) {\n\t\t\t\tpackOfPackedExtensions.push(...this.getAllPackExtensionsToUninstall(packedExtension, installed, checked));\n\t\t\t}\n\t\t\treturn [...packedExtensions, ...packOfPackedExtensions];\n\t\t}\n\t\treturn [];\n\t}\n\n\tprivate getDependents(extension: ILocalExtension, installed: ILocalExtension[]): ILocalExtension[] {\n\t\treturn installed.filter(e => e.manifest.extensionDependencies && e.manifest.extensionDependencies.some(id => areSameExtensions({ id }, extension.identifier)));\n\t}\n\n\tprivate async doUninstall(extension: ILocalExtension): Promise<void> {\n\t\ttry {\n\t\t\tawait this.preUninstallExtension(extension);\n\t\t\tawait this.uninstallExtension(extension);\n\t\t} catch (error) {\n\t\t\tawait this.postUninstallExtension(extension, new ExtensionManagementError(error instanceof Error ? error.message : error, INSTALL_ERROR_LOCAL));\n\t\t\tthrow error;\n\t\t}\n\t\tawait this.postUninstallExtension(extension);\n\t}\n\n\tprivate async preUninstallExtension(extension: ILocalExtension): Promise<void> {\n\t\tconst exists = await pfs.exists(extension.location.fsPath);\n\t\tif (!exists) {\n\t\t\tthrow new Error(nls.localize('notExists', \"Could not find extension\"));\n\t\t}\n\t\tthis.logService.info('Uninstalling extension:', extension.identifier.id);\n\t\tthis._onUninstallExtension.fire(extension.identifier);\n\t}\n\n\tprivate async uninstallExtension(local: ILocalExtension): Promise<void> {\n\t\tlet promise = this.uninstallingExtensions.get(local.identifier.id);\n\t\tif (!promise) {\n\t\t\t// Set all versions of the extension as uninstalled\n\t\t\tpromise = createCancelablePromise(async () => {\n\t\t\t\tconst userExtensions = await this.extensionsScanner.scanUserExtensions(false);\n\t\t\t\tawait this.extensionsScanner.setUninstalled(...userExtensions.filter(u => areSameExtensions(u.identifier, local.identifier)));\n\t\t\t});\n\t\t\tthis.uninstallingExtensions.set(local.identifier.id, promise);\n\t\t\tpromise.finally(() => this.uninstallingExtensions.delete(local.identifier.id));\n\t\t}\n\t\treturn promise;\n\t}\n\n\tprivate async postUninstallExtension(extension: ILocalExtension, error?: Error): Promise<void> {\n\t\tif (error) {\n\t\t\tthis.logService.error('Failed to uninstall extension:', extension.identifier.id, error.message);\n\t\t} else {\n\t\t\tthis.logService.info('Successfully uninstalled extension:', extension.identifier.id);\n\t\t\t// only report if extension has a mapped gallery extension. UUID identifies the gallery extension.\n\t\t\tif (extension.identifier.uuid) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.galleryService.reportStatistic(extension.manifest.publisher, extension.manifest.name, extension.manifest.version, StatisticType.Uninstall);\n\t\t\t\t} catch (error) { /* ignore */ }\n\t\t\t}\n\t\t}\n\t\tthis.reportTelemetry('extensionGallery:uninstall', getLocalExtensionTelemetryData(extension), undefined, error);\n\t\tconst errorcode = error ? error instanceof ExtensionManagementError ? error.code : ERROR_UNKNOWN : undefined;\n\t\tthis._onDidUninstallExtension.fire({ identifier: extension.identifier, error: errorcode });\n\t}\n\n\tgetInstalled(type: ExtensionType | null = null): Promise<ILocalExtension[]> {\n\t\treturn this.extensionsScanner.scanExtensions(type);\n\t}\n\n\tremoveDeprecatedExtensions(): Promise<void> {\n\t\treturn this.extensionsScanner.cleanUp();\n\t}\n\n\tprivate async isUninstalled(identifier: ExtensionIdentifierWithVersion): Promise<boolean> {\n\t\tconst uninstalled = await this.filterUninstalled(identifier);\n\t\treturn uninstalled.length === 1;\n\t}\n\n\tprivate async filterUninstalled(...identifiers: ExtensionIdentifierWithVersion[]): Promise<string[]> {\n\t\tconst uninstalled: string[] = [];\n\t\tconst allUninstalled = await this.extensionsScanner.getUninstalledExtensions();\n\t\tfor (const identifier of identifiers) {\n\t\t\tif (!!allUninstalled[identifier.key()]) {\n\t\t\t\tuninstalled.push(identifier.key());\n\t\t\t}\n\t\t}\n\t\treturn uninstalled;\n\t}\n\n\tgetExtensionsReport(): Promise<IReportedExtension[]> {\n\t\tconst now = new Date().getTime();\n\n\t\tif (!this.reportedExtensions || now - this.lastReportTimestamp > 1000 * 60 * 5) { // 5 minute cache freshness\n\t\t\tthis.reportedExtensions = this.updateReportCache();\n\t\t\tthis.lastReportTimestamp = now;\n\t\t}\n\n\t\treturn this.reportedExtensions;\n\t}\n\n\tprivate async updateReportCache(): Promise<IReportedExtension[]> {\n\t\ttry {\n\t\t\tthis.logService.trace('ExtensionManagementService.refreshReportedCache');\n\t\t\tconst result = await this.galleryService.getExtensionsReport();\n\t\t\tthis.logService.trace(`ExtensionManagementService.refreshReportedCache - got ${result.length} reported extensions from service`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.logService.trace('ExtensionManagementService.refreshReportedCache - failed to get extension report');\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate reportTelemetry(eventName: string, extensionData: any, duration?: number, error?: Error): void {\n\t\tconst errorcode = error ? error instanceof ExtensionManagementError ? error.code : ERROR_UNKNOWN : undefined;\n\t\t/* __GDPR__\n\t\t\t\"extensionGallery:install\" : {\n\t\t\t\t\"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\t\t\"recommendationReason\": { \"retiredFromVersion\": \"1.23.0\", \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\t\t\"${include}\": [\n\t\t\t\t\t\"${GalleryExtensionTelemetryData}\"\n\t\t\t\t]\n\t\t\t}\n\t\t*/\n\t\t/* __GDPR__\n\t\t\t\"extensionGallery:uninstall\" : {\n\t\t\t\t\"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\t\t\"${include}\": [\n\t\t\t\t\t\"${GalleryExtensionTelemetryData}\"\n\t\t\t\t]\n\t\t\t}\n\t\t*/\n\t\t/* __GDPR__\n\t\t\t\"extensionGallery:update\" : {\n\t\t\t\t\"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\t\t\"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\t\t\"${include}\": [\n\t\t\t\t\t\"${GalleryExtensionTelemetryData}\"\n\t\t\t\t]\n\t\t\t}\n\t\t*/\n\t\tthis.telemetryService.publicLogError(eventName, { ...extensionData, success: !error, duration, errorcode });\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as https from 'https';\nimport * as http from 'http';\nimport * as streams from 'vs/base/common/stream';\nimport { createGunzip } from 'zlib';\nimport { parse as parseUrl } from 'url';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { isBoolean, isNumber } from 'vs/base/common/types';\nimport { canceled } from 'vs/base/common/errors';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IRequestService, IHTTPConfiguration } from 'vs/platform/request/common/request';\nimport { IRequestOptions, IRequestContext } from 'vs/base/parts/request/common/request';\nimport { getProxyAgent, Agent } from 'vs/platform/request/node/proxy';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { streamToBufferReadableStream } from 'vs/base/common/buffer';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { resolveShellEnv } from 'vs/platform/environment/node/shellEnv';\n\nexport interface IRawRequestFunction {\n\t(options: http.RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n}\n\nexport interface NodeRequestOptions extends IRequestOptions {\n\tagent?: Agent;\n\tstrictSSL?: boolean;\n\tgetRawRequest?(options: IRequestOptions): IRawRequestFunction;\n}\n\n/**\n * This service exposes the `request` API, while using the global\n * or configured proxy settings.\n */\nexport class RequestService extends Disposable implements IRequestService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate proxyUrl?: string;\n\tprivate strictSSL: boolean | undefined;\n\tprivate authorization?: string;\n\n\tconstructor(\n\t\t@IConfigurationService configurationService: IConfigurationService,\n\t\t@INativeEnvironmentService private readonly environmentService: INativeEnvironmentService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis.configure(configurationService.getValue<IHTTPConfiguration>());\n\t\tthis._register(configurationService.onDidChangeConfiguration(() => this.configure(configurationService.getValue()), this));\n\t}\n\n\tprivate configure(config: IHTTPConfiguration) {\n\t\tthis.proxyUrl = config.http && config.http.proxy;\n\t\tthis.strictSSL = !!(config.http && config.http.proxyStrictSSL);\n\t\tthis.authorization = config.http && config.http.proxyAuthorization;\n\t}\n\n\tasync request(options: NodeRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\t\tthis.logService.trace('RequestService#request', options.url);\n\n\t\tconst { proxyUrl, strictSSL } = this;\n\t\tconst env = {\n\t\t\t...process.env,\n\t\t\t...(await resolveShellEnv(this.logService, this.environmentService.args, process.env)),\n\t\t};\n\t\tconst agent = options.agent ? options.agent : await getProxyAgent(options.url || '', env, { proxyUrl, strictSSL });\n\n\t\toptions.agent = agent;\n\t\toptions.strictSSL = strictSSL;\n\n\t\tif (this.authorization) {\n\t\t\toptions.headers = {\n\t\t\t\t...(options.headers || {}),\n\t\t\t\t'Proxy-Authorization': this.authorization\n\t\t\t};\n\t\t}\n\n\t\treturn this._request(options, token);\n\t}\n\n\tprivate async getNodeRequest(options: IRequestOptions): Promise<IRawRequestFunction> {\n\t\tconst endpoint = parseUrl(options.url!);\n\t\tconst module = endpoint.protocol === 'https:' ? await import('https') : await import('http');\n\t\treturn module.request;\n\t}\n\n\tprivate _request(options: NodeRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\n\t\treturn new Promise<IRequestContext>(async (c, e) => {\n\t\t\tlet req: http.ClientRequest;\n\n\t\t\tconst endpoint = parseUrl(options.url!);\n\t\t\tconst rawRequest = options.getRawRequest\n\t\t\t\t? options.getRawRequest(options)\n\t\t\t\t: await this.getNodeRequest(options);\n\n\t\t\tconst opts: https.RequestOptions = {\n\t\t\t\thostname: endpoint.hostname,\n\t\t\t\tport: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),\n\t\t\t\tprotocol: endpoint.protocol,\n\t\t\t\tpath: endpoint.path,\n\t\t\t\tmethod: options.type || 'GET',\n\t\t\t\theaders: options.headers,\n\t\t\t\tagent: options.agent,\n\t\t\t\trejectUnauthorized: isBoolean(options.strictSSL) ? options.strictSSL : true\n\t\t\t};\n\n\t\t\tif (options.user && options.password) {\n\t\t\t\topts.auth = options.user + ':' + options.password;\n\t\t\t}\n\n\t\t\treq = rawRequest(opts, (res: http.IncomingMessage) => {\n\t\t\t\tconst followRedirects: number = isNumber(options.followRedirects) ? options.followRedirects : 3;\n\t\t\t\tif (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && followRedirects > 0 && res.headers['location']) {\n\t\t\t\t\tthis._request({\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\turl: res.headers['location'],\n\t\t\t\t\t\tfollowRedirects: followRedirects - 1\n\t\t\t\t\t}, token).then(c, e);\n\t\t\t\t} else {\n\t\t\t\t\tlet stream: streams.ReadableStreamEvents<Uint8Array> = res;\n\n\t\t\t\t\tif (res.headers['content-encoding'] === 'gzip') {\n\t\t\t\t\t\tstream = res.pipe(createGunzip());\n\t\t\t\t\t}\n\n\t\t\t\t\tc({ res, stream: streamToBufferReadableStream(stream) } as IRequestContext);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treq.on('error', e);\n\n\t\t\tif (options.timeout) {\n\t\t\t\treq.setTimeout(options.timeout);\n\t\t\t}\n\n\t\t\tif (options.data) {\n\t\t\t\tif (typeof options.data === 'string') {\n\t\t\t\t\treq.write(options.data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.end();\n\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\treq.abort();\n\t\t\t\te(canceled());\n\t\t\t});\n\t\t});\n\t}\n\n\tasync resolveProxy(url: string): Promise<string | undefined> {\n\t\treturn undefined; // currently not implemented in node\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { release, hostname } from 'os';\nimport * as fs from 'fs';\nimport { gracefulify } from 'graceful-fs';\nimport { isAbsolute, join } from 'vs/base/common/path';\nimport { raceTimeout } from 'vs/base/common/async';\nimport product from 'vs/platform/product/common/product';\nimport { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { InstantiationService } from 'vs/platform/instantiation/common/instantiationService';\nimport { INativeEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { NativeParsedArgs } from 'vs/platform/environment/common/argv';\nimport { NativeEnvironmentService } from 'vs/platform/environment/node/environmentService';\nimport { IExtensionManagementService, IExtensionGalleryService, IExtensionManagementCLIService } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { ExtensionManagementService } from 'vs/platform/extensionManagement/node/extensionManagementService';\nimport { ExtensionGalleryService } from 'vs/platform/extensionManagement/common/extensionGalleryService';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { combinedAppender, NullTelemetryService } from 'vs/platform/telemetry/common/telemetryUtils';\nimport { TelemetryService, ITelemetryServiceConfig } from 'vs/platform/telemetry/common/telemetryService';\nimport { resolveCommonProperties } from 'vs/platform/telemetry/common/commonProperties';\nimport { IRequestService } from 'vs/platform/request/common/request';\nimport { RequestService } from 'vs/platform/request/node/requestService';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { ConfigurationService } from 'vs/platform/configuration/common/configurationService';\nimport { AppInsightsAppender } from 'vs/platform/telemetry/node/appInsightsAppender';\nimport { IStateService } from 'vs/platform/state/node/state';\nimport { StateService } from 'vs/platform/state/node/stateService';\nimport { ILogService, getLogLevel, LogLevel, ConsoleLogger, MultiplexLogService, ILogger } from 'vs/platform/log/common/log';\nimport { Schemas } from 'vs/base/common/network';\nimport { SpdLogLogger } from 'vs/platform/log/node/spdlogLog';\nimport { buildTelemetryMessage } from 'vs/platform/telemetry/node/telemetry';\nimport { FileService } from 'vs/platform/files/common/fileService';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { DiskFileSystemProvider } from 'vs/platform/files/node/diskFileSystemProvider';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IProductService } from 'vs/platform/product/common/productService';\nimport { ExtensionManagementCLIService } from 'vs/platform/extensionManagement/common/extensionManagementCLIService';\nimport { URI } from 'vs/base/common/uri';\nimport { LocalizationsService } from 'vs/platform/localizations/node/localizations';\nimport { ILocalizationsService } from 'vs/platform/localizations/common/localizations';\nimport { setUnexpectedErrorHandler } from 'vs/base/common/errors';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { cwd } from 'vs/base/common/process';\n\nclass CliMain extends Disposable {\n\n\tconstructor(\n\t\tprivate argv: NativeParsedArgs\n\t) {\n\t\tsuper();\n\n\t\t// Enable gracefulFs\n\t\tgracefulify(fs);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Dispose on exit\n\t\tprocess.once('exit', () => this.dispose());\n\t}\n\n\tasync run(): Promise<void> {\n\n\t\t// Services\n\t\tconst [instantiationService, appenders] = await this.initServices();\n\n\t\treturn instantiationService.invokeFunction(async accessor => {\n\t\t\tconst logService = accessor.get(ILogService);\n\t\t\tconst fileService = accessor.get(IFileService);\n\t\t\tconst environmentService = accessor.get(INativeEnvironmentService);\n\t\t\tconst extensionManagementCLIService = accessor.get(IExtensionManagementCLIService);\n\n\t\t\t// Log info\n\t\t\tlogService.info('CLI main', this.argv);\n\n\t\t\t// Error handler\n\t\t\tthis.registerErrorHandler(logService);\n\n\t\t\t// Run based on argv\n\t\t\tawait this.doRun(environmentService, extensionManagementCLIService, fileService);\n\n\t\t\t// Flush the remaining data in AI adapter (with 1s timeout)\n\t\t\treturn raceTimeout(combinedAppender(...appenders).flush(), 1000);\n\t\t});\n\t}\n\n\tprivate async initServices(): Promise<[IInstantiationService, AppInsightsAppender[]]> {\n\t\tconst services = new ServiceCollection();\n\n\t\t// Product\n\t\tconst productService = { _serviceBrand: undefined, ...product };\n\t\tservices.set(IProductService, productService);\n\n\t\t// Environment\n\t\tconst environmentService = new NativeEnvironmentService(this.argv, productService);\n\t\tservices.set(INativeEnvironmentService, environmentService);\n\n\t\t// Init folders\n\t\tawait Promise.all([environmentService.appSettingsHome.fsPath, environmentService.extensionsPath].map(path => path ? fs.promises.mkdir(path, { recursive: true }) : undefined));\n\n\t\t// Log\n\t\tconst logLevel = getLogLevel(environmentService);\n\t\tconst loggers: ILogger[] = [];\n\t\tloggers.push(new SpdLogLogger('cli', join(environmentService.logsPath, 'cli.log'), true, logLevel));\n\t\tif (logLevel === LogLevel.Trace) {\n\t\t\tloggers.push(new ConsoleLogger(logLevel));\n\t\t}\n\n\t\tconst logService = this._register(new MultiplexLogService(loggers));\n\t\tservices.set(ILogService, logService);\n\n\t\t// Files\n\t\tconst fileService = this._register(new FileService(logService));\n\t\tservices.set(IFileService, fileService);\n\n\t\tconst diskFileSystemProvider = this._register(new DiskFileSystemProvider(logService));\n\t\tfileService.registerProvider(Schemas.file, diskFileSystemProvider);\n\n\t\t// Configuration\n\t\tconst configurationService = this._register(new ConfigurationService(environmentService.settingsResource, fileService));\n\t\tservices.set(IConfigurationService, configurationService);\n\n\t\t// Init config\n\t\tawait configurationService.initialize();\n\n\t\t// State\n\t\tconst stateService = new StateService(environmentService, logService);\n\t\tservices.set(IStateService, stateService);\n\n\t\t// Request\n\t\tservices.set(IRequestService, new SyncDescriptor(RequestService));\n\n\t\t// Extensions\n\t\tservices.set(IExtensionManagementService, new SyncDescriptor(ExtensionManagementService));\n\t\tservices.set(IExtensionGalleryService, new SyncDescriptor(ExtensionGalleryService));\n\t\tservices.set(IExtensionManagementCLIService, new SyncDescriptor(ExtensionManagementCLIService));\n\n\t\t// Localizations\n\t\tservices.set(ILocalizationsService, new SyncDescriptor(LocalizationsService));\n\n\t\t// Telemetry\n\t\tconst appenders: AppInsightsAppender[] = [];\n\t\tif (environmentService.isBuilt && !environmentService.isExtensionDevelopment && !environmentService.disableTelemetry && productService.enableTelemetry) {\n\t\t\tif (productService.aiConfig && productService.aiConfig.asimovKey) {\n\t\t\t\tappenders.push(new AppInsightsAppender('monacoworkbench', null, productService.aiConfig.asimovKey));\n\t\t\t}\n\n\t\t\tconst { appRoot, extensionsPath, installSourcePath } = environmentService;\n\n\t\t\tconst config: ITelemetryServiceConfig = {\n\t\t\t\tappender: combinedAppender(...appenders),\n\t\t\t\tsendErrorTelemetry: false,\n\t\t\t\tcommonProperties: resolveCommonProperties(fileService, release(), hostname(), process.arch, productService.commit, productService.version, stateService.getItem('telemetry.machineId'), productService.msftInternalDomains, installSourcePath),\n\t\t\t\tpiiPaths: [appRoot, extensionsPath]\n\t\t\t};\n\n\t\t\tservices.set(ITelemetryService, new SyncDescriptor(TelemetryService, [config]));\n\n\t\t} else {\n\t\t\tservices.set(ITelemetryService, NullTelemetryService);\n\t\t}\n\n\t\treturn [new InstantiationService(services), appenders];\n\t}\n\n\tprivate registerErrorHandler(logService: ILogService): void {\n\n\t\t// Install handler for unexpected errors\n\t\tsetUnexpectedErrorHandler(error => {\n\t\t\tconst message = toErrorMessage(error, true);\n\t\t\tif (!message) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogService.error(`[uncaught exception in CLI]: ${message}`);\n\t\t});\n\t}\n\n\tprivate async doRun(environmentService: INativeEnvironmentService, extensionManagementCLIService: IExtensionManagementCLIService, fileService: IFileService): Promise<void> {\n\n\t\t// Install Source\n\t\tif (this.argv['install-source']) {\n\t\t\treturn this.setInstallSource(environmentService, fileService, this.argv['install-source']);\n\t\t}\n\n\t\t// List Extensions\n\t\tif (this.argv['list-extensions']) {\n\t\t\treturn extensionManagementCLIService.listExtensions(!!this.argv['show-versions'], this.argv['category']);\n\t\t}\n\n\t\t// Install Extension\n\t\telse if (this.argv['install-extension'] || this.argv['install-builtin-extension']) {\n\t\t\treturn extensionManagementCLIService.installExtensions(this.asExtensionIdOrVSIX(this.argv['install-extension'] || []), this.argv['install-builtin-extension'] || [], !!this.argv['do-not-sync'], !!this.argv['force']);\n\t\t}\n\n\t\t// Uninstall Extension\n\t\telse if (this.argv['uninstall-extension']) {\n\t\t\treturn extensionManagementCLIService.uninstallExtensions(this.asExtensionIdOrVSIX(this.argv['uninstall-extension']), !!this.argv['force']);\n\t\t}\n\n\t\t// Locate Extension\n\t\telse if (this.argv['locate-extension']) {\n\t\t\treturn extensionManagementCLIService.locateExtension(this.argv['locate-extension']);\n\t\t}\n\n\t\t// Telemetry\n\t\telse if (this.argv['telemetry']) {\n\t\t\tconsole.log(buildTelemetryMessage(environmentService.appRoot, environmentService.extensionsPath));\n\t\t}\n\t}\n\n\tprivate asExtensionIdOrVSIX(inputs: string[]): (string | URI)[] {\n\t\treturn inputs.map(input => /\\.vsix$/i.test(input) ? URI.file(isAbsolute(input) ? input : join(cwd(), input)) : input);\n\t}\n\n\tprivate async setInstallSource(environmentService: INativeEnvironmentService, fileService: IFileService, installSource: string): Promise<void> {\n\t\tawait fileService.writeFile(URI.file(environmentService.installSourcePath), VSBuffer.fromString(installSource.slice(0, 30)));\n\t}\n}\n\nexport async function main(argv: NativeParsedArgs): Promise<void> {\n\tconst cliMain = new CliMain(argv);\n\n\ttry {\n\t\tawait cliMain.run();\n\t} finally {\n\t\tcliMain.dispose();\n\t}\n}\n"],"mappings":"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AAA,IAAA,KACA,EAAA,EAAA,GAAA,IAAA,KACA,EAAA,EAAA,GAAA,IAAA,KAEA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IACA,EAAA,EAAA,EAAA,KAAA,IAEA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,EAAA,IAAA,IACA,EAAA,EAAA,E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","names":[],"file":"cliProcessMain.js"}